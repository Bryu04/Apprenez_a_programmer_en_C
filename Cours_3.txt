                          Partie 3 : Utilisez les pointeurs et manipulez les tableaux


Créez et initialisez des pointeurs

Comprenez le problème posé

Un des plus gros problèmes avec les pointeurs, en plus d'être assez délicats à assimiler pour des débutants, c'est qu'on a du mal à comprendre à quoi ils peuvent bien servir.

Alors bien sûr, je pourrais vous dire : "Les pointeurs sont totalement indispensables, on s'en sert tout le temps, croyez-moi !", mais je sais que cela ne vous suffira pas.

Je vais donc vous poser un problème que vous ne pourrez pas résoudre sans utiliser de pointeurs. Ce sera en quelque sorte le fil rouge du chapitre.

Voici le problème : je veux écrire une fonction qui renvoie deux valeurs. "Impossible", me direz-vous ! En effet, on ne peut renvoyer qu'une valeur par fonction :

int fonction()
{
    return valeur;
}

Si on indique int  , on renverra un nombre de type int  (grâce à l'instruction return).

On peut aussi écrire une fonction qui ne renvoie aucune valeur avec le mot-clé void:

void fonction()
{

}

Mais renvoyer deux valeurs à la fois… c'est impossible. On ne peut pas faire deux return.

Supposons que je veuille écrire une fonction à laquelle on envoie un nombre de minutes. Celle-ci renverrait le nombre d'heures et minutes correspondant :

  1. Si on envoie 45, la fonction renvoie 0 heure et 45 minutes.

  2. Si on envoie 60, la fonction renvoie 1 heure et 0 minute.

  3. Si on envoie 90, la fonction renvoie 1 heure et 30 minutes.

Soyons fous, tentons le coup :

#include <stdio.h>
#include <stdlib.h>

/* Je mets le prototype en haut. Comme c'est un tout
petit programme je ne le mets pas dans un .h, mais
en temps normal (dans un vrai programme), j'aurais placé
le prototype dans un fichier .h bien entendu */

void decoupeMinutes(int heures, int minutes);

int main(int argc, char *argv[])
{
    int heures = 0, minutes = 90;

    /* On a une variable minutes qui vaut 90.
    Après appel de la fonction, je veux que ma variable
    "heures" vaille 1 et que ma variable "minutes" vaille 30 */

    decoupeMinutes(heures, minutes);

    printf("%d heures et %d minutes", heures, minutes);

    return 0;
}

void decoupeMinutes(int heures, int minutes)
{
    heures = minutes / 60;  // 90 / 60 = 1
    minutes = minutes % 60; // 90 % 60 = 30
}

Résultat :

0 heures et 90 minutes

Zut, zut, zut et rezut, ça n'a pas marché !

Que s'est-il passé ?

En fait, quand vous "envoyez" une variable à une fonction, une copie de la variable est réalisée : la variable heures dans la fonction decoupeMinutes n'est pas la même que celle de la fonction main  ! 

Votre fonction decoupeMinutes fait son travail : à l'intérieur de decoupeMinutes  , les variables heures et minutes ont les bonnes valeurs : 1 et 30.

Mais ensuite, la fonction s'arrête lorsqu'on arrive à l'accolade fermante. Comme on l'a appris dans les chapitres précédents, toutes les variables créées dans une fonction sont détruites à la fin de cette fonction. Vos copies de heures et de minutes sont donc supprimées.

On retourne ensuite à la fonction main  , dans laquelle vos variables heures et minutes valent toujours 0 et 90. C'est un échec !

Comme une fonction fait une copie des variables qu'on lui envoie, vous n'êtes pas du tout obligé d'appeler vos variables de la même façon que dans le main : vous pourriez très bien écrire : void decoupeMinutes(int h, int m) avec h pour heures et m pour minutes. Si vos variables ne s'appellent pas de la même façon dans la fonction et dans le main, ça ne pose donc aucun problème !

Bref, vous aurez beau retourner le problème dans tous les sens… vous pouvez essayer de renvoyer une valeur avec la fonction (en utilisant un return et en mettant le type int à la fonction), mais vous n'arriverez à renvoyer qu'une des deux valeurs. Vous ne pouvez pas renvoyer les deux valeurs à la fois. De plus, vous ne pouvez pas utiliser de variables globales car, comme on l'a vu, cette pratique est fortement déconseillée.

Voilà, le problème est posé. Voyons comment les pointeurs vont nous permettre de le résoudre !

Souvenez-vous du chapitre sur les variables

Analysez le schéma de la mémoire vive


Adresse     Valeur

0           145

1           3.8028322

2           0.827551

3           3901930

...         ...

3554511     940.5118


La première ligne représente la "cellule" du tout début de la mémoire vive.

Chaque cellule a un numéro, c'est son adresse.

La mémoire comporte un grand nombre d'adresses, commençant à l'adresse numéro 0 et se terminant à l'adresse numéro (insérez un très grand nombre ici).

Le nombre d'adresses disponibles dépend en fait de la quantité de mémoire dont dispose votre ordinateur.

À chaque adresse, on peut stocker UN SEUL nombre (et votre mémoire ne peut stocker ni des lettres, ni des phrases).

Pour contourner ce problème, on a inventé une table qui fait la liaison entre les nombres et les lettres. Cette table dit par exemple : « Le nombre 89 représente la lettre Y ».

Rappelez-vous comment faire afficher la valeur d'une variable

Quand vous créez une variable age de type int en tapant ceci :

  1.int age = 10;

… votre programme demande au système d'exploitation (Windows, par exemple) la permission d'utiliser un peu de mémoire. Le système d'exploitation répond en indiquant à quelle adresse en mémoire il vous laisse le droit d'inscrire votre nombre.

C'est d'ailleurs un des rôles principaux d'un système d'exploitation : il alloue de la mémoire aux programmes. C'est un peu lui le chef : il contrôle chaque programme, et vérifie que ce dernier a l'autorisation de se servir de la mémoire à l'endroit où il le fait.

Revenons à notre variable age. La valeur 10 a été inscrite quelque part en mémoire, disons par exemple à l'adresse n° 4655.

Ce qu'il se passe (et c'est le rôle du compilateur), c'est que le mot age dans votre programme est remplacé par l'adresse 4655 à l'exécution. Cela fait que, à chaque fois que vous avez tapé le mot age dans votre code source, il est remplacé par "4655", et votre ordinateur voit ainsi à quelle adresse il doit aller chercher en mémoire ! Du coup, l'ordinateur se rend en mémoire à l'adresse 4655, et répond fièrement : "La variable age vaut 10".

On sait donc comment récupérer la valeur de la variable : il suffit de taper age dans son code source. Si on veut afficher l'âge, on peut utiliser la fonction printf  :

  1.printf("La variable age vaut : %d", age);

Résultat à l'écran :

La variable age vaut : 10

Bon, rien de bien nouveau jusque-là : on sait afficher la valeur de la variable, mais saviez-vous que l'on peut aussi afficher l'adresse correspondante ?

Faites afficher l'adresse d'une variable

Pour afficher l'adresse de la variable, on doit :

  1. Utiliser le symbole%p  (le p du mot « pointeur ») dans le printf  .

  2. Envoyer à la fonction printf non pas la variable age  , mais son adresse… Et pour faire cela, vous devez 
     mettre le symbole &  devant la variable age  , comme je vous avais demandé de le faire pour les scanf  , 
     il y a quelque temps, sans vous expliquer pourquoi.

Tapez donc :

  1.printf("L'adresse de la variable age est : %p", &age);

Résultat :

L'adresse de la variable age est : 0x0023FF74

Ce que vous voyez là est l'adresse de la variable age au moment où j'ai lancé le programme sur mon ordinateur. Oui, oui, 0x0023FF74 est un nombre, il est simplement écrit dans le système hexadécimal, au lieu du système décimal dont nous avons l'habitude. Le préfixe "0x" indique que les symboles suivants sont écrits en hexadécimal. Si vous remplacez %p par %d  , vous obtiendrez un nombre décimal que vous connaissez.

Si vous exécutez ce programme sur votre ordinateur, l'adresse sera très certainement différente. Tout dépend de la place que vous avez en mémoire, des programmes que vous avez lancés, etc.
Il est totalement impossible de prédire à quelle adresse la variable sera stockée chez vous :

  - Si vous lancez votre programme plusieurs fois d'affilée, il se peut que l'adresse soit identique, la 
    mémoire n'ayant pas beaucoup changé entretemps.

  - Si par contre vous redémarrez votre ordinateur, vous aurez sûrement une valeur différente.

OK, mais où on veut en venir avec tout ça ?

Eh bien en fait, je veux vous faire retenir ceci :

  - age désigne la valeur de la variable ;

  - &age désigne l'adresse de la variable.

Avec  age  , l'ordinateur lit la valeur de la variable en mémoire et vous renvoie cette valeur.

Avec &age  , votre ordinateur vous dit en revanche à quelle adresse se trouve la variable.

Utilisez des pointeurs

Jusqu'ici, nous avons uniquement créé des variables faites pour contenir des nombres. Maintenant, nous allons apprendre à créer des variables faites pour contenir des adresses : ce sont justement ce qu'on appelle des pointeurs.

Mais… Les adresses sont des nombres aussi, non ? Ça revient à stocker des nombres encore et toujours !

C'est exact. Mais ces nombres auront une signification particulière : ils indiqueront l'adresse d'une autre variable en mémoire.

Créez un pointeur et donnez-lui une valeur par défaut

Pour créer une variable de type pointeur, on rajoute le symbole *  devant le nom de la variable.

  1.int *monPointeur;

Notez qu'on peut aussi écrire int* monPointeur; . Cela revient exactement au même.

Cependant, la première méthode est à préférer. En effet, si vous voulez déclarer plusieurs pointeurs sur la même ligne, vous serez obligé de mettre l'étoile devant le nom :int *pointeur1, *pointeur2, *pointeur3;  .

Comme je vous l'ai appris, il est important d'initialiser dès le début ses variables, en leur donnant la valeur 0, par exemple. C'est encore plus important de le faire avec les pointeurs !

Pour initialiser un pointeur, c'est-à-dire lui donner une valeur par défaut, on n'utilise généralement pas le nombre 0 mais le mot-clé NULL  (veillez à l'écrire en majuscules) :

  1.int *monPointeur = NULL;

Là, vous avez un pointeur initialisé à NULL  . Comme ça, vous saurez dans la suite de votre programme que votre pointeur ne contient aucune adresse.

Que se passe-t-il ?

Ce code va réserver une case en mémoire comme si vous aviez créé une variable normale.

Cependant, et c'est ce qui change, la valeur du pointeur est faite pour contenir une adresse. L'adresse… d'une autre variable.

Vous savez maintenant comment indiquer l'adresse d'une variable (au lieu de sa valeur) en utilisant le symbole &  , alors allons-y :

  1.int age = 10;
  2.int *pointeurSurAge = &age;

Qu'est-ce que ça veut dire ?

  1. La première ligne signifie : "Créer une variable de type int dont la valeur vaut 10".

  2. La seconde ligne signifie : "Créer une variable de type pointeur dont la valeur vaut l'adresse de la 
     variable age ". La seconde ligne fait donc deux choses à la fois. Si vous le souhaitez, pour ne pas tout 
     mélanger, sachez qu'on peut la découper en deux temps :

  1.int age = 10;
  2.int *pointeurSurAge; // 1) signifie "Je crée un pointeur"
  3.pointeurSurAge = &age; // 2) signifie "pointeurSurAge contient l'adresse de la variable age"

Vous avez remarqué qu'il n'y a pas de type "pointeur" comme il y a un type int et un type double

On n'écrit donc pas pointeur pointeurSurAge; !

Au lieu de ça, on utilise le symbole *  , mais on continue à écrire int  .

Qu'est-ce que ça signifie ?

En fait, on doit indiquer le type de variable pour laquelle le pointeur va contenir l'adresse.

Comme notre pointeur pointeurSurAge va contenir l'adresse de la variable age  (qui est de type int  ), alors mon pointeur doit être de type int*  !

Si ma variable age avait été de type double  , alors j'aurais dû écrire double *monPointeur  .

Vocabulaire : on dit que le pointeur pointeurSurAge  pointe sur la variable age  .

La schéma suivant résume ce qu'il s'est passé dans la mémoire :

Dans ce schéma :

  - la variable age a été placée à l'adresse 177450 (vous voyez d'ailleurs que sa valeur est 10) ;

  - et le pointeur pointeurSurAge a été placé à l'adresse 3 (c'est tout à fait le fruit du hasard).

Lorsque mon pointeur est créé, le système d'exploitation réserve une case en mémoire comme il l'a fait pour age  . La différence ici, c'est que la valeur de pointeurSurAge est un peu particulière. Regardez bien le schéma : c'est l'adresse de la variable age  !

Ceci est le secret absolu de tout programme écrit en langage C. On y est, nous venons de rentrer dans le monde merveilleux des pointeurs !

Et… ça sert à quoi ?

Maintenant, on a un pointeurSurAge qui contient l'adresse de la variable age  .

Essayons de voir ce que contient le pointeur à l'aide d'un printf  :


  1.int age = 10;
  2.int *pointeurSurAge = &age;
  3.
  4.printf("%d", pointeurSurAge);

177450

Hum. En fait, cela n'est pas très étonnant. On demande la valeur de pointeurSurAge  , et sa valeur, c'est l'adresse de la variable age  (177450).

Comment faire pour demander à avoir la valeur de la variable se trouvant à l'adresse indiquée dans pointeurSurAge  ?

Il faut placer le symbole *  devant le nom du pointeur :

  1.int age = 10;
  2.int *pointeurSurAge = &age;
  3.
  4.printf("%d", *pointeurSurAge);

10

Hourra ! Nous y sommes arrivés !

En plaçant le symbole *  devant le nom du pointeur, on accède à la valeur de la variable age  . Si au contraire on avait utilisé le symbole &  devant le nom du pointeur, on aurait obtenu l'adresse à laquelle se trouve le pointeur (ici, c'est 3).

Qu'est-ce qu'on y gagne ? On a simplement réussi à compliquer les choses ici. On n'avait pas besoin d'un pointeur pour afficher la valeur de la variable age  !

Cette question (que vous devez inévitablement vous poser) est légitime. Actuellement l'intérêt n'est pas évident, mais petit à petit, tout au long des chapitres suivants, vous comprendrez que tout cela n'a pas été inventé par pur plaisir de compliquer les choses.

Faites l'impasse sur la frustration que vous devez ressentir. Si vous avez compris le principe, c'est l'essentiel. Les choses s'éclairciront d'elles-mêmes par la suite.

Retenez le principe de base d'un pointeur

Voici ce qu'il faut avoir compris et ce qu'il faut retenir pour la suite de ce chapitre :

Sur une variable, comme la variable age  :

  - age signifie : "Je veux la valeur de la variable age  " ;

  - &age signifie : "Je veux l'adresse à laquelle se trouve la variable age  ".

Sur un pointeur, comme pointeurSurAge  :

  - pointeurSurAge signifie : "Je veux la valeur de pointeurSurAge  " (cette valeur étant une adresse) ;

  - *pointeurSurAge signifie : "Je veux la valeur de la variable qui se trouve à l'adresse contenue dans 
    pointeurSurAge  ".

Contentez-vous de bien retenir ces quatre points. Faites des tests et vérifiez que ça marche.

Ce schéma devrait bien vous aider à situer chacun de ces éléments.


Attention à ne pas confondre les différentes significations de l'étoile !

Lorsque vous déclarez un pointeur, l'étoile indique qu'on veut créer un pointeur :int *pointeurSurAge;  .

En revanche, lorsqu'ensuite vous utilisez votre pointeur en écrivant printf("%d", *pointeurSurAge);  , cela ne signifie pas "Je veux créer un pointeur", mais : "Je veux la valeur de la variable sur laquelle pointe mon pointeurSurAge  ".

Ce n’est sans doute pas facile d'assimiler toutes ces notions d’un coup. Je vous propose une petite vidéo pour résumer tous ces points :

Ce que l'on vient de voir est fondamental. Il faut connaître cela par cœur, et surtout le comprendre. N'hésitez pas à lire et relire ce chapitre.

En résumé

- Chaque variable est stockée à une adresse précise en mémoire.

- Les pointeurs sont semblables aux variables, à ceci près qu'au lieu de stocker un nombre, ils stockent 
  l'adresse à laquelle se trouve une variable en mémoire.

- Si on place un symbole & devant un nom de variable, on obtient son adresse au lieu de sa valeur (ex. : 
  &age  ).

- Si on place un symbole * devant un nom de pointeur, on obtient la valeur de la variable stockée à l'adresse 
  indiquée par le pointeur.

Félicitations, vous êtes arrivé à la fin de ce chapitre ! Dans le prochain, on continue sur notre lancée et on récupère le problème que l'on avait posé pour comprendre l'intérêt des pointeurs. C'est parti !

##############################################################################################################

Envoyez des pointeurs

Envoyez un pointeur à une fonction

Le gros intérêt des pointeurs (mais ce n'est pas le seul) est qu'on peut les envoyer à des fonctions pour qu'ils modifient directement une variable en mémoire, et non une copie comme on l'a vu.

Comment ça marche ?

Il y a en fait plusieurs façons de faire.

Envoyez un pointeur dans la fonction triplePointeur 

Voici un premier exemple :


void triplePointeur(int *pointeurSurNombre);

int main(int argc, char *argv[])
{
    int nombre = 5;

    triplePointeur(&nombre); // On envoie l'adresse de nombre à la fonction
    printf("%d", nombre); // On affiche la variable nombre. La fonction a directement modifié la valeur de la variable car elle connaissait son adresse

    return 0;
}

void triplePointeur(int *pointeurSurNombre)
{
    *pointeurSurNombre *= 3; // On multiplie par 3 la valeur de nombre
}


15

La fonction triplePointeur prend un paramètre de type int*  (c'est-à-dire un pointeur sur int  ). Voici ce qu'il se passe dans l'ordre, en partant du début du main  :

  1. Une variable nombre est créée dans le main. On lui affecte la valeur 5. Ça, vous connaissez.

  2. On appelle la fonction triplePointeur. On lui envoie en paramètre l'adresse de notre variable nombre.

  3. La fonction triplePointeur reçoit cette adresse dans pointeurSurNombre (à l'intérieur de la fonction 
     triplePointeur, on a donc un pointeur pointeurSurNombre qui contient l'adresse de la variable nombre ).

  4. Maintenant qu'on a un pointeur sur nombre  , on peut modifier directement la variable nombre en mémoire 
     avec *pointeurSurNombre pour désigner la variable nombre(pour l'exemple, on fait un simple test : on 
     multiplie la variable nombre par 3).

  5. De retour dans la fonction main  , notre nombre vaut maintenant 15 car la fonction triplePointeur a 
     modifié directement la valeur de nombre.


Bien sûr, j'aurais pu faire un simple return comme on a appris à le faire dans le chapitre sur les fonctions. Mais l'intérêt, là, c'est que de cette manière, en utilisant des pointeurs, on peut modifier la valeur de plusieurs variables en mémoire (on peut donc « renvoyer plusieurs valeurs »). Nous ne sommes plus limités à une seule valeur !

Quel est l'intérêt maintenant d'utiliser un return dans une fonction, si on peut se servir des pointeurs pour modifier des valeurs ?

Ça dépendra de vous et de votre programme. C'est à vous de décider. Il faut savoir que les return sont toujours utilisés en C. Le plus souvent, on s'en sert pour renvoyer ce qu'on appelle un code d'erreur : la fonction renvoie :

  - "0 success" ;

  - "1 (ou any non-0) failure", s'il y a eu une erreur pendant le déroulement de la fonction.

Alternative : ajoutez un pointeur dans la fonction  main

Dans le code source qu'on vient de voir, il n'y avait pas de pointeur dans la fonction main  . Juste une variable nombre  . Le seul pointeur qu'il y avait vraiment était dans la fonction triplePointeur  (de type int*  ).

Il faut absolument que vous sachiez qu'il y a une autre façon d'écrire le code précédent, en ajoutant un pointeur dans la fonction main  :



void triplePointeur(int *pointeurSurNombre);

int main(int argc, char *argv[])
{
    int nombre = 5;
    int *pointeur = &nombre; // pointeur prend l'adresse de nombre

    triplePointeur(pointeur); // On envoie pointeur (l'adresse de nombre) à la fonction
    printf("%d", *pointeur); // On affiche la valeur de nombre avec *pointeur

    return 0;
}

void triplePointeur(int *pointeurSurNombre)
{
    *pointeurSurNombre *= 3; // On multiplie par 3 la valeur de nombre
}


Comparez bien ce code source avec le précédent. Il y a de subtiles différences, et pourtant le résultat est strictement le même :

15

Ce qui compte, c'est d'envoyer l'adresse de la variable nombre à la fonction.

Or, pointeur vaut l'adresse de la variable nombre  , donc c'est bon de ce côté !

On le fait seulement d'une manière différente en créant un pointeur dans la fonction main  .

Dans le printf  (et c'est juste pour l'exercice), j'affiche le contenu de la variable nombre en tapant *pointeur  . Notez qu'à la place, j'aurais pu écrire nombre  : le résultat aurait été identique car *pointeur et nombre désignent la même chose dans la mémoire.

Dans le chapitre "Déclarez des variables", nous avons vu comment récupérer la saisie d’un utilisateur, et nous avons utilisé des pointeurs sans vraiment le savoir.

C'était en fait en appelant la fonction scanf . En effet, cette fonction lit ce que l'utilisateur a entré au clavier et renvoie le résultat.

Pour que la fonction puisse modifier directement le contenu de votre variable afin d'y placer la valeur tapée au clavier, elle a besoin de l'adresse de la variable :

  1.int nombre = 0;
  2.scanf("%d", &nombre);

La fonction travaille avec un pointeur sur la variable nombre   , et peut ainsi modifier directement le contenu de nombre  .

Comme on vient de le voir, on pourrait créer un pointeur qu'on enverrait à la fonction scanf  :

  1.int nombre = 0;
  2.int *pointeur = &nombre;
  3.scanf("%d", pointeur);

Attention à ne pas mettre le symbole & devant pointeur dans la fonction scanf  !

Ici, pointeur contient lui-même l'adresse de la variable nombre , inutile de mettre &.

Si vous faisiez ça, vous enverriez l'adresse où se trouve le pointeur : or, c'est l'adresse de nombre dont on a besoin.

Ce n’est peut-être pas évident de comprendre ces deux méthodes, c’est normal, pas d'inquiétude. C’est pour ça que je vous propose une vidéo qui explique ces deux façons d’envoyer un pointeur à une fonction :

Reprenez notre problème de départ

Il est temps de retrouver notre fil rouge : si vous avez compris ce chapitre, vous devriez être capable de résoudre le problème, maintenant.

Voici la solution :

void decoupeMinutes(int* pointeurHeures, int* pointeurMinutes);

int main(int argc, char *argv[])
{
    int heures = 0, minutes = 90;

    // On envoie l'adresse de heures et minutes
    decoupeMinutes(&heures, &minutes);

    // Cette fois, les valeurs ont été modifiées !
    printf("%d heures et %d minutes", heures, minutes);

    return 0;
}

void decoupeMinutes(int* pointeurHeures, int* pointeurMinutes)
{
    /* Attention à ne pas oublier de mettre une étoile devant le nom
    des pointeurs ! Comme ça, vous pouvez modifier la valeur des variables,
    et non leur adresse ! Vous ne voudriez pas diviser des adresses,
    n'est-ce pas ? ;o) */
    *pointeurHeures = *pointeurMinutes / 60;
    *pointeurMinutes = *pointeurMinutes % 60; 
}

Résultat :

1 heures et 30 minutes

Rien ne devrait vous surprendre dans ce code source.

Toutefois, comme on n'est jamais trop prudent, voyons ce qui se passe dans le détail :

  1. Les variables heures et minutes sont créées dans le main  .

  2. On envoie à la fonction decoupeMinutes l'adresse de heures et minutes  .

  3. La fonction decoupeMinutes récupère ces adresses dans des pointeurs appeléspointeurHeures et 
     pointeurMinutes. Notez que, là encore, le nom importe peu. J'aurais pu les appeler h et m, ou même heures 
     et minutes. Je ne l'ai pas fait car je ne veux pas que vous risquiez de confondre avec les variables 
     heures et minutes du main, qui ne sont pas les mêmes.

  4. La fonction decoupeMinutes modifie directement les valeurs des variables heures et minutes en mémoire, 
     car elle possède leurs adresses dans des pointeurs. La seule contrainte, un peu gênante je dois le 
     reconnaître, c'est qu'il faut impérativement mettre une étoile devant le nom des pointeurs si on veut 
     modifier la valeur de heures et de minutes. Si on n'avait pas fait ça, on aurait modifié l'adresse 
     contenue dans les pointeurs, ce qui n'aurait servi… à rien.

Il est possible de résoudre le "problème" sans utiliser de pointeurs, en contournant certaines règles que nous nous sommes fixées :

on peut utiliser des variables globales (mais on l'a dit, c'est mal) ;

ou encore faire un printf dans la fonction decoupeMinutes  (alors que c'est dans le main qu'on veut faire le printf  !).

L'exercice est un peu scolaire et peut donc être contourné si vous êtes malin, ce qui vous fait peut-être douter de l'intérêt des pointeurs. Soyez assuré que cet intérêt vous paraîtra de plus en plus évident au cours des chapitres suivants.

En résumé

  - Les pointeurs constituent une notion essentielle du langage C, mais néanmoins un peu complexe au début. Il 
    faut prendre le temps de bien comprendre comment ils fonctionnent, car beaucoup d'autres notions sont 
    basées dessus.

Ce n’est peut-être pas encore clair comme l’eau de roche, mais laissez-vous le temps d’assimiler la notion de pointeur, et n’hésitez pas à vous entraîner à les manipuler. Quand vous serez prêt, je vous retrouve au prochain chapitre pour découvrir la notion de tableau.

##############################################################################################################

Créez des variables de type "tableaux"

Ce chapitre est la suite directe des pointeurs, et va vous faire comprendre un peu plus leur utilité.

Les tableaux sont très utilisés en C, car ils permettent d'organiser une série de valeurs.

Comprenez le fonctionnement des tableaux en mémoire

Les tableaux sont une suite de variables de même type, stockées côte à côte en mémoire. Concrètement, il s'agit de "grosses variables" pouvant contenir plusieurs nombres du même type : long  , int  , char  , double  …

Un tableau a une dimension bien précise. Il peut occuper 2, 3, 10, 150, 2 500 cases, c'est vous qui décidez.

Voici le schéma d'un tableau de 4 cases en mémoire qui commence à l'adresse 1600.



Adresse             Valeur

1600                 10

1601                 23

1602                 505

1603                 8



Lorsque vous demandez à créer un tableau de 4 cases en mémoire, votre programme demande au système d'exploitation la permission d'utiliser 4 cases en mémoire.

Ces 4 cases doivent être contiguës, c'est-à-dire les unes à la suite des autres. Comme vous le voyez, les adresses se suivent : 1600, 1601, 1602, 1603. Il n'y a pas de "trou" au milieu.

Chaque case du tableau contient un nombre du même type. Si le tableau est de type int, alors chaque case du tableau contiendra un int. On ne peut pas faire de tableau contenant à la fois des int et des double, par exemple.

En résumé, voici ce qu'il faut retenir sur les tableaux :

  - Lorsqu'un tableau est créé, il prend un espace contigu en mémoire : les cases sont les unes à la suite des 
    autres.

  - Toutes les cases d'un tableau sont du même type. Ainsi, un tableau de int contiendra uniquement des int  , 
    et pas autre chose.

Définissez un tableau

Voyons comment définir un tableau de 4 int  :

  1.int tableau[4];

Voilà. Il suffit de rajouter entre crochets le nombre de cases que vous voulez mettre dans votre tableau. Il n'y a pas de limite (à part peut-être la taille de votre mémoire, quand même).

Maintenant, comment accéder à chaque case du tableau ?

Il faut écrire tableau[numeroDeLaCase]  .

Attention : un tableau commence à l'indice n° 0 ! Notre tableau de 4 int a donc les indices 0, 1, 2 et 3. Il n'y a pas d'indice 4 dans un tableau de 4 cases ! C'est une source d'erreurs très courantes, souvenez-vous-en.

Si je veux mettre dans mon tableau les mêmes valeurs que celles indiquées dans le schéma plus haut, je devrai donc écrire :

  1.int tableau[4];
  2.
  3.tableau[0] = 10;
  4.tableau[1] = 23;
  5.tableau[2] = 505;
  6.tableau[3] = 8;

Je ne vois pas le rapport entre les tableaux et les pointeurs ?

En fait, si vous écrivez juste tableau  , vous obtenez un pointeur. C'est un pointeur sur la première case du tableau. Faites le test :

  1.int tableau[4];
  2.
  3.printf("%d", tableau);

Résultat, on voit l'adresse où se trouve tableau  :

1600

En revanche, si vous indiquez l'indice de la case du tableau entre crochets, vous obtenez la valeur :

  1.int tableau[4];
  2.
  3.printf("%d", tableau[0]);

10

De même pour les autres indices. Notez que comme tableau est un pointeur, on peut utiliser le symbole * pour connaître la première valeur :

  1.int tableau[4];
  2.
  3.printf("%d", *tableau);

10

Il est aussi possible d'obtenir la valeur de la seconde case avec *(tableau + 1)  (adresse de tableau + 1). Les deux lignes suivantes sont donc identiques :

  1.tableau[1] // Renvoie la valeur de la seconde case (la première case étant 0)
  2.*(tableau + 1) // Identique : renvoie la valeur contenue dans la seconde case

En clair, quand vous écrivez tableau[0], vous demandez la valeur qui se trouve à l'adresse tableau + 0 case (c'est-à-dire, dans notre cas, la valeur 10 associée à l'adresse 1600).

Si vous écrivez tableau[1], vous demandez la valeur se trouvant à l'adresse tableau + 1 case (c'est-à-dire, dans notre cas, la valeur 23 associée à l'adresse 1601).

Et ainsi de suite pour les autres valeurs.

Attention : Il est interdit de créer un tableau dont la taille dépend d’une variable, du moins pour l’instant. C’est ce qu’on appelle une allocation dynamique, nous verrons cette notion bien plus loin dans le cours. Pour l’instant, vous devez écrire noir sur blanc le nombre correspondant à la taille du tableau.

Voyons dans vidéo suivante comment créer un tableau et accéder aux différentes cases de celui-ci :

