                          Partie 3 : Utilisez les pointeurs et manipulez les tableaux


Créez et initialisez des pointeurs

Comprenez le problème posé

Un des plus gros problèmes avec les pointeurs, en plus d'être assez délicats à assimiler pour des débutants, c'est qu'on a du mal à comprendre à quoi ils peuvent bien servir.

Alors bien sûr, je pourrais vous dire : "Les pointeurs sont totalement indispensables, on s'en sert tout le temps, croyez-moi !", mais je sais que cela ne vous suffira pas.

Je vais donc vous poser un problème que vous ne pourrez pas résoudre sans utiliser de pointeurs. Ce sera en quelque sorte le fil rouge du chapitre.

Voici le problème : je veux écrire une fonction qui renvoie deux valeurs. "Impossible", me direz-vous ! En effet, on ne peut renvoyer qu'une valeur par fonction :

int fonction()
{
    return valeur;
}

Si on indique int  , on renverra un nombre de type int  (grâce à l'instruction return).

On peut aussi écrire une fonction qui ne renvoie aucune valeur avec le mot-clé void:

void fonction()
{

}

Mais renvoyer deux valeurs à la fois… c'est impossible. On ne peut pas faire deux return.

Supposons que je veuille écrire une fonction à laquelle on envoie un nombre de minutes. Celle-ci renverrait le nombre d'heures et minutes correspondant :

  1. Si on envoie 45, la fonction renvoie 0 heure et 45 minutes.

  2. Si on envoie 60, la fonction renvoie 1 heure et 0 minute.

  3. Si on envoie 90, la fonction renvoie 1 heure et 30 minutes.

Soyons fous, tentons le coup :

#include <stdio.h>
#include <stdlib.h>

/* Je mets le prototype en haut. Comme c'est un tout
petit programme je ne le mets pas dans un .h, mais
en temps normal (dans un vrai programme), j'aurais placé
le prototype dans un fichier .h bien entendu */

void decoupeMinutes(int heures, int minutes);

int main(int argc, char *argv[])
{
    int heures = 0, minutes = 90;

    /* On a une variable minutes qui vaut 90.
    Après appel de la fonction, je veux que ma variable
    "heures" vaille 1 et que ma variable "minutes" vaille 30 */

    decoupeMinutes(heures, minutes);

    printf("%d heures et %d minutes", heures, minutes);

    return 0;
}

void decoupeMinutes(int heures, int minutes)
{
    heures = minutes / 60;  // 90 / 60 = 1
    minutes = minutes % 60; // 90 % 60 = 30
}

Résultat :

0 heures et 90 minutes

Zut, zut, zut et rezut, ça n'a pas marché !

Que s'est-il passé ?

En fait, quand vous "envoyez" une variable à une fonction, une copie de la variable est réalisée : la variable heures dans la fonction decoupeMinutes n'est pas la même que celle de la fonction main  ! 

Votre fonction decoupeMinutes fait son travail : à l'intérieur de decoupeMinutes  , les variables heures et minutes ont les bonnes valeurs : 1 et 30.

Mais ensuite, la fonction s'arrête lorsqu'on arrive à l'accolade fermante. Comme on l'a appris dans les chapitres précédents, toutes les variables créées dans une fonction sont détruites à la fin de cette fonction. Vos copies de heures et de minutes sont donc supprimées.

On retourne ensuite à la fonction main  , dans laquelle vos variables heures et minutes valent toujours 0 et 90. C'est un échec !

Comme une fonction fait une copie des variables qu'on lui envoie, vous n'êtes pas du tout obligé d'appeler vos variables de la même façon que dans le main : vous pourriez très bien écrire : void decoupeMinutes(int h, int m) avec h pour heures et m pour minutes. Si vos variables ne s'appellent pas de la même façon dans la fonction et dans le main, ça ne pose donc aucun problème !

Bref, vous aurez beau retourner le problème dans tous les sens… vous pouvez essayer de renvoyer une valeur avec la fonction (en utilisant un return et en mettant le type int à la fonction), mais vous n'arriverez à renvoyer qu'une des deux valeurs. Vous ne pouvez pas renvoyer les deux valeurs à la fois. De plus, vous ne pouvez pas utiliser de variables globales car, comme on l'a vu, cette pratique est fortement déconseillée.

Voilà, le problème est posé. Voyons comment les pointeurs vont nous permettre de le résoudre !

Souvenez-vous du chapitre sur les variables

Analysez le schéma de la mémoire vive


Adresse     Valeur

0           145

1           3.8028322

2           0.827551

3           3901930

...         ...

3554511     940.5118


La première ligne représente la "cellule" du tout début de la mémoire vive.

Chaque cellule a un numéro, c'est son adresse.

La mémoire comporte un grand nombre d'adresses, commençant à l'adresse numéro 0 et se terminant à l'adresse numéro (insérez un très grand nombre ici).

Le nombre d'adresses disponibles dépend en fait de la quantité de mémoire dont dispose votre ordinateur.

À chaque adresse, on peut stocker UN SEUL nombre (et votre mémoire ne peut stocker ni des lettres, ni des phrases).

Pour contourner ce problème, on a inventé une table qui fait la liaison entre les nombres et les lettres. Cette table dit par exemple : « Le nombre 89 représente la lettre Y ».

Rappelez-vous comment faire afficher la valeur d'une variable

Quand vous créez une variable age de type int en tapant ceci :

  1.int age = 10;

… votre programme demande au système d'exploitation (Windows, par exemple) la permission d'utiliser un peu de mémoire. Le système d'exploitation répond en indiquant à quelle adresse en mémoire il vous laisse le droit d'inscrire votre nombre.

C'est d'ailleurs un des rôles principaux d'un système d'exploitation : il alloue de la mémoire aux programmes. C'est un peu lui le chef : il contrôle chaque programme, et vérifie que ce dernier a l'autorisation de se servir de la mémoire à l'endroit où il le fait.

Revenons à notre variable age. La valeur 10 a été inscrite quelque part en mémoire, disons par exemple à l'adresse n° 4655.

Ce qu'il se passe (et c'est le rôle du compilateur), c'est que le mot age dans votre programme est remplacé par l'adresse 4655 à l'exécution. Cela fait que, à chaque fois que vous avez tapé le mot age dans votre code source, il est remplacé par "4655", et votre ordinateur voit ainsi à quelle adresse il doit aller chercher en mémoire ! Du coup, l'ordinateur se rend en mémoire à l'adresse 4655, et répond fièrement : "La variable age vaut 10".

On sait donc comment récupérer la valeur de la variable : il suffit de taper age dans son code source. Si on veut afficher l'âge, on peut utiliser la fonction printf  :

  1.printf("La variable age vaut : %d", age);

Résultat à l'écran :

La variable age vaut : 10

Bon, rien de bien nouveau jusque-là : on sait afficher la valeur de la variable, mais saviez-vous que l'on peut aussi afficher l'adresse correspondante ?

Faites afficher l'adresse d'une variable

Pour afficher l'adresse de la variable, on doit :

  1. Utiliser le symbole%p  (le p du mot « pointeur ») dans le printf  .

  2. Envoyer à la fonction printf non pas la variable age  , mais son adresse… Et pour faire cela, vous devez 
     mettre le symbole &  devant la variable age  , comme je vous avais demandé de le faire pour les scanf  , 
     il y a quelque temps, sans vous expliquer pourquoi.

Tapez donc :

  1.printf("L'adresse de la variable age est : %p", &age);

Résultat :

L'adresse de la variable age est : 0x0023FF74

Ce que vous voyez là est l'adresse de la variable age au moment où j'ai lancé le programme sur mon ordinateur. Oui, oui, 0x0023FF74 est un nombre, il est simplement écrit dans le système hexadécimal, au lieu du système décimal dont nous avons l'habitude. Le préfixe "0x" indique que les symboles suivants sont écrits en hexadécimal. Si vous remplacez %p par %d  , vous obtiendrez un nombre décimal que vous connaissez.

Si vous exécutez ce programme sur votre ordinateur, l'adresse sera très certainement différente. Tout dépend de la place que vous avez en mémoire, des programmes que vous avez lancés, etc.
Il est totalement impossible de prédire à quelle adresse la variable sera stockée chez vous :

  - Si vous lancez votre programme plusieurs fois d'affilée, il se peut que l'adresse soit identique, la 
    mémoire n'ayant pas beaucoup changé entretemps.

  - Si par contre vous redémarrez votre ordinateur, vous aurez sûrement une valeur différente.

OK, mais où on veut en venir avec tout ça ?

Eh bien en fait, je veux vous faire retenir ceci :

  - age désigne la valeur de la variable ;

  - &age désigne l'adresse de la variable.

Avec  age  , l'ordinateur lit la valeur de la variable en mémoire et vous renvoie cette valeur.

Avec &age  , votre ordinateur vous dit en revanche à quelle adresse se trouve la variable.

Utilisez des pointeurs

Jusqu'ici, nous avons uniquement créé des variables faites pour contenir des nombres. Maintenant, nous allons apprendre à créer des variables faites pour contenir des adresses : ce sont justement ce qu'on appelle des pointeurs.

Mais… Les adresses sont des nombres aussi, non ? Ça revient à stocker des nombres encore et toujours !

C'est exact. Mais ces nombres auront une signification particulière : ils indiqueront l'adresse d'une autre variable en mémoire.

Créez un pointeur et donnez-lui une valeur par défaut

Pour créer une variable de type pointeur, on rajoute le symbole *  devant le nom de la variable.

  1.int *monPointeur;

Notez qu'on peut aussi écrire int* monPointeur; . Cela revient exactement au même.

Cependant, la première méthode est à préférer. En effet, si vous voulez déclarer plusieurs pointeurs sur la même ligne, vous serez obligé de mettre l'étoile devant le nom :int *pointeur1, *pointeur2, *pointeur3;  .

Comme je vous l'ai appris, il est important d'initialiser dès le début ses variables, en leur donnant la valeur 0, par exemple. C'est encore plus important de le faire avec les pointeurs !

Pour initialiser un pointeur, c'est-à-dire lui donner une valeur par défaut, on n'utilise généralement pas le nombre 0 mais le mot-clé NULL  (veillez à l'écrire en majuscules) :

  1.int *monPointeur = NULL;

Là, vous avez un pointeur initialisé à NULL  . Comme ça, vous saurez dans la suite de votre programme que votre pointeur ne contient aucune adresse.

Que se passe-t-il ?

Ce code va réserver une case en mémoire comme si vous aviez créé une variable normale.

Cependant, et c'est ce qui change, la valeur du pointeur est faite pour contenir une adresse. L'adresse… d'une autre variable.

Vous savez maintenant comment indiquer l'adresse d'une variable (au lieu de sa valeur) en utilisant le symbole &  , alors allons-y :

  1.int age = 10;
  2.int *pointeurSurAge = &age;

Qu'est-ce que ça veut dire ?

  1. La première ligne signifie : "Créer une variable de type int dont la valeur vaut 10".

  2. La seconde ligne signifie : "Créer une variable de type pointeur dont la valeur vaut l'adresse de la 
     variable age ". La seconde ligne fait donc deux choses à la fois. Si vous le souhaitez, pour ne pas tout 
     mélanger, sachez qu'on peut la découper en deux temps :

  1.int age = 10;
  2.int *pointeurSurAge; // 1) signifie "Je crée un pointeur"
  3.pointeurSurAge = &age; // 2) signifie "pointeurSurAge contient l'adresse de la variable age"

Vous avez remarqué qu'il n'y a pas de type "pointeur" comme il y a un type int et un type double

On n'écrit donc pas pointeur pointeurSurAge; !

Au lieu de ça, on utilise le symbole *  , mais on continue à écrire int  .

Qu'est-ce que ça signifie ?

En fait, on doit indiquer le type de variable pour laquelle le pointeur va contenir l'adresse.

Comme notre pointeur pointeurSurAge va contenir l'adresse de la variable age  (qui est de type int  ), alors mon pointeur doit être de type int*  !

Si ma variable age avait été de type double  , alors j'aurais dû écrire double *monPointeur  .

Vocabulaire : on dit que le pointeur pointeurSurAge  pointe sur la variable age  .

La schéma suivant résume ce qu'il s'est passé dans la mémoire :

Dans ce schéma :

  - la variable age a été placée à l'adresse 177450 (vous voyez d'ailleurs que sa valeur est 10) ;

  - et le pointeur pointeurSurAge a été placé à l'adresse 3 (c'est tout à fait le fruit du hasard).

Lorsque mon pointeur est créé, le système d'exploitation réserve une case en mémoire comme il l'a fait pour age  . La différence ici, c'est que la valeur de pointeurSurAge est un peu particulière. Regardez bien le schéma : c'est l'adresse de la variable age  !

Ceci est le secret absolu de tout programme écrit en langage C. On y est, nous venons de rentrer dans le monde merveilleux des pointeurs !

Et… ça sert à quoi ?

Maintenant, on a un pointeurSurAge qui contient l'adresse de la variable age  .

Essayons de voir ce que contient le pointeur à l'aide d'un printf  :


  1.int age = 10;
  2.int *pointeurSurAge = &age;
  3.
  4.printf("%d", pointeurSurAge);

177450

Hum. En fait, cela n'est pas très étonnant. On demande la valeur de pointeurSurAge  , et sa valeur, c'est l'adresse de la variable age  (177450).

Comment faire pour demander à avoir la valeur de la variable se trouvant à l'adresse indiquée dans pointeurSurAge  ?

Il faut placer le symbole *  devant le nom du pointeur :

  1.int age = 10;
  2.int *pointeurSurAge = &age;
  3.
  4.printf("%d", *pointeurSurAge);

10

Hourra ! Nous y sommes arrivés !

En plaçant le symbole *  devant le nom du pointeur, on accède à la valeur de la variable age  . Si au contraire on avait utilisé le symbole &  devant le nom du pointeur, on aurait obtenu l'adresse à laquelle se trouve le pointeur (ici, c'est 3).

Qu'est-ce qu'on y gagne ? On a simplement réussi à compliquer les choses ici. On n'avait pas besoin d'un pointeur pour afficher la valeur de la variable age  !

Cette question (que vous devez inévitablement vous poser) est légitime. Actuellement l'intérêt n'est pas évident, mais petit à petit, tout au long des chapitres suivants, vous comprendrez que tout cela n'a pas été inventé par pur plaisir de compliquer les choses.

Faites l'impasse sur la frustration que vous devez ressentir. Si vous avez compris le principe, c'est l'essentiel. Les choses s'éclairciront d'elles-mêmes par la suite.

Retenez le principe de base d'un pointeur

Voici ce qu'il faut avoir compris et ce qu'il faut retenir pour la suite de ce chapitre :

Sur une variable, comme la variable age  :

  - age signifie : "Je veux la valeur de la variable age  " ;

  - &age signifie : "Je veux l'adresse à laquelle se trouve la variable age  ".

Sur un pointeur, comme pointeurSurAge  :

  - pointeurSurAge signifie : "Je veux la valeur de pointeurSurAge  " (cette valeur étant une adresse) ;

  - *pointeurSurAge signifie : "Je veux la valeur de la variable qui se trouve à l'adresse contenue dans 
    pointeurSurAge  ".

Contentez-vous de bien retenir ces quatre points. Faites des tests et vérifiez que ça marche.

Ce schéma devrait bien vous aider à situer chacun de ces éléments.


Attention à ne pas confondre les différentes significations de l'étoile !

Lorsque vous déclarez un pointeur, l'étoile indique qu'on veut créer un pointeur :int *pointeurSurAge;  .

En revanche, lorsqu'ensuite vous utilisez votre pointeur en écrivant printf("%d", *pointeurSurAge);  , cela ne signifie pas "Je veux créer un pointeur", mais : "Je veux la valeur de la variable sur laquelle pointe mon pointeurSurAge  ".

Ce n’est sans doute pas facile d'assimiler toutes ces notions d’un coup. Je vous propose une petite vidéo pour résumer tous ces points :

Ce que l'on vient de voir est fondamental. Il faut connaître cela par cœur, et surtout le comprendre. N'hésitez pas à lire et relire ce chapitre.

En résumé

- Chaque variable est stockée à une adresse précise en mémoire.

- Les pointeurs sont semblables aux variables, à ceci près qu'au lieu de stocker un nombre, ils stockent 
  l'adresse à laquelle se trouve une variable en mémoire.

- Si on place un symbole & devant un nom de variable, on obtient son adresse au lieu de sa valeur (ex. : 
  &age  ).

- Si on place un symbole * devant un nom de pointeur, on obtient la valeur de la variable stockée à l'adresse 
  indiquée par le pointeur.

Félicitations, vous êtes arrivé à la fin de ce chapitre ! Dans le prochain, on continue sur notre lancée et on récupère le problème que l'on avait posé pour comprendre l'intérêt des pointeurs. C'est parti !

##############################################################################################################

Envoyez des pointeurs

Envoyez un pointeur à une fonction

Le gros intérêt des pointeurs (mais ce n'est pas le seul) est qu'on peut les envoyer à des fonctions pour qu'ils modifient directement une variable en mémoire, et non une copie comme on l'a vu.

Comment ça marche ?

Il y a en fait plusieurs façons de faire.

Envoyez un pointeur dans la fonction triplePointeur 

Voici un premier exemple :


void triplePointeur(int *pointeurSurNombre);

int main(int argc, char *argv[])
{
    int nombre = 5;

    triplePointeur(&nombre); // On envoie l'adresse de nombre à la fonction
    printf("%d", nombre); // On affiche la variable nombre. La fonction a directement modifié la valeur de la variable car elle connaissait son adresse

    return 0;
}

void triplePointeur(int *pointeurSurNombre)
{
    *pointeurSurNombre *= 3; // On multiplie par 3 la valeur de nombre
}


15

La fonction triplePointeur prend un paramètre de type int*  (c'est-à-dire un pointeur sur int  ). Voici ce qu'il se passe dans l'ordre, en partant du début du main  :

  1. Une variable nombre est créée dans le main. On lui affecte la valeur 5. Ça, vous connaissez.

  2. On appelle la fonction triplePointeur. On lui envoie en paramètre l'adresse de notre variable nombre.

  3. La fonction triplePointeur reçoit cette adresse dans pointeurSurNombre (à l'intérieur de la fonction 
     triplePointeur, on a donc un pointeur pointeurSurNombre qui contient l'adresse de la variable nombre ).

  4. Maintenant qu'on a un pointeur sur nombre  , on peut modifier directement la variable nombre en mémoire 
     avec *pointeurSurNombre pour désigner la variable nombre(pour l'exemple, on fait un simple test : on 
     multiplie la variable nombre par 3).

  5. De retour dans la fonction main  , notre nombre vaut maintenant 15 car la fonction triplePointeur a 
     modifié directement la valeur de nombre.


Bien sûr, j'aurais pu faire un simple return comme on a appris à le faire dans le chapitre sur les fonctions. Mais l'intérêt, là, c'est que de cette manière, en utilisant des pointeurs, on peut modifier la valeur de plusieurs variables en mémoire (on peut donc « renvoyer plusieurs valeurs »). Nous ne sommes plus limités à une seule valeur !

Quel est l'intérêt maintenant d'utiliser un return dans une fonction, si on peut se servir des pointeurs pour modifier des valeurs ?

Ça dépendra de vous et de votre programme. C'est à vous de décider. Il faut savoir que les return sont toujours utilisés en C. Le plus souvent, on s'en sert pour renvoyer ce qu'on appelle un code d'erreur : la fonction renvoie :

  - "0 success" ;

  - "1 (ou any non-0) failure", s'il y a eu une erreur pendant le déroulement de la fonction.

Alternative : ajoutez un pointeur dans la fonction  main

Dans le code source qu'on vient de voir, il n'y avait pas de pointeur dans la fonction main  . Juste une variable nombre  . Le seul pointeur qu'il y avait vraiment était dans la fonction triplePointeur  (de type int*  ).

Il faut absolument que vous sachiez qu'il y a une autre façon d'écrire le code précédent, en ajoutant un pointeur dans la fonction main  :



void triplePointeur(int *pointeurSurNombre);

int main(int argc, char *argv[])
{
    int nombre = 5;
    int *pointeur = &nombre; // pointeur prend l'adresse de nombre

    triplePointeur(pointeur); // On envoie pointeur (l'adresse de nombre) à la fonction
    printf("%d", *pointeur); // On affiche la valeur de nombre avec *pointeur

    return 0;
}

void triplePointeur(int *pointeurSurNombre)
{
    *pointeurSurNombre *= 3; // On multiplie par 3 la valeur de nombre
}


Comparez bien ce code source avec le précédent. Il y a de subtiles différences, et pourtant le résultat est strictement le même :

15

Ce qui compte, c'est d'envoyer l'adresse de la variable nombre à la fonction.

Or, pointeur vaut l'adresse de la variable nombre  , donc c'est bon de ce côté !

On le fait seulement d'une manière différente en créant un pointeur dans la fonction main  .

Dans le printf  (et c'est juste pour l'exercice), j'affiche le contenu de la variable nombre en tapant *pointeur  . Notez qu'à la place, j'aurais pu écrire nombre  : le résultat aurait été identique car *pointeur et nombre désignent la même chose dans la mémoire.

Dans le chapitre "Déclarez des variables", nous avons vu comment récupérer la saisie d’un utilisateur, et nous avons utilisé des pointeurs sans vraiment le savoir.

C'était en fait en appelant la fonction scanf . En effet, cette fonction lit ce que l'utilisateur a entré au clavier et renvoie le résultat.

Pour que la fonction puisse modifier directement le contenu de votre variable afin d'y placer la valeur tapée au clavier, elle a besoin de l'adresse de la variable :

  1.int nombre = 0;
  2.scanf("%d", &nombre);

La fonction travaille avec un pointeur sur la variable nombre   , et peut ainsi modifier directement le contenu de nombre  .

Comme on vient de le voir, on pourrait créer un pointeur qu'on enverrait à la fonction scanf  :

  1.int nombre = 0;
  2.int *pointeur = &nombre;
  3.scanf("%d", pointeur);

Attention à ne pas mettre le symbole & devant pointeur dans la fonction scanf  !

Ici, pointeur contient lui-même l'adresse de la variable nombre , inutile de mettre &.

Si vous faisiez ça, vous enverriez l'adresse où se trouve le pointeur : or, c'est l'adresse de nombre dont on a besoin.

Ce n’est peut-être pas évident de comprendre ces deux méthodes, c’est normal, pas d'inquiétude. C’est pour ça que je vous propose une vidéo qui explique ces deux façons d’envoyer un pointeur à une fonction :

Reprenez notre problème de départ

Il est temps de retrouver notre fil rouge : si vous avez compris ce chapitre, vous devriez être capable de résoudre le problème, maintenant.

Voici la solution :

void decoupeMinutes(int* pointeurHeures, int* pointeurMinutes);

int main(int argc, char *argv[])
{
    int heures = 0, minutes = 90;

    // On envoie l'adresse de heures et minutes
    decoupeMinutes(&heures, &minutes);

    // Cette fois, les valeurs ont été modifiées !
    printf("%d heures et %d minutes", heures, minutes);

    return 0;
}

void decoupeMinutes(int* pointeurHeures, int* pointeurMinutes)
{
    /* Attention à ne pas oublier de mettre une étoile devant le nom
    des pointeurs ! Comme ça, vous pouvez modifier la valeur des variables,
    et non leur adresse ! Vous ne voudriez pas diviser des adresses,
    n'est-ce pas ? ;o) */
    *pointeurHeures = *pointeurMinutes / 60;
    *pointeurMinutes = *pointeurMinutes % 60; 
}

Résultat :

1 heures et 30 minutes

Rien ne devrait vous surprendre dans ce code source.

Toutefois, comme on n'est jamais trop prudent, voyons ce qui se passe dans le détail :

  1. Les variables heures et minutes sont créées dans le main  .

  2. On envoie à la fonction decoupeMinutes l'adresse de heures et minutes  .

  3. La fonction decoupeMinutes récupère ces adresses dans des pointeurs appeléspointeurHeures et 
     pointeurMinutes. Notez que, là encore, le nom importe peu. J'aurais pu les appeler h et m, ou même heures 
     et minutes. Je ne l'ai pas fait car je ne veux pas que vous risquiez de confondre avec les variables 
     heures et minutes du main, qui ne sont pas les mêmes.

  4. La fonction decoupeMinutes modifie directement les valeurs des variables heures et minutes en mémoire, 
     car elle possède leurs adresses dans des pointeurs. La seule contrainte, un peu gênante je dois le 
     reconnaître, c'est qu'il faut impérativement mettre une étoile devant le nom des pointeurs si on veut 
     modifier la valeur de heures et de minutes. Si on n'avait pas fait ça, on aurait modifié l'adresse 
     contenue dans les pointeurs, ce qui n'aurait servi… à rien.

Il est possible de résoudre le "problème" sans utiliser de pointeurs, en contournant certaines règles que nous nous sommes fixées :

on peut utiliser des variables globales (mais on l'a dit, c'est mal) ;

ou encore faire un printf dans la fonction decoupeMinutes  (alors que c'est dans le main qu'on veut faire le printf  !).

L'exercice est un peu scolaire et peut donc être contourné si vous êtes malin, ce qui vous fait peut-être douter de l'intérêt des pointeurs. Soyez assuré que cet intérêt vous paraîtra de plus en plus évident au cours des chapitres suivants.

En résumé

  - Les pointeurs constituent une notion essentielle du langage C, mais néanmoins un peu complexe au début. Il 
    faut prendre le temps de bien comprendre comment ils fonctionnent, car beaucoup d'autres notions sont 
    basées dessus.

Ce n’est peut-être pas encore clair comme l’eau de roche, mais laissez-vous le temps d’assimiler la notion de pointeur, et n’hésitez pas à vous entraîner à les manipuler. Quand vous serez prêt, je vous retrouve au prochain chapitre pour découvrir la notion de tableau.

##############################################################################################################

Créez des variables de type "tableaux"

Ce chapitre est la suite directe des pointeurs, et va vous faire comprendre un peu plus leur utilité.

Les tableaux sont très utilisés en C, car ils permettent d'organiser une série de valeurs.

Comprenez le fonctionnement des tableaux en mémoire

Les tableaux sont une suite de variables de même type, stockées côte à côte en mémoire. Concrètement, il s'agit de "grosses variables" pouvant contenir plusieurs nombres du même type : long  , int  , char  , double  …

Un tableau a une dimension bien précise. Il peut occuper 2, 3, 10, 150, 2 500 cases, c'est vous qui décidez.

Voici le schéma d'un tableau de 4 cases en mémoire qui commence à l'adresse 1600.



Adresse             Valeur

1600                 10

1601                 23

1602                 505

1603                 8



Lorsque vous demandez à créer un tableau de 4 cases en mémoire, votre programme demande au système d'exploitation la permission d'utiliser 4 cases en mémoire.

Ces 4 cases doivent être contiguës, c'est-à-dire les unes à la suite des autres. Comme vous le voyez, les adresses se suivent : 1600, 1601, 1602, 1603. Il n'y a pas de "trou" au milieu.

Chaque case du tableau contient un nombre du même type. Si le tableau est de type int, alors chaque case du tableau contiendra un int. On ne peut pas faire de tableau contenant à la fois des int et des double, par exemple.

En résumé, voici ce qu'il faut retenir sur les tableaux :

  - Lorsqu'un tableau est créé, il prend un espace contigu en mémoire : les cases sont les unes à la suite des 
    autres.

  - Toutes les cases d'un tableau sont du même type. Ainsi, un tableau de int contiendra uniquement des int  , 
    et pas autre chose.

Définissez un tableau

Voyons comment définir un tableau de 4 int  :

  1.int tableau[4];

Voilà. Il suffit de rajouter entre crochets le nombre de cases que vous voulez mettre dans votre tableau. Il n'y a pas de limite (à part peut-être la taille de votre mémoire, quand même).

Maintenant, comment accéder à chaque case du tableau ?

Il faut écrire tableau[numeroDeLaCase]  .

Attention : un tableau commence à l'indice n° 0 ! Notre tableau de 4 int a donc les indices 0, 1, 2 et 3. Il n'y a pas d'indice 4 dans un tableau de 4 cases ! C'est une source d'erreurs très courantes, souvenez-vous-en.

Si je veux mettre dans mon tableau les mêmes valeurs que celles indiquées dans le schéma plus haut, je devrai donc écrire :

  1.int tableau[4];
  2.
  3.tableau[0] = 10;
  4.tableau[1] = 23;
  5.tableau[2] = 505;
  6.tableau[3] = 8;

Je ne vois pas le rapport entre les tableaux et les pointeurs ?

En fait, si vous écrivez juste tableau  , vous obtenez un pointeur. C'est un pointeur sur la première case du tableau. Faites le test :

  1.int tableau[4];
  2.
  3.printf("%d", tableau);

Résultat, on voit l'adresse où se trouve tableau  :

1600

En revanche, si vous indiquez l'indice de la case du tableau entre crochets, vous obtenez la valeur :

  1.int tableau[4];
  2.
  3.printf("%d", tableau[0]);

10

De même pour les autres indices. Notez que comme tableau est un pointeur, on peut utiliser le symbole * pour connaître la première valeur :

  1.int tableau[4];
  2.
  3.printf("%d", *tableau);

10

Il est aussi possible d'obtenir la valeur de la seconde case avec *(tableau + 1)  (adresse de tableau + 1). Les deux lignes suivantes sont donc identiques :

  1.tableau[1] // Renvoie la valeur de la seconde case (la première case étant 0)
  2.*(tableau + 1) // Identique : renvoie la valeur contenue dans la seconde case

En clair, quand vous écrivez tableau[0], vous demandez la valeur qui se trouve à l'adresse tableau + 0 case (c'est-à-dire, dans notre cas, la valeur 10 associée à l'adresse 1600).

Si vous écrivez tableau[1], vous demandez la valeur se trouvant à l'adresse tableau + 1 case (c'est-à-dire, dans notre cas, la valeur 23 associée à l'adresse 1601).

Et ainsi de suite pour les autres valeurs.

Attention : Il est interdit de créer un tableau dont la taille dépend d’une variable, du moins pour l’instant. C’est ce qu’on appelle une allocation dynamique, nous verrons cette notion bien plus loin dans le cours. Pour l’instant, vous devez écrire noir sur blanc le nombre correspondant à la taille du tableau.

Voyons dans vidéo suivante comment créer un tableau et accéder aux différentes cases de celui-ci :

Créez des tableaux à taille dynamique

Le langage C existe en plusieurs versions.

Une version récente, appelée le C99, autorise la création de tableaux à taille dynamique, c'est-à-dire de tableaux dont la taille est définie par une variable :

  1.int taille = 5;
  2.int tableau[taille];

Or cela n'est pas forcément reconnu par tous les compilateurs, certains planteront sur la seconde ligne. Le langage C que je vous enseigne depuis le début (appelé le C89) n'autorise pas ce genre de choses. Nous considèrerons donc que faire cela est interdit.

Nous allons nous mettre d'accord sur ceci : vous n'avez pas le droit d'utiliser une variable entre crochets pour la définition de la taille du tableau, même si cette variable est une constante ! Le tableau doit avoir une dimension fixe, c'est-à-dire que vous devez écrire noir sur blanc le nombre correspondant à la taille du tableau :

  1.int tableau[5];

Mais alors… il est interdit de créer un tableau dont la taille dépend d'une variable ?

C'est possible, même en C89. Mais pour faire cela, nous utiliserons une autre technique (plus sûre et qui marche partout), appelée l'allocation dynamique. Nous verrons cela plus loin dans ce cours.

Parcourez un tableau

Supposons que je veuille maintenant afficher les valeurs de chaque case du tableau. Je pourrais faire autant de printf qu'il y a de cases, mais ce serait répétitif et lourd. Et imaginez un peu la taille de notre code si on devait afficher le contenu de chaque case du tableau une à une !

Le mieux est de se servir d'une boucle. La boucle for est très pratique pour parcourir un tableau :


int main(int argc, char *argv[])
{
    int tableau[4], i = 0;

    tableau[0] = 10;
    tableau[1] = 23;
    tableau[2] = 505;
    tableau[3] = 8;

    for (i = 0 ; i < 4 ; i++)
    {
        printf("%d\n", tableau[i]);
    }

    return 0;
}


10
23
505
8

Cette boucle parcourt le tableau à l'aide d'une variable i  (c'est le nom très original que les programmeurs donnent en général à la variable qui leur permet de parcourir un tableau).

Ce qui est pratique, c'est qu'on peut mettre une variable entre crochets. En effet, la variable était interdite pour la création du tableau (pour définir sa taille), mais elle est heureusement autorisée pour "parcourir" le tableau, c'est-à-dire afficher ses valeurs !

Ici, on a mis la variable i  , qui vaut successivement 0, 1, 2, et 3.

Ainsi, on va afficher la valeur de tableau[0]  , tableau[1]  , tableau[2] et tableau[3]  !

Attention à ne pas tenter d'afficher la valeur de tableau[4]  ! Un tableau de 4 cases possède les indices 0, 1, 2 et 3, point barre. Si vous tentez d'afficher tableau[4]  , vous aurez soit n'importe quoi, soit une belle erreur, le système d'exploitation coupant votre programme car il aura tenté d'accéder à une adresse ne lui appartenant pas.


Initialisez un tableau

Maintenant que l'on sait parcourir un tableau, nous sommes capables d'initialiser toutes ses valeurs à 0 en faisant une boucle :


int main(int argc, char *argv[])
{
    int tableau[4], i = 0;

    // Initialisation du tableau
    for (i = 0 ; i < 4 ; i++)
    {
        tableau[i] = 0;
    }

    // Affichage de ses valeurs pour vérifier
    for (i = 0 ; i < 4 ; i++)
    {
        printf("%d\n", tableau[i]);
    }

    return 0;
}


0
0
0
0


Il existe une autre façon d'initialiser un tableau un peu plus automatisée en C. Elle consiste à écrire tableau[4] = {valeur1, valeur2, valeur3, valeur4}  . En clair, vous placez les valeurs une à une entre accolades, séparées par des virgules :

int main(int argc, char *argv[])
{
    int tableau[4] = {0, 0, 0, 0}, i = 0;

    for (i = 0 ; i < 4 ; i++)
    {
        printf("%d\n", tableau[i]);
    }

    return 0;
}


0
0
0
0


Mais en fait, c'est même mieux que ça : vous pouvez définir les valeurs des premières cases du tableau, toutes celles que vous n'aurez pas renseignées seront automatiquement mises à 0.

Ainsi, si je fais :

  1.int tableau[4] = {10, 23}; // Valeurs insérées : 10, 23, 0, 0

… la case n° 0 prendra la valeur 10, la n° 1 prendra 23, et toutes les autres prendront la valeur 0 (par défaut).

Comment initialiser tout le tableau à 0 en sachant ça ?

Il suffit d'initialiser au moins la première valeur à 0, et toutes les autres valeurs non indiquées prendront la valeur 0.

  1.int tableau[4] = {0}; // Toutes les cases du tableau seront initialisées à 0

Cette technique a l'avantage de fonctionner avec un tableau de n'importe quelle taille (là, ça marche pour 4 cases, mais s'il en avait eu 100, ça aurait été bon aussi).

Attention, on rencontre souvent int tableau[4] = {1};  , ce qui insère les valeurs suivantes : 1, 0, 0, 0.

Contrairement à ce que vous pourriez croire, on n'initialise pas toutes les cases à 1 en faisant cela : seule la première case sera à 1, les autres seront à 0. On ne peut donc pas initialiser toutes les cases à 1 automatiquement, à moins de faire une boucle.

Allez, pour terminer, je vous montre une dernière méthode pour initialiser un tableau. Elle consiste à écrire le nom de la variable avec les crochets vides, et à mettre comme précédemment les valeurs des cases entre accolades et séparées par une virgule. Au moment de la compilation, le compilateur va déduire automatiquement que c’est un tableau de taille "n" en fonction du nombre de valeurs qu’il y a entre accolades.

Par exemple :

  1.int tableau[] = {12, 19, 18, 2};

Ici, le compilateur déduira que le tableau est de taille 4 et les cases seront initialisées en fonction des  nombres entre accolades.

Vous aurez à coup sûr souvent besoin d'afficher tout le contenu de votre tableau. Pourquoi ne pas écrire une fonction qui fait ça ? Ça va nous permettre de découvrir comment on envoie un tableau à une fonction (ce qui m'arrange).

Écrivez une fonction pour afficher le contenu d'un tableau

Pour cela, il va falloir envoyer deux informations à la fonction :

  1. Le tableau (enfin, l'adresse du tableau).

  2. Et aussi et surtout sa taille !

En effet, notre fonction doit être capable d'initialiser un tableau de n'importe quelle taille. Or, dans votre fonction, vous ne connaissez pas la taille de votre tableau. C'est pour cela qu'il faut envoyer en plus une variable que vous appellerez tailleTableau   , par exemple.

tableau peut être considéré comme un pointeur.

On peut donc l'envoyer à la fonction comme on l'aurait fait avec un vulgaire pointeur :



// Prototype de la fonction d'affichage
void affiche(int *tableau, int tailleTableau);
 
int main(int argc, char *argv[])
{
    int tableau[4] = {10, 15, 3};
 
    // On affiche le contenu du tableau
    affiche(tableau, 4);
 
    return 0;
}
 
void affiche(int *tableau, int tailleTableau)
{
    int i;
 
    for (i = 0 ; i < tailleTableau ; i++)
    {
        printf("%d\n", tableau[i]);
    }
}


10
15
3
0

La fonction n'est pas différente de celles que l'on a étudiées dans le chapitre sur les pointeurs. Elle prend en paramètre un pointeur sur int (notre tableau), ainsi que la taille du tableau (très important pour savoir quand s'arrêter dans la boucle !).

Tout le contenu du tableau est affiché par la fonction via une boucle.

Notez qu'il existe une autre façon d'indiquer que la fonction reçoit un tableau. Plutôt que d'indiquer que la fonction attend un int *tableau, mettez ceci :

  1.void affiche(int tableau[], int tailleTableau)

Cela revient exactement au même, mais la présence des crochets permet au programmeur de bien voir que c'est un tableau que la fonction prend, et non un simple pointeur. Cela permet d'éviter des confusions.
J'utilise personnellement tout le temps les crochets dans mes fonctions, pour bien montrer que la fonction attend un tableau. Je vous conseille de faire de même. Il n'est pas nécessaire de mettre la taille du tableau entre les crochets, cette fois.

Avant de vous entraîner à créer vos propres fonctions avec des tableaux, nous allons voir dans cette vidéo comment passer un tableau en paramètre d’une fonction.

À vous de jouer

Je vous propose de réaliser des fonctions travaillant sur des tableaux.

Consigne

D'abord, créez une fonction somme Tableau qui renvoie la somme des valeurs contenues dans le tableau (utilisez un return pour renvoyer la valeur). Pour vous aider, voici le prototype de la fonction à créer :

  1.int sommeTableau(int tableau[], int tailleTableau);

Ensuite, créez une fonction moyenne Tableau qui calcule et renvoie la moyenne des valeurs. Voici le prototype :

  1.double moyenneTableau(int tableau[], int tailleTableau);

Corrigé

Voici une proposition de correction pour la fonction  sommeTableau.

Dans cette fonction nous avons :

  1. déclaré un entier  somme  initialisé à 0,

  2. parcouru le tableau à l'aide d'une boucle  for  ,

  3. et ajouté au fur et à mesure à la variable  somme  le contenu de chaque case du tableau passé en argument 
     de la fonction :

int sommeTableau(int tableau[], int tailleTableau)
{
    int somme = 0;
    for(int i = 0; i < tailleTableau; i++)
    {
        somme += tableau[i];
    }
    return somme;
}

Concernant la fonction moyenneTableau, c'est exactement la même chose, sauf que cette fois nous allons retourner, à la fin de la fonction, la division de la variable somme et tailleTableau pour avoir la moyenne.

Attention il est primordial de convertir le type de somme et tailleTableau en double avant de faire le calcul, pour ne pas perdre les informations après la virgule.

double moyenneTableau(int tableau[], int tailleTableau)
{
    int somme = 0;
    for(int i = 0; i < tailleTableau; i++)
    {
        somme += tableau[i];
    }
    return (double)somme/(double)tailleTableau;
}

En résumé

  - Les tableaux sont des ensembles de variables du même type stockées côte à côte en mémoire.

  - La taille d'un tableau doit être déterminée avant la compilation, elle ne peut pas dépendre d'une 
    variable.

  - Chaque case d'un tableau de type int contient une variable de type int  .

  - Les cases sont numérotées via des indices commençant à 0 : tableau[0]  , tableau[1]  ,tableau[2]  , etc.

Bon, nous n’avons toujours pas vu comment stocker du texte dans une variable et c’est normal, car nous avions besoin de voir le chapitre sur les tableaux avant. Il est donc temps de voir les chaînes de caractères !

##############################################################################################################

Manipulez du texte avec les chaînes de caractères

En programmation, une chaîne de caractères désigne… du texte, tout simplement ! Et on peut retenir ce texte sous forme de variable en mémoire.

Comme nous l'avons dit plus tôt, notre ordinateur ne peut retenir que des nombres. Les lettres sont exclues. Comment diable les programmeurs font-ils pour manipuler du texte, alors ? Eh bien ils sont malins, vous allez voir !

Utilisez le type char pour stocker une lettre

Si le type char permet de stocker des nombres (compris entre -128 et 127), on l'utilise rarement pour ça en C.

En général, même si le nombre est petit, on le stocke dans un int  . Certes, ça prend un peu plus de place en mémoire, mais aujourd'hui, la mémoire, ce n'est vraiment pas ce qui manque sur un ordinateur.

Le type char est en fait prévu pour stocker une lettre ! Attention, j'ai bien dit UNE lettre.

Comme la mémoire ne peut stocker que des nombres, on a inventé une table qui fait la conversion entre les nombres et les lettres. Ainsi, cette table indique par exemple que le nombre 65 équivaut à la lettre A.

Le langage C permet de faire très facilement la traduction lettre <=> nombre correspondant. Pour obtenir le nombre associé à une lettre, il suffit d'écrire cette lettre entre apostrophes, comme ceci : 'A'  . À la compilation, 'A' sera remplacé par la valeur correspondante.

Testons :

int main(int argc, char *argv[])
{
    char lettre = 'A';

    printf("%d\n", lettre);

    return 0;
}


65

On sait donc que la lettre A majuscule est représentée par le nombre 65. B vaut 66, C vaut 67, etc.

Testez avec des minuscules, et vous verrez que les valeurs sont différentes. 'a' n'est pas identique à 'A'  : l'ordinateur fait la différence entre les majuscules et les minuscules (on dit qu'il "respecte la casse").

La plupart des caractères « de base » sont codés entre les nombres 0 et 127. Une table fait la conversion entre les nombres et les lettres : la table ASCII (prononcez « Aski »). Le site AsciiTable.com propose cette table mais ce n'est pas le seul, on peut aussi la retrouver sur Wikipédia et bien d'autres sites encore.

Affichez un caractère avec la fonction printf

La fonction printf  peut aussi afficher un caractère via le symbole %c(c comme caractère) :

int main(int argc, char *argv[])
{
    char lettre = 'A';

    printf("%c\n", lettre);

    return 0;
}

A

Hourra, nous savons afficher une lettre !

On peut aussi demander à l'utilisateur d'entrer une lettre en utilisant le %c dans un scanf  :


int main(int argc, char *argv[])
{
    char lettre = 0;

    scanf("%c", &lettre);
    printf("%c\n", lettre);

    return 0;
}


Si je tape la lettre B, je verrai :

B
B


Le premier des deux B est celui que j'ai tapé au clavier, le second est celui affiché par le printf.

Voici à peu près tout ce qu'il faut savoir sur le type char :

  - le type char permet de stocker des nombres allant de -128 à 127, (le type unsigned char permet de stocker 
    les nombres de 0 à 255) ;

  - votre ordinateur utilise la table ASCII pour convertir les lettres en nombres et inversement ;

  - on peut alors utiliser le type char pour stocker UNE lettre ;

  - 'A'  est remplacé à la compilation par la valeur correspondante (65, en l'occurrence). On utilise donc les 
    apostrophes pour obtenir la valeur d'une lettre.


Voyez les chaînes comme des tableaux de type  char

Une chaîne de caractères n'est en fait rien d'autre qu'un tableau de type char. 

Si on crée un tableau :

  1.char chaine[5];

et qu'on met :

  - dans chaine[0] la lettre 'S'  ;

  - dans chaine[1] la lettre 'a'  ,

…  on peut ainsi former une chaîne de caractères, c'est-à-dire du texte.

Voici, de manière simplifiée, comment la chaîne est stockée en mémoire :


Adresse       Valeur

18000           'S'

18001           'a'

18002           'l'

18003           'u'

18004           't'


Ce tableau prend 5 cases en mémoire pour représenter le mot "Salut".

Pour la valeur, j'ai volontairement écrit sur le schéma les lettres entre apostrophes pour indiquer que c'est un nombre qui est stocké, et non une lettre. En réalité, dans la mémoire, ce sont bel et bien les nombres correspondant à ces lettres qui sont stockés.

Toutefois, une chaîne de caractères ne contient pas que des lettres ! Le schéma est en fait incomplet. Une chaîne de caractère doit impérativement contenir un caractère spécial à la fin de la chaîne, appelé "caractère de fin de chaîne". Ce caractère s'écrit'\0'  .

Pourquoi faut-il que la chaîne de caractères se termine par un \0  ?

Tout simplement pour que votre ordinateur sache quand s'arrête la chaîne ! Le caractère\0permet de dire : "Stop, c'est fini, y'a plus rien à lire après, circulez !".

Par conséquent, pour stocker le mot "Salut" (qui comprend 5 lettres) en mémoire, il ne faut pas un tableau de 5 char, mais de 6 :


Adresse       Valeur

18000           'S'

18001           'a'

18002           'l'

18003           'u'

18004           't'

18005           '\0'


Chaque fois que vous créez une chaîne de caractères, vous allez donc devoir penser à prévoir de la place pour le caractère de fin de chaîne. Il faut toujours ajouter un bloc de plus dans le tableau pour stocker ce caractère \0  , c'est impératif !

Oublier le caractère de fin \0  est une source d'erreurs impitoyable du langage C. Je le sais pour en avoir fait les frais plus d'une fois.

Grâce à \0  :

  - vous n'avez pas à retenir la taille de votre tableau car il indique que le tableau s'arrête à cet 
    endroit ;

  - vous pouvez passer votre tableau de char à une fonction sans avoir à ajouter à côté une variable indiquant 
    la taille du tableau.

Cela n'est valable que pour les chaînes de caractères (c'est-à-dire le type char*  , qu'on peut aussi écrire char[]  ). Pour les autres types de tableaux, vous êtes toujours obligé de retenir la taille du tableau quelque part.

Créez et initialisez une chaîne

Si on veut initialiser notre tableau chaine avec le texte "Salut", on peut utiliser la méthode manuelle mais peu efficace :

  1.char chaine[6]; // Tableau de 6 char pour stocker S-a-l-u-t + le \0
  2.  
  3.chaine[0] = 'S';
  4.chaine[1] = 'a';
  5.chaine[2] = 'l';
  6.chaine[3] = 'u';
  7.chaine[4] = 't';
  8.chaine[5] = '\0';

Cette méthode marche.

On peut le vérifier avec un printf en utilisant le symbole %s   ( s pour string en anglais, qu'on traduit par "chaîne").

Voici le code complet qui crée une chaîne "Salut" en mémoire, et qui l'affiche :

#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
    char chaine[6]; // Tableau de 6 char pour stocker S-a-l-u-t + le \0

    // Initialisation de la chaîne (on écrit les caractères un à un en mémoire)
    chaine[0] = 'S';
    chaine[1] = 'a';
    chaine[2] = 'l';
    chaine[3] = 'u';
    chaine[4] = 't';
    chaine[5] = '\0';

    // Affichage de la chaîne grâce au %s du printf
    printf("%s", chaine);

    return 0;
}
Résultat :

Salut

Vous remarquerez que c'est un peu fatigant et répétitif de devoir écrire les caractères un à un comme on l'a fait dans le tableau chaine  .

Pour initialiser une chaîne, il existe heureusement une méthode plus simple :

int main(int argc, char *argv[])
{
    char chaine[] = "Salut"; // La taille du tableau chaine est automatiquement calculée

    printf("%s", chaine);

    return 0;
}

Salut

À la première ligne, je crée une variable de type char[]  . J'aurais pu écrire aussi char*  , le résultat aurait été le même.
En tapant entre guillemets la chaîne à mettre dans votre tableau, le compilateur C calcule automatiquement la taille nécessaire. C'est-à-dire qu'il compte les lettres et ajoute 1 pour placer le caractère \0  .

Il écrit ensuite, une à une, les lettres du mot "Salut" en mémoire, et ajoute le \0  comme on l'a fait nous-mêmes manuellement quelques instants plus tôt. Bref, c'est bien plus pratique.

Il y a toutefois un défaut : ça ne marche que pour l'initialisation ! Vous ne pouvez pas écrire plus loin dans le code :

  1.chaine = "Salut";

Cette technique est donc à réserver à l'initialisation. Après cela, il faudra écrire les caractères manuellement un à un en mémoire, comme on l'a fait au début.

Dans cette vidéo, nous allons voir les différentes méthodes pour créer une chaîne de caractères, en respectant les bonnes pratiques :


Récupérez une chaîne via un scanf

Vous pouvez enregistrer une chaîne entrée par l'utilisateur via un scanf  , via le symbole %s  .

Seul problème : vous ne savez pas combien de caractères l'utilisateur va entrer. Si vous lui demandez son prénom, il s'appelle peut-être Luc (3 caractères), mais qui vous dit qu'il ne s'appelle pas Jean-Édouard (beaucoup plus de caractères) ?

Pour ça, il n'y a pas 36 solutions. Il va falloir créer un tableau de char suffisamment grand pour pouvoir stocker le prénom. On va donc créer un char[100] :


int main(int argc, char *argv[])
{
    char prenom[100];

    printf("Comment t'appelles-tu ? ");
    scanf("%s", prenom);
    printf("Salut %s, je suis heureux de te rencontrer !", prenom);

    return 0;
}

Comment t'appelles-tu ? Mateo21

Salut Mateo21, je suis heureux de te rencontrer !

Manipulez des chaînes à l'aide de fonctions

La bibliothèque string.h fournit de nombreuses fonctions dédiées aux calculs sur des chaînes.

Je vais vous présenter les principales :

  1. strlen pour calculer la longueur d'une chaîne.

  2. strcpy pour copier une chaîne dans une autre.

  3. strcat pour concaténer 2 chaînes.

  4. strcmp pour comparer 2 chaînes.

  5. strchr pour rechercher un caractère.

  6. strpbrk pour rechercher le premier caractère de la liste.

  7. strstr pour rechercher une chaîne dans une autre.

  8. sprintf pour écrire dans une chaîne.

Comme on va utiliser une nouvelle bibliothèque appelée string.h  , vous devez l'inclure !

Rajoutez cette ligne en haut des fichiers .c où vous en avez besoin :

  1.#include <string.h>

Si vous ne le faites pas, l'ordinateur ne connaîtra pas les fonctions que je vais vous présenter car il n'aura pas les prototypes, et la compilation plantera.

1. Calculez la longueur d'une chaîne avec  strlen

strlen (pour "string length") est une fonction qui calcule la longueur d'une chaîne de caractères (sans compter le caractère\0  ) :

  1. Vous lui envoyez un seul paramètre (votre chaîne de caractères) ;

  2. Elle vous retourne la longueur de la chaîne.

Maintenant que vous savez ce qu'est un prototype, je vous donne celui de la fonction  strlen  :

  1.size_t strlen(const char* chaine);

size_t est un type spécial qui signifie que la fonction renvoie un nombre correspondant à une taille.

Ce n'est pas un type de base comme int  , long ou char  , c'est un type "inventé".

Nous apprendrons nous aussi à créer nos propres types de variables quelques chapitres plus loin. Pour le moment, on va se contenter de stocker la valeur renvoyée par strlen dans une variable de type int  (l'ordinateur convertira de size_t en int automatiquement).

En toute rigueur, il faudrait plutôt stocker le résultat dans une variable de type size_t  , mais en pratique un int est suffisant pour cela.

La fonction prend un paramètre de type const char*  .

Le const(  qui signifie constante) fait que la fonction strlen "s'interdit" en quelque sorte de modifier votre chaîne. Quand vous voyez un const  , vous savez que la variable n'est pas modifiée par la fonction, elle est juste lue.

Testons la fonction strlen  :


int main(int argc, char *argv[])
{
    char chaine[] = "Salut";
    int longueurChaine = 0;

    // On récupère la longueur de la chaîne dans longueurChaine
    longueurChaine = strlen(chaine);

    // On affiche la longueur de la chaîne
    printf("La chaine %s fait %d caracteres de long", chaine, longueurChaine);

    return 0;
}

La chaine Salut fait 5 caracteres de long

Pour écrire la fonction strlen   , il suffit de faire une boucle sur le tableau de char qui s'arrête quand on tombe sur le caractère \0  . Un compteur s'incrémente à chaque tour de boucle, et c'est ce compteur que la fonction retourne.

Tiens, tout ça m'a donné envie d'écrire moi-même une fonction similaire à strlen  . Ça vous permettra en plus de bien comprendre comment la fonction marche :


int longueurChaine(const char* chaine);

int main(int argc, char *argv[])
{
    char chaine[] = "Salut";
    int longueur = 0;

    longueur = longueurChaine(chaine);

    printf("La chaine %s fait %d caracteres de long", chaine, longueur);

    
    return 0;
}

int longueurChaine(const char* chaine)
{
    int nombreDeCaracteres = 0;
    char caractereActuel = 0;

    do
    {
        caractereActuel = chaine[nombreDeCaracteres];
        nombreDeCaracteres++;
    }
    while(caractereActuel != '\0'); // On boucle tant qu'on n'est pas arrivé à l'\0

    nombreDeCaracteres--; // On retire 1 caractère de long pour ne pas compter le caractère \0

    return nombreDeCaracteres;
}


La fonction longueurChaine fait une boucle sur le tableau chaine :

  1. Elle stocke les caractères un par un dans caractereActuel  .

  2. Dès que caractèreActuel vaut '\0'  , la boucle s'arrête.

  3. À chaque passage dans la boucle, on ajoute 1 au nombre de caractères qu'on a analysés.

  4. À la fin de la boucle, on retire 1 caractère au nombre total de caractères qu'on a comptés. Cela permet 
     de ne pas compter le caractère \0  dans le lot.

  5. Enfin, on retourne nombreDeCaracteres   , et le tour est joué !


2. Copiez une chaîne dans une autre avec strcpy

La fonction strcpy(pour "string copy") permet de copier une chaîne à l'intérieur d'une autre.

Voici son prototype :

  1.char* strcpy(char* copieDeLaChaine, const char* chaineACopier);

Cette fonction prend deux paramètres :

  1. copieDeLaChaine  : c'est un pointeur vers un char*  (tableau de char  ). C'est dans ce tableau que la 
                        chaîne sera copiée.

  2. chaineACopier  : c'est un pointeur vers un autre tableau de char  . Cette chaîne sera copiée dans 
                      copieDeLaChaine  .

La fonction renvoie un pointeur sur copieDeLaChaine  , ce qui n'est pas très utile. En général, on ne récupère pas ce que cette fonction renvoie.

Testons cela :

int main(int argc, char *argv[])
{
    /* On crée une chaîne "chaine" qui contient un peu de texte
    et une copie (vide) de taille 100 pour être sûr d'avoir la place
    pour la copie */
    
    char chaine[] = "Texte", copie[100] = {0};

    strcpy(copie, chaine); // On copie "chaine" dans "copie"

    // Si tout s'est bien passé, la copie devrait être identique à chaine
    printf("chaine vaut : %s\n", chaine);
    printf("copie vaut : %s\n", copie);

    return 0;
}

chaine vaut : Texte
copie vaut : Texte

On voit que chaine vaut "Texte". Jusque-là, c'est normal.

Par contre, on voit aussi que la variable copie  , qui était vide au départ, a été remplie par le contenu de chaine  . La chaîne a donc bien été copiée dans copie  .

Vérifiez que la chaîne copie est assez grande pour accueillir le contenu de chaine  .

Si, dans mon exemple, j'avais défini copie[5]  (ce qui n'est pas suffisant car il n'y aurait pas eu de place pour le \0  ), la fonction strcpy aurait "débordé en mémoire" et probablement fait planter votre programme. À éviter à tout prix !

Chaque caractère de chaine a été placé dans copie  .

La chaîne copie contient de nombreux caractères inutilisés. Je lui ai donné la taille 100 par sécurité, mais en toute rigueur, la taille 6 aurait suffit. L'avantage de créer un tableau un peu plus grand, c'est que de cette façon la chaîne copie sera capable de recevoir d'autres chaînes peut-être plus grandes dans la suite du programme.

3. Concaténez deux chaînes avec  strcat

La fonction  strcat  (pour "string catenate") ajoute une chaîne à la suite d'une autre. On appelle cela la concaténation.

Supposons que l'on ait les variables suivantes :

  1. chaine1 = "Salut "

  2. chaine2 = "Mateo21"

Si je concatène chaine2 dans chaine1  , alors chaine1 vaudra "Salut Mateo21"  .

Quant à chaine2  , elle n'aura pas changé et vaudra donc toujours "Mateo21"  .

Seule chaine1 est modifiée.

C'est exactement ce que fait strcat  , dont voici le prototype :

  1.char* strcat(char* chaine1, const char* chaine2);

chaine2 ne peut pas être modifiée car elle est définie comme constante dans le prototype de la fonction.

La fonction retourne un pointeur vers chaine1  , ce qui, comme pour strcpy  , ne sert pas à grand-chose dans le cas présent : on peut donc ignorer ce que la fonction nous renvoie.

La fonction ajoute à chaine1 le contenu de chaine2  .

Regardons-y de plus près :

int main(int argc, char *argv[])
{
    /* On crée 2 chaînes. chaine1 doit être assez grande pour accueillir
    le contenu de chaine2 en plus, sinon risque de plantage */
    char chaine1[100] = "Salut ", chaine2[] = "Mateo21";

    strcat(chaine1, chaine2); // On concatène chaine2 dans chaine1

    // Si tout s'est bien passé, chaine1 vaut "Salut Mateo21"
    printf("chaine1 vaut : %s\n", chaine1);
    // chaine2 n'a pas changé :
    printf("chaine2 vaut toujours : %s\n", chaine2);

    return 0;
}

chaine1 vaut : Salut Mateo21
chaine2 vaut toujours : Mateo21


Vérifiez que chaine1 est assez grande pour qu'on puisse lui ajouter le contenu de chaine2   , sinon vous ferez un débordement en mémoire qui peut conduire à un plantage.

C'est pour cela que j'ai défini chaine1 de taille 100.

Quant à chaine2  , j'ai laissé l'ordinateur calculer sa taille (je n'ai donc pas précisé la taille) car cette chaîne n'est pas modifiée, il n'y a donc pas besoin de la rendre plus grande que nécessaire.

Voici comment fonctionne la concaténation :

Le tableau chaine2 a été ajouté à la suite de chaine1  (qui comprenait une centaine de cases).

Le \0 de chaine1 a été supprimé (en fait, il a été remplacé par le M de Mateo21).

En effet, il ne faut pas laisser un \0  au milieu de la chaîne, sinon celle-ci aurait été "coupée" au milieu ! On ne met un \0  qu'à la fin de la chaîne, une fois qu'elle est finie.

4. Comparez deux chaînes avec strcmp

strcmp (pour "string compare") compare 2 chaînes entre elles.

Voici son prototype :

  1.int strcmp(const char* chaine1, const char* chaine2);

Les variables chaine1 et chaine2 sont comparées. Aucune d'elles n'est modifiée car elles sont indiquées comme constantes.

Il est important de récupérer ce que la fonction strcmp renvoie :

  - 0 si les chaînes sont identiques ;

  - une autre valeur (positive ou négative) si les chaînes sont différentes.

Il aurait été plus logique que la fonction renvoie 1 si les chaînes avaient été identiques, pour dire "vrai" (rappelez-vous des booléens).

La raison est simple : la fonction compare les valeurs de chacun des caractères un à un :

  - si tous les caractères sont identiques, elle renvoie 0 ;

  - si les caractères de la chaine1 sont supérieurs à ceux de la chaine2  , la fonction renvoie un nombre 
    positif ;

  - si c'est l'inverse, la fonction renvoie un nombre négatif.

Dans la pratique, on se sert surtout de strcmp pour vérifier si deux chaînes sont identiques ou non.

Voici un code de test :



int main(int argc, char *argv[])
{
    char chaine1[] = "Texte de test", chaine2[] = "Texte de test";

    if (strcmp(chaine1, chaine2) == 0) // Si chaînes identiques
    {
        printf("Les chaines sont identiques\n");
    }
    else
    {
        printf("Les chaines sont differentes\n");
    }

    return 0;
}

Les chaines sont identiques

Les chaînes étant identiques, la fonction strcmp a renvoyé le nombre 0.

Notez que j'aurais pu stocker ce que renvoie strcmp dans une variable de type int  . Toutefois, ce n'est pas obligatoire, on peut directement mettre la fonction dans le if comme je l'ai fait.

N'oubliez pas :

  - 0 signifie "identique" ;

  - et une autre valeur signifie "différent".

C'est la seule source d'erreur possible ici.

5. Recherchez un caractère avec  strchr

La fonction strchr recherche un caractère dans une chaîne.

Voici son prototype :

  1.char* strchr(const char* chaine, int caractereARechercher);

La fonction prend 2 paramètres :

  1. chaine  : la chaîne dans laquelle la recherche doit être faite.

  2. caractereARechercher  : le caractère que l'on doit rechercher dans la chaîne.

caractereARechercher est de type int et non de typechar  .

Ce n'est pas réellement un problème car, au fond, un caractère est et restera toujours un nombre. Néanmoins, on utilise quand même plus souvent un char qu'un int pour stocker un caractère en mémoire.

La fonction renvoie un pointeur vers le premier caractère qu'elle a trouvé, c'est-à-dire qu'elle renvoie l'adresse de ce caractère dans la mémoire. Elle renvoie NULL si elle n'a rien trouvé.

Dans l'exemple suivant, je récupère ce pointeur dans suiteChaine  :

int main(int argc, char *argv[])
{
    char chaine[] = "Texte de test", *suiteChaine = NULL;

    suiteChaine = strchr(chaine, 'd');
    if (suiteChaine != NULL) // Si on a trouvé quelque chose
    {
        printf("Voici la fin de la chaine a partir du premier d : %s", suiteChaine);
    }

    return 0;
}

Voici la fin de la chaine a partir du premier d : de test

Avez-vous bien compris ce qu'il se passe ici ? C'est un peu particulier.
En fait, suiteChaine est un pointeur comme chaine  , sauf que chaine pointe sur le premier caractère (le 'T'  majuscule), tandis que suiteChaine pointe sur le premier caractère 'd' qui a été trouvé dans chaine  .

Ce schéma montre où pointe chaque pointeur :

chaine commence au début de la chaine ( 'T'  majuscule), tandis que suiteChaine pointe sur le 'd' minuscule.

Lorsque je fais un printf de suiteChaine  , il est donc normal que l'on m'affiche juste "de test".

printf affiche tous les caractères qu'elle rencontre (d,e, ,t,e,s,t) jusqu'à ce qu'elle tombe sur \0 qui lui dit que la chaîne s'arrête là.

Il existe une fonction strrchr strictement identique à strchr  , sauf que celle-là renvoie un pointeur vers le dernier caractère qu'elle a trouvé dans la chaîne, plutôt que vers le premier.


6. Recherchez le premier caractère d'une liste avec strpbrk

Cette fonction recherche un des caractères dans la liste que vous lui donnez sous forme de chaîne, contrairement à strchr qui ne peut rechercher qu'un seul caractère à la fois.

Si on forme la chaîne "xds" et qu'on en fait une recherche dans "Texte de test"  , la fonction renvoie un pointeur vers le premier de ces caractères qu'elle y a trouvés. En l'occurrence, le premier caractère de "xds"  qu'elle trouve dans "Texte de test"  est le x  , donc strpbrk renverra un pointeur sur 'x'  .

Voici son prototype :

  1.char* strpbrk(const char* chaine, const char* lettresARechercher);

Testons la fonction :

int main(int argc, char *argv[])
{
    char *suiteChaine;

    // On cherche la première occurrence de x, d ou s dans "Texte de test" 
    suiteChaine = strpbrk("Texte de test", "xds");

    if (suiteChaine != NULL)
    {
        printf("Voici la fin de la chaine a partir du premier des caracteres trouves : %s", suiteChaine);
    }

    return 0;
}

Voici la fin de la chaine a partir du premier des caracteres trouves :
xte de test


Pour cet exemple, j'ai directement écrit les valeurs à envoyer à la fonction (entre guillemets). Rien ne nous oblige à employer une variable à tous les coups, on peut très bien écrire la chaîne directement. Il faut simplement retenir la règle suivante :

  - si vous utilisez les guillemets ""  , cela signifie chaîne ;

  - si vous utilisez les apostrophes ''  , cela signifie caractère.

7. Recherchez une chaîne dans une autre avec strstr

La fonction  strstr  (pour "string string") recherche la première occurrence d'une chaîne dans une autre chaîne.

Son prototype est :

  1.char* strstr(const char* chaine, const char* chaineARechercher);

Le prototype est similaire à strpbrk  , mais attention à ne pas confondre :

  - strpbrk recherche UN des caractères ;

  - strstr recherche toute la chaîne.

Exemple :

int main(int argc, char *argv[])
{
    char *suiteChaine;

    // On cherche la première occurrence de "test" dans "Texte de test" :
    suiteChaine = strstr("Texte de test", "test");
    if (suiteChaine != NULL)
    {
        printf("Premiere occurrence de test dans Texte de test : %s\n", suiteChaine);
    }

    return 0;
}

Premiere occurrence de test dans Texte de test : test

La fonction strstr recherche la chaîne "test" dans "Texte de test" :

  - elle renvoie, comme les autres, un pointeur quand elle a trouvé ce qu'elle cherchait ;

  - elle renvoie NULL si elle n'a rien trouvé.

Jusqu'ici, je me suis contenté d'afficher la chaîne à partir du pointeur retourné par les fonctions. Dans la pratique, ça n'est pas très utile. Vous ferez juste un if (resultat != NULL)  pour savoir si la recherche a ou non donné quelque chose, et vous afficherez "Le texte que vous recherchiez a été trouvé".

8. Écrivez dans une chaîne avec  sprintf

Cette fonction se trouve dans stdio.h  , contrairement aux autres fonctions que nous avons étudiées jusqu'ici, qui étaient dans string.h  .

Cette fonction ressemble énormément au printf sauf qu'au lieu d'écrire à l'écran, sprintf écrit dans… une chaîne ! D'où son nom d'ailleurs, qui commence par le "s" de "string".

C'est une fonction très pratique pour mettre en forme une chaîne. Petit exemple :


#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
    char chaine[100];
    int age = 15;

    // On écrit "Tu as 15 ans" dans chaine
    sprintf(chaine, "Tu as %d ans !", age);

    // On affiche chaine pour vérifier qu'elle contient bien cela :
    printf("%s", chaine);

    return 0;
}

Tu as 15 ans !


Elle s'utilise de la même manière que printf  , mis à part le fait que vous devez lui donner en premier paramètre un pointeur vers la chaîne qui doit recevoir le texte.

Dans mon exemple, j'écris dans chaine  "Tu as %d ans", où %d est remplacé par le contenu de la variable agenn. Toutes les règles du printf s'appliquent, vous pouvez donc si vous le voulez mettre des %s pour insérer d'autres chaînes à l'intérieur de votre chaîne !

Comme d'habitude, vérifiez que votre chaîne est suffisamment grande pour accueillir tout le texte que le sprintf va lui envoyer. Sinon, comme on l'a vu, vous vous exposez à des dépassements de mémoire, et donc à un plantage de votre programme.

En résumé

  - Un ordinateur ne sait pas manipuler du texte, il ne connaît que les nombres. Pour régler le problème, on 
    associe à chaque lettre de l'alphabet un nombre correspondant dans une table appelée la table ASCII.

  - Le type char est utilisé pour stocker une et une seule lettre. Il stocke en réalité un nombre, mais ce 
    nombre est automatiquement traduit par l'ordinateur à l'affichage.

  - Pour créer un mot ou une phrase, on doit construire une chaîne de caractères. Pour cela, on utilise un 
    tableau de char  .

  - Toute chaîne de caractères se termine par un caractère spécial appelé \0  qui signifie "fin de chaîne".

  - Il existe de nombreuses fonctions toutes prêtes de manipulation des chaînes dans la bibliothèque string. 
    Il faut inclure string.h pour pouvoir les utiliser.

Les chaînes de caractères n’ont plus de secret pour vous ! Il est donc temps d’apprendre une nouvelle notion. Passez au chapitre suivant sans tarder, vous allez travailler sur les directives du préprocesseur. Pas d'inquiétude, le prochain chapitre est plus simple que les deux précédents.

##############################################################################################################

Utilisez les directives du préprocesseur

Dans les codes source, on retrouve des lignes un peu particulières qu'on appelle des directives de préprocesseur. Elles commencent toujours par le symbole #.

Utilisez #include pour inclure un fichier dans un autre

#include ne fait rien d'autre qu'insérer un fichier dans un autre.

  - Pour inclure un fichier .h se trouvant dans le dossier où est installé votre IDE, vous devez utiliser les 
    chevrons :  < >  .

  - Pour inclure un fichier .h se trouvant dans le dossier de votre projet, vous devez en revanche utiliser 
    les guillemets :  " "  .


Utilisez #define pour associer une valeur à un mot

#define permet de définir une constante de préprocesseur, autrement dit, d'associer une valeur à un mot.

L'intérêt, c'est que :

  - ça ne prend pas de place en mémoire, puisque que lors de la compilation il ne reste plus que des nombres 
    dans le code source ;

  - le remplacement se fait dans tout le fichier dans lequel se trouve le #define. Si vous aviez défini une 
    constante en mémoire dans une fonction, celle-ci n'aurait été valable que dans la fonction, puis aurait 
    été supprimée. Le #define en revanche s'appliquera à toutes les fonctions du fichier, ce qui peut s'avérer 
    parfois pratique selon les besoins.

Les #define sont généralement placés dans des .h  , à côté des prototypes.


Définissez la taille des tableaux avec  #define

Voici un exemple :

#define TAILLE_MAX      1000

int main(int argc, char *argv[])
{
    char chaine1[TAILLE_MAX], chaine2[TAILLE_MAX];
    // ...

Mais… je croyais qu'on ne pouvait pas mettre de variable ni de constante entre les crochets lors d'une définition de tableau ?

Oui, mais TAILLE_MAX n'est PAS une variable ni une constante. En effet je vous l'ai dit, le préprocesseur transforme le fichier avant compilation en :

int main(int argc, char *argv[])
{
    char chaine1[1000], chaine2[1000];
    // ...

… et cela est valide !

En définissant TAILLE_MAX ainsi, vous pouvez vous en servir pour créer des tableaux d'une certaine taille.

Si à l'avenir cela s'avère insuffisant, vous n'aurez qu'à :

  1. Modifier la ligne du #define  .

  2. Recompiler, et vos tableaux de char prendront tous la nouvelle taille que vous aurez indiquée.


Faites des calculs dans les #define

Il est possible de faire quelques petits calculs dans les #define  .
Par exemple, ce code crée une constante LARGEUR_FENETRE  , une autre HAUTEUR_FENETRE  , puis une troisième NOMBRE_PIXELS qui contiendra le nombre de pixels affichés à l'intérieur de la fenêtre (le calcul est simple : largeur * hauteur) :

  1.#define LARGEUR_FENETRE  800
  2.#define HAUTEUR_FENETRE  600
  3.#define NOMBRE_PIXELS    (LARGEUR_FENETRE * HAUTEUR_FENETRE)

La valeur de NOMBRE_PIXELS est remplacée avant la compilation par le code suivant : (LARGEUR_FENETRE * HAUTEUR_FENETRE), c'est-à-dire par (800 * 600), ce qui fait 480 000.
Mettez toujours votre calcul entre parenthèses, comme je l'ai fait par sécurité pour bien isoler l'opération.

Vous pouvez faire toutes les opérations de base que vous connaissez : addition (+), soustraction (-), multiplication (*), division (/) et modulo (%).

Voyons dans cette courte vidéo comment créer une constante de préprocesseur et l’utiliser dans votre programme. D’une part nous verrons comment créer une constante pour l’utiliser dans une partie du code, et d’autre part comment créer un tableau statique à l’aide de ces constantes :

