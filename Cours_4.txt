                           Partie 4 : Allez plus loin pour programmer comme un pro


Créez vos propres types de variables

En C, lorsque l'on cherche à faire des programmes plus complexes, on peut créer nos propres types de variables :

   1. Les structures.

   2. Et les énumérations.

Et bonne nouvelle : c'est plutôt simple à comprendre et à manipuler !


Définissez une structure

Une structure est un assemblage de variables qui peuvent avoir différents types.
Contrairement aux tableaux qui vous obligent à utiliser le même type dans tout le tableau, vous pouvez créer une structure comportant des variables de types long  , char  , int et double à la fois.

Les structures sont généralement définies dans les fichiers .h  , au même titre que les prototypes et les define  .

Pour définir une structure, il suffit de :

  - commencer par taper  struct ;

  - puis écrire le nom de la structure ;

ASTUCE : nommez vos structures en suivant les mêmes règles que pour les noms de variables, sauf que vous mettez la première lettre en majuscule pour pouvoir faire la différence.
Du coup, en regardant mon code, si vous voyez quelque chose comme :

    - ageDuCapitaine , vous saurez qu'il s'agit d'une variable car cela commence par une lettre minuscule ;

    - MorceauAudio , vous saurez qu'il s'agit d'une structure (un type personnalisé) car cela commence par une 
      majuscule.

  - ouvrir ensuite les accolades et les fermer plus loin, comme pour une fonction ;

Attention, ici c'est particulier : vous DEVEZ mettre un point-virgule après l'accolade fermante. C'est obligatoire. Si vous ne le faites pas, la compilation plantera.

  - placer entre les accolades les variables dont est composée votre structure. Une structure est généralement 
    composée d'au moins deux "sous-variables ", sinon elle n'a pas trop d'intérêt. Toutes les structures que 
    vous verrez sont en fait des "assemblages" de variables de type de base, comme long, int, double, etc. 

Voici donc à quoi ressemble une structure  :


struct NomDeVotreStructure
{
    int variable1;
    int variable2;
    int autreVariable;
    double nombreDecimal;
};

Imaginons par exemple que vous vouliez créer une variable qui stocke les coordonnées d'un point à l'écran.

Lorsqu'on travaille en 2D (2 dimensions), on a deux axes : l'axe des abscisses (de gauche à droite) et l'axe des ordonnées (de bas en haut). On a l'habitude d'exprimer les abscisses par une variable appelée x  , et les ordonnées par y  .

Voyons ce que ça donne :

struct Coordonnees
{
    int x; // Abscisses
    int y; // Ordonnées
};


Notre structure s'appelle Coordonnees et est composée de deux variables x et y  , c'est-à-dire de l'abscisse et de l'ordonnée.

Si on le voulait, on pourrait facilement faire une structure Coordonnees pour de la 3D : il suffirait d'ajouter une troisième variable (par exemple z  ) qui indiquerait la hauteur. 


Placez des tableaux dans une structure

Les structures peuvent contenir des tableaux. Ça tombe bien, on va pouvoir ainsi placer des tableaux de char (chaînes de caractères) sans problème !

Allez, imaginons une structure Personne qui stocke diverses informations sur une personne :

struct Personne
{
    char nom[100];
    char prenom[100];
    char adresse[1000];
    
    int age;
    int etudiant; // Booléen : 1 = etudiant, 0 = non etudiant
};

Cette structure est composée de cinq sous-variables. Les trois premières sont des chaînes qui stockeront le nom, le prénom et l'adresse de la personne. Les deux dernières stockent l'âge et le statut étudiant de la personne (c'est un booléen, 1 = vrai = étudiant, 0 = faux = pas étudiant).

Vous pouvez rajouter des variables dans la structure pour la compléter si vous le voulez. Il n'y a pas de limite au nombre de variables dans une structure.

Utilisez une structure dans une fonction

Maintenant que notre structure est définie dans le .h  , on va pouvoir l'utiliser dans une fonction de notre fichier .c  .

Voici comment créer une variable de type Coordonnees  (la structure qu'on a définie plus haut) :

#include "main.h" // Inclusion du .h qui contient les prototypes et structures

int main(int argc, char *argv[])
{
    struct Coordonnees point; // Création d'une variable "point" de type Coordonnees

    return 0;
}


Nous avons ainsi créé une variable point de type Coordonnees  . Cette variable est automatiquement composée de deux sous-variables : x et y  (son abscisse et son ordonnée).

Faut-il obligatoirement écrire le mot-clé struct lors de la définition de la variable ?

Oui, cela permet à l'ordinateur de différencier un type de base (comme int  ) d'un type personnalisé, comme Coordonnees  .

Toutefois, les programmeurs trouvent souvent un peu lourd de mettre le mot struct à chaque définition de variable personnalisée. Pour régler ce problème, ils ont inventé une instruction spéciale : le typedef  .

Créez un alias de structure avec l'instruction typedef

Retournons dans le fichier .h qui contient la définition de notre structure de typeCoordonnees  . Nous allons ajouter une instruction appelée typedef pour créer un alias de structure et dire qu'écrire telle chose équivaut à écrire telle autre chose.

Ajoutons une ligne commençant par typedef juste avant la définition de la structure :

typedef struct Coordonnees Coordonnees;
struct Coordonnees
{
    int x;
    int y;
};

Cette ligne doit être découpée en trois morceaux (non, je n'ai pas bégayé le mot Coordonnees  ) :

  - typedef  : indique que nous allons créer un alias de structure ;

  - struct Coordonnees  : c'est le nom de la structure dont vous allez créer un alias (c'est-à-dire un "équivalent") ;

  - Coordonnees  : c'est le nom de l'équivalent.

En clair, cette ligne dit :

"Écrire le mot Coordonnees est désormais équivalent à écrire struct Coordonnees  ".

En faisant cela, vous n'aurez plus besoin de mettre le mot struct à chaque définition de variable de type Coordonnees  . On peut donc retourner dans notre main et écrire :

int main(int argc, char *argv[])
{
    Coordonnees point; // L'ordinateur comprend qu'il s'agit de "struct Coordonnees" grâce au typedef
    return 0;
}

Je vous recommande de faire un typedef comme je l'ai fait ici pour Coordonnees  . Ça évite d'avoir à écrire le mot struct partout. Un bon programmeur est un programmeur fainéant ! Il en écrit le moins possible.

Modifiez les composantes de la structure

Maintenant que notre variable point est créée, nous voulons modifier ses coordonnées.
Comment accéder au x et au y de point? Comme ceci :

int main(int argc, char *argv[])
{
    Coordonnees point;
    
    point.x = 10;
    point.y = 20;

    return 0;
}

On a ainsi modifié la valeur de point  , en lui donnant une abscisse de 10 et une ordonnée de 20. Notre point se situe désormais à la position (10 ; 20) ; c'est la notation mathématique d'une coordonnée.

Pour accéder à chaque composante de la structure, vous devez donc écrire :

  1.variable.nomDeLaComposante

Le point fait la séparation entre la variable et la composante.

Si on prend la structure Personne que nous avons vue tout à l'heure, et qu'on demande le nom et le prénom, on devra faire comme ça :

int main(int argc, char *argv[])
{
    Personne utilisateur;

    printf("Quel est votre nom ? ");
    scanf("%s", utilisateur.nom);
    printf("Votre prenom ? ");
    scanf("%s", utilisateur.prenom);

    printf("Vous vous appelez %s %s", utilisateur.prenom, utilisateur.nom);

    return 0;
}

Quel est votre nom ? Dupont
Votre prenom ? Jean
Vous vous appelez Jean Dupont

On envoie la variable utilisateur.nom à scanf qui écrira directement dans notre variable utilisateur  . On fait de même pour prenom  , et on pourrait aussi le faire pour l'adresse, l'âge et le statut étudiant, mais je n'ai guère envie de me répéter (je dois être programmeur, c'est pour ça).

Vous auriez pu faire la même chose sans connaître les structures, en créant juste une variable nom et une autre, prenom  . Mais l'intérêt ici est que vous pouvez créer une autre variable de type Personne qui aura aussi son propre nom, son propre prénom, etc.

On peut donc faire :

  1.Personne joueur1, joueur2;

… et stocker ainsi les informations sur chaque joueur. Chaque joueur a son propre nom, son propre prénom, etc.

On peut même faire encore mieux : on peut créer un tableau de Personne :

  1.Personne joueurs[2];

Et ensuite, vous accédez par exemple au nom du joueur n° 0 en tapant :

  1.joueurs[0].nom

L'avantage d'utiliser un tableau ici, c'est que vous pouvez faire une boucle pour demander les infos du joueur 1 et du joueur 2, sans avoir à répéter deux fois le même code. Il suffit de parcourir le tableau joueur et de demander à chaque fois nom, prénom, adresse…


Initialisez une structure

Pour les structures comme pour les variables, tableaux et pointeurs, il est vivement conseillé de les initialiser dès leur création pour éviter qu'elles ne contiennent n'importe quoi.

En effet, une variable qui est créée prend la valeur de ce qui se trouve en mémoire là où elle a été placée. Parfois cette valeur est 0, parfois c'est un résidu d'un autre programme qui est passé par là avant vous, et la variable a alors une valeur qui n'a aucun sens, comme -84570.

Pour rappel, voici comment on initialise :

  - une variable : on met sa valeur à 0 (cas le plus simple) ;

  - un pointeur : on met sa valeur à NULL  . NULL  est en fait un #define situé dans stdlib.h qui vaut 
    généralement 0, mais on continue à utiliser NULL par convention sur les pointeurs pour bien voir qu'il 
    s'agit de pointeurs et non de variables ordinaires ;

  - un tableau : on met chacune de ses valeurs à 0.

Pour une structure, l'initialisation ressemble un peu à celle d'un tableau.

En effet, on peut faire à la déclaration de la variable :

  1.Coordonnees point = {0, 0};

Cela définira, dans l'ordre :

  1. point.x = 0  .

  2. point.y = 0  .

Pour envoyer ma variable point à une fonction initialiserCoordonnees par exemple, qui se charge de faire les initialisations sur ma variable, je peux envoyer un pointeur de ma variable.

En effet, si j'envoie juste ma variable, une copie en sera réalisée dans la fonction (comme pour une variable de base), et la fonction modifiera les valeurs de la copie et non celles de ma vraie variable. Revoyez le fil rouge du chapitre sur les pointeurs si vous avez oublié comment cela fonctionne.

Reprenons l’exemple de la structure  Personne  et voyons comment créer et utiliser la structure dans la vidéo suivante :


Utilisez un pointeur sur une structure

Un pointeur de structure se crée de la même manière qu'un pointeur de int  , de double ou de n'importe quel autre type de base :

  1.Coordonnees* point = NULL;

On a ainsi un pointeur de Coordonnees appelé point  .

Comme un rappel ne fera de mal à personne, je tiens à vous répéter que l'on aurait aussi pu mettre l'étoile devant le nom du pointeur, cela revient exactement au même :

  1.Coordonnees *point = NULL;

C'est même mieux car pour définir plusieurs pointeurs sur la même ligne, nous sommes obligés de placer l'étoile devant chaque nom de pointeur :

  1.Coordonnees *point1 = NULL, *point2 = NULL;


Envoyez la structure à une fonction

Ce qui nous intéresse ici, c'est de savoir comment envoyer un pointeur de structure à une fonction pour que celle-ci puisse modifier le contenu de la variable.

On va faire ceci pour cet exemple : on va simplement créer une variable de type Coordonnees  dans le main et envoyer son adresse à initialiserCoordonnees  . Cette fonction aura pour rôle de mettre tous les éléments de la structure à 0.

Notre fonction initialiserCoordonnees va prendre un paramètre : un pointeur sur une structure de type Coordonnees (un Coordonnees*  , donc).

int main(int argc, char *argv[])
{
    Coordonnees monPoint;

    initialiserCoordonnees(&monPoint);

    return 0;
}

void initialiserCoordonnees(Coordonnees* point)
{
    // Initialisation de chacun des membres de la structure ici
}

Ma variable monPoint est donc créée dans le main  .

On envoie son adresse à la fonction initialiserCoordonnees qui récupère cette variable sous la forme d'un pointeur appelé point (on aurait d'ailleurs pu l'appeler n'importe comment dans la fonction, cela n'aurait pas eu d'incidence).

Maintenant que nous sommes dans initialiserCoordonnees  , nous allons initialiser chacune des valeurs une à une.

Il ne faut pas oublier de mettre une étoile devant le nom du pointeur pour accéder à la variable. Si vous ne le faites pas, vous risquez de modifier l'adresse, et ce n'est pas ce que nous voulons faire.

Oui mais voilà, problème… On ne peut pas vraiment faire :

void initialiserCoordonnees(Coordonnees* point)
{
    *point.x = 0;
    *point.y = 0;
}


Pourquoi on ne peut pas faire ça ?

Parce que le point de séparation s'applique sur le mot point et non sur *point en entier. Or, nous ce qu'on veut, c'est accéder à *point pour en modifier la valeur.

Pour régler le problème, il faut placer des parenthèses autour de *point ;  le point de séparation s'appliquera à *point et non juste à point  :

void initialiserCoordonnees(Coordonnees* point)
{
    (*point).x = 0;
    (*point).y = 0;
}


La variable de type Coordonnees a été transmise à la fonction qui a initialisé x et y à 0.

En langage C, on initialise généralement nos structures avec la méthode simple qu'on a vue plus haut. En C++ en revanche, on initialise plus souvent dans des fonctions. Le C++ n'est en fait rien d'autre qu'une sorte de super-amélioration des structures.


Utilisez ce raccourci

Vous allez voir qu'on manipulera très souvent des pointeurs de structures. Pour être franc, je dois même vous avouer qu'en C, on utilise plus souvent des pointeurs de structures que des structures tout court.

Comme les pointeurs de structures sont très utilisés, on sera souvent amené à écrire ceci :

  1.(*point).x = 0;

Oui mais voilà, encore une fois les programmeurs trouvent ça trop long. Les parenthèses autour de *point  , quelle plaie ! Alors, ils ont inventé le raccourci suivant :

  1.point->x = 0;

Ce raccourci consiste à former une flèche avec un tiret suivi d'un chevron >  .
Écrire point->x est donc STRICTEMENT équivalent à écrire (*point).x  .

On ne peut utiliser la flèche que sur un pointeur !
Si vous travaillez directement sur la variable, vous devez utiliser le point.

Utilisez ce petit exemple pour vous en souvenir :


int main(int argc, char *argv[])
{
    Coordonnees monPoint;
    Coordonnees *pointeur = &monPoint;

    monPoint.x = 10; // On travaille sur une variable, on utilise le "point"
    pointeur->x = 10; // On travaille sur un pointeur, on utilise la flèche

    return 0;
}


On modifie la valeur du x à 10 de deux manières différentes, ici : la première fois en travaillant directement sur la variable, la seconde fois en passant par le pointeur.

Reprenons maintenant notre fonction initialiserCoordonnees ; nous pouvons alors l'écrire comme ceci :

void initialiserCoordonnees(Coordonnees* point)
{
    point->x = 0;
    point->y = 0;
}


Utilisez des énumérations

Les énumérations constituent une façon un peu différente de créer ses propres types de variables.

Une énumération ne contient pas de sous-variables comme c'était le cas pour les structures. C'est une liste de valeurs possibles pour une variable. Une énumération ne prend donc qu'une case en mémoire, et cette case peut prendre une des valeurs que vous définissez (et une seule à la fois).

Voici un exemple d'énumération :

typedef enum Volume Volume;
enum Volume
{
    FAIBLE, MOYEN, FORT
};


Vous noterez qu'on utilise un typedef là aussi, comme on l'a fait jusqu'ici.

Pour créer une énumération, on utilise le mot-clé enum  .

Notre énumération s'appelle ici Volume  . C'est un type de variable personnalisé qui peut prendre une des trois valeurs qu'on a indiquées : soit FAIBLE, soit MOYEN, soit FORT  .

On va pouvoir créer une variable de type Volume  , par exemple musique  , qui stockera le volume actuel de la musique.

On peut par exemple initialiser la musique au volume MOYEN  :

  1.Volume musique = MOYEN;

Voilà qui est fait. Plus tard dans le programme, on pourra modifier la valeur du volume et la mettre soit à FAIBLE, soit à FORT  .

Associez des nombres aux valeurs

Vous avez remarqué que j'ai écrit les valeurs possibles de l'énumération en majuscules. Cela devrait vous rappeler les constantes et les define  , non ?

En effet, c'est assez similaire, mais ce n'est pourtant pas exactement la même chose. Le compilateur associe automatiquement un nombre à chacune des valeurs possibles de l'énumération.

Dans le cas de notre énumération Volume  , FAIBLE vaut 0, MOYEN vaut 1 et FORT vaut 2. L'association est automatique et commence à 0.

Contrairement au #define  , c'est le compilateur qui associe MOYEN  à 1 par exemple, et non le préprocesseur. Au bout du compte, ça revient un peu au même. En fait, quand on a initialisé la variable musique  à MOYEN  , on a donc mis la case en mémoire à la valeur 1.

En pratique, est-ce utile de savoir que MOYEN vaut 1, FORT vaut 2, etc. ?

Non. En général ça nous est égal. C'est le compilateur qui associe automatiquement un nombre à chaque valeur. Grâce à ça, vous n'avez plus qu'à écrire :

if (musique == MOYEN)
{
    // Jouer la musique au volume moyen
}


Peu importe la valeur de MOYEN  , vous laissez le compilateur se charger de gérer les nombres.

Du coup, votre code est très lisible : tout le monde peut facilement lire le if précédent (on comprend bien que la condition signifie "Si la musique est au volume moyen").


Associez une valeur précise

Pour le moment, c'est le compilateur qui décide d'associer le nombre 0 à la première valeur, puis 1, 2, 3 dans l'ordre. Il est possible de demander d'associer une valeur précise à chaque élément de l'énumération.

Quel intérêt est-ce que ça peut bien avoir ?

Supposons que sur votre ordinateur, le volume soit géré entre 0 et 100 (0 = pas de son, 100 = 100 % du son). Il est alors pratique d'associer une valeur précise à chaque élément :


typedef enum Volume Volume;
enum Volume
{
    FAIBLE = 10, MOYEN = 50, FORT = 100
};


Ici, le volume FAIBLE correspondra à 10 % de volume, le volume MOYEN à 50 %, etc.

On pourrait facilement ajouter de nouvelles valeurs possibles comme MUET  . On associerait dans ce cas MUET  à la valeur… 0 ! Vous avez compris.

Un autre petit point à noter : si vous ne précisez pas la valeur d’un élément, elle sera forcément égale à la valeur de l'élément précédent + 1.

Dans le cas suivant, l’élément FORT est égal à 51 car la valeur précédente est égale à 50 :


typedef enum Volume Volume;
enum Volume
{
···FAIBLE = 10, MOYEN = 50, FORT·
};


En résumé

  - Une structure est un type de variable personnalisé que vous pouvez créer et utiliser dans vos programmes. 
    C'est à vous de la définir, contrairement aux types de base tels que int etdouble que l'on retrouve dans 
    tous les programmes.

  - Une structure est composée de "sous-variables" qui sont en général des variables de type de base comme int 
    et double  , mais aussi des tableaux.

  - On accède à un des composants de la structure en séparant le nom de la variable et la composante d'un 
    point : joueur.prenom  .

  - Si on manipule un pointeur de structure et qu'on veut accéder à une des composantes, on utilise une flèche 
    à la place du point : pointeurJoueur->prenom  .

  - Une énumération est un type de variable personnalisé qui peut seulement prendre une des valeurs 
    prédéfinies : FAIBLE  , MOYEN ou FORT   , par exemple.

Découvrons maintenant comment lire et écrire dans des fichiers. C’est parti !

##############################################################################################################

Manipulez des fichiers à l'aide de fonctions

Les variables n'existent que dans la mémoire vive : une fois votre programme arrêté, elles sont supprimées de la mémoire et il n'est pas possible de retrouver ensuite leur valeur. Comment peut-on faire un éditeur de texte si tout le texte écrit disparaît lorsqu'on arrête le programme ?

On peut lire et écrire dans des fichiers en langage C. Ces fichiers seront écrits sur le disque dur de votre ordinateur : ils restent là même si vous arrêtez le programme ou l'ordinateur.

Pour lire et écrire dans des fichiers, nous allons nous servir de fonctions situées dans des bibliothèques standard.

Incluez au moins les bibliothèques stdio.h et stdlib.h en haut de votre fichier .c  :

  1.#include <stdlib.h>
  2.#include <stdio.h>

Je vous recommande d'ailleurs de les inclure dans tous vos futurs programmes, quels qu'ils soient.

Pour commencer, voyons d'abord comment ouvrir et fermer un fichier. Nous verrons ensuite comment le modifier.


Ouvrez un fichier avec  fopen


Chaque fois que vous voulez ouvrir un fichier, que ce soit pour le lire ou pour y écrire, il faut :

  1. Appeler la fonction d'ouverture de fichier fopen qui renvoie un pointeur sur le fichier.

  2. Vérifier si l'ouverture a réussi (c'est-à-dire si le fichier existait) en testant la valeur du pointeur 
     qu'on a reçu. Nous verrons comment faire dans un instant.

Dans le chapitre sur les chaînes, nous nous sommes servis des prototypes des fonctions comme d'un mode d'emploi. Voyons justement le prototype de la fonction fopen  :

  1.FILE* fopen(const char* nomDuFichier, const char* modeOuverture);

Cette fonction attend deux paramètres :

  1. Le nom du fichier à ouvrir.

  2. Le mode d'ouverture du fichier, c'est-à-dire une indication qui mentionne ce que vous voulez faire : 
     seulement écrire dans le fichier, seulement le lire, ou les deux à la fois.

Cette fonction renvoie un pointeur sur FILE (une structure de type FILE qui est définie dans stdio.h  ). Elle renvoie un FILE*  .

Il faut absolument récupérer ce pointeur pour pouvoir ensuite lire et écrire dans le fichier.
Créons donc un pointeur de FILE  au début de notre fonction, par exemple la fonction main :

int main(int argc, char *argv[])
{
    FILE* fichier = NULL;

    return 0;
}


Le pointeur est initialisé à NULL dès le début.

Initialiser un pointeur à NULL dès le début, si on n'a pas d'autre valeur à lui donner, est fondamental !
Si vous ne le faites pas, vous augmentez considérablement le risque d'erreur par la suite.

Il n'est pas nécessaire d'écrire struct FILE* fichier = NULL  . Les créateurs de stdio ont donc fait un typedef .
La forme de la structure peut changer d'un système d'exploitation à l'autre (elle ne contient pas forcément les mêmes sous-variables partout). On ne modifie donc jamais le contenu d'un FILE directement (on ne fait pas fichier.element  , par exemple). On utilise des fonctions qui manipulent le FILE  à notre place.

Maintenant, nous allons appeler la fonction fopen et récupérer la valeur qu'elle renvoie dans le pointeur fichier  . Mais avant ça, il faut que je vous explique comment se servir du second paramètre, le paramètre modeOuverture  . En effet, il y a un code à envoyer qui indiquera à l'ordinateur si vous ouvrez le fichier en mode de lecture seule, d'écriture seule, ou des deux à la fois.

Voici les principaux modes d'ouverture possibles :

  - "r"  : lecture seule. Vous pourrez lire le contenu du fichier, mais pas y écrire. Le fichier doit avoir 
           été créé au préalable.

  - "w"  : écriture seule. Vous pourrez écrire dans le fichier, mais pas lire son contenu. Si le fichier 
           n'existe pas, il sera créé.

  - "a"  : mode d'ajout. Vous écrirez dans le fichier, en partant de la fin du fichier. Vous ajouterez donc du 
           texte à la fin du fichier. Si le fichier n'existe pas, il sera créé. Ce mode d'ajout peut être 
           utile si vous voulez seulement ajouter des informations à la fin du fichier.

  - "a+"  : ajout en lecture / écriture à la fin. Vous écrivez et lisez du texte à partir de la fin du 
            fichier. Si le fichier n'existe pas, il sera créé.

  - "r+"  : lecture et écriture. Vous pourrez lire et écrire dans le fichier. Le fichier doit avoir été créé 
            au préalable.

  - "w+"  : lecture et écriture, avec suppression du contenu au préalable. Le fichier est donc d'abord vidé de 
            son contenu, vous pouvez y écrire, et le lire ensuite. Si le fichier n'existe pas, il sera créé.


"r" (lecture), "w" (écriture) et "r+" (lecture et écriture) sont ceux que vous utiliserez le plus souvent.
Si vous avez juste l'intention de lire un fichier, il est conseillé de mettre "r"  . Certes, le mode "r+"  aurait fonctionné aussi, mais avec "r"  vous vous assurez que le fichier ne pourra pas être modifié, ce qui est en quelque sorte une sécurité.

Le mode "w+"  est un peu dangereux parce qu'il vide de suite le contenu du fichier, sans demande de confirmation.

Il ne doit être utilisé que si vous voulez d'abord réinitialiser le fichier.

Le code suivant ouvre le fichier test.txt en mode "r+"  (lecture et écriture) :

int main(int argc, char *argv[])
{
    FILE* fichier = NULL;

    fichier = fopen("test.txt", "r+");

    return 0;
}

Le pointeur fichier devient alors un pointeur sur test.txt  .

Où doit être situé test.txt  ?

Il doit être situé dans le même dossier que votre exécutable ( .exe  ). Pour les besoins de ce chapitre, créez un fichier test.txt dans le même dossier que le .exe :


Le fichier doit-il être de type .txt  ?

Non. C'est vous qui choisissez l'extension lorsque vous ouvrez le fichier. Vous pouvez très bien inventer votre propre format de fichier.

Le fichier doit-il être obligatoirement dans le même répertoire que l'exécutable ?

Non plus. Il peut être dans un sous-dossier :

  1.fichier = fopen("dossier/test.txt", "r+");

Ici, le fichier test.txt est dans un sous-dossier appelé dossier  . Cette méthode, que l'on appelle "chemin relatif", est plus pratique. Comme ça, cela fonctionnera, peu importe l'endroit où est installé votre programme.

Il est aussi possible d'ouvrir un autre fichier n'importe où ailleurs sur le disque dur. Dans ce cas, il faut écrire le chemin complet (ce qu'on appelle le "chemin absolu") :

  1.fichier = fopen("C:\\Program Files\\Notepad++\\readme.txt", "r+");

Ce code ouvre le fichier readme.txt situé dans C:\Program Files\Notepad++  .

Il faut mettre deux "antislashs" \  à chaque fois, comme vous l'avez remarqué.
S'il n'y en a qu'un, votre ordinateur pensera que vous essayez d'insérer un symbole spécial comme \n ou \t  .
Pour écrire un "antislash" dans une chaîne, il faut donc l'écrire deux fois : votre ordinateur comprend alors que c'est bien le symbole \  que vous vouliez utiliser.

Le défaut des chemins absolus, c'est qu'ils ne fonctionnent que sur un système d'exploitation précis. Ce n'est pas une solution portable, donc. Si vous aviez été sous Linux, vous auriez dû écrire un chemin "à la Linux", tel que :

  1.fichier = fopen("/home/mateo/dossier/readme.txt", "r+");

Je vous recommande donc d'utiliser des chemins relatifs plutôt que des chemins absolus. N'utilisez les chemins absolus que si votre programme est fait pour un système d'exploitation précis, et doit modifier un fichier précis quelque part sur votre disque dur.

Le pointeur fichier devrait contenir l'adresse de la structure de type FILE qui sert de descripteur de fichier. Celui-ci a été chargé en mémoire pour vous par la fonction fopen()  .

À partir de là, deux possibilités :

  1. Soit l'ouverture a réussi : vous pouvez commencer à lire et écrire dans le fichier via des fonctions que 
     je vais vous présenter dans la suite de ce chapitre.

  2. Soit l'ouverture a échoué parce que le fichier n'existait pas ou était utilisé par un autre programme : 
     vous devez arrêter de travailler sur le fichier.

Juste après l'ouverture du fichier, il faut impérativement vérifier si l'ouverture a réussi ou non. Pour faire ça, c'est très simple : si le pointeur vaut NULL  , l'ouverture a échoué. S'il vaut autre chose que NULL  , l'ouverture a réussi.

On va donc suivre systématiquement le schéma suivant :

int main(int argc, char *argv[])
{
    FILE* fichier = NULL;

    fichier = fopen("test.txt", "r+");

    if (fichier != NULL)
    {
        // On peut lire et écrire dans le fichier
    }
    else
    {
        // On affiche un message d'erreur si on veut
        printf("Impossible d'ouvrir le fichier test.txt");
    }

    return 0;
}

Faites toujours cela lorsque vous ouvrez un fichier. Si vous ne le faites pas et que le fichier n'existe pas, vous risquez un plantage du programme par la suite.

Quand vous avez terminé de travailler sur un fichier, n'oubliez pas de le fermer avec la fonction fclose  .


Fermez un fichier avec fclose

Si l'ouverture du fichier a réussi, vous pouvez le lire et y écrire (nous allons voir sous peu comment faire).
Une fois que vous aurez fini de travailler avec le fichier, il faudra le « fermer ». On utilise pour cela la fonction fclose  qui a pour rôle de libérer la mémoire, c'est-à-dire supprimer votre fichier chargé dans la mémoire vive.

Son prototype est :

  1.int fclose(FILE* pointeurSurFichier);

Cette fonction prend un paramètre : votre pointeur sur le fichier.
Elle renvoie un int  qui indique si elle a réussi à fermer le fichier. Ce int  vaut :

  - 0  : si la fermeture a marché ;

  - EOF  : si la fermeture a échoué. EOF  est un define  situé dans stdio.h  qui correspond à un nombre 
           spécial, utilisé pour dire soit qu'il y a eu une erreur, soit que nous sommes arrivés à la fin du 
           fichier. Dans le cas présent, cela signifie qu'il y a eu une erreur.

À priori, la fermeture se passe toujours bien : je n'ai donc pas l'habitude de tester si le fclose  a marché. Vous pouvez néanmoins le faire si vous le voulez.

Pour fermer le fichier, on va donc écrire :

  1.fclose(fichier);

Au final, le schéma que nous allons suivre pour ouvrir et fermer un fichier sera le suivant :


int main(int argc, char *argv[])
{
    FILE* fichier = NULL;

    fichier = fopen("test.txt", "r+");

    if (fichier != NULL)
    {
        // On lit et on écrit dans le fichier
        
        // ...
        
        fclose(fichier); // On ferme le fichier qui a été ouvert
    }

    return 0;
}


Je n'ai pas mis le else  ici pour afficher un message d'erreur si l'ouverture a échoué, mais vous pouvez le faire si vous le désirez.
Il faut toujours penser à fermer son fichier une fois que l'on a fini de travailler avec. Cela permet de libérer de la mémoire.
Si vous oubliez de libérer la mémoire, votre programme risque à la fin de prendre énormément de mémoire qu'il n'utilise plus. Sur un petit exemple comme ça ce n'est pas flagrant, mais sur un gros programme, bonjour les dégâts !

Oublier de libérer la mémoire, ça arrive. Ça vous arrivera d'ailleurs très certainement. Dans ce cas, vous serez témoin de ce que l'on appelle des fuites mémoire. Votre programme se mettra alors à utiliser plus de mémoire que nécessaire sans que vous arriviez à comprendre pourquoi. Bien souvent, il s'agit simplement d'un ou deux « détails », comme des petits fclose  oubliés.

Maintenant que nous avons écrit le code qui ouvre et ferme le fichier, nous n'avons plus qu'à insérer le code qui le lit et y écrit.

Nous allons commencer par voir comment écrire dans un fichier (ce qui est un peu plus simple), puis nous verrons ensuite comment lire dans un fichier.


Écrivez dans un fichier

Il existe plusieurs fonctions capables d'écrire dans un fichier. Ce sera à vous de choisir celle qui est la plus adaptée à votre cas.
Voici les trois fonctions que nous allons étudier :

  1. fputc écrit un caractère dans le fichier (UN SEUL caractère à la fois).

  2. fputs écrit une chaîne dans le fichier.

  3. fprintf écrit une chaîne formatée dans le fichier.


1. Écrivez un caractère dans le fichier avec fputc

Cette fonction écrit un caractère à la fois dans le fichier. Son prototype est :

  1.int fputc(int caractere, FILE* pointeurSurFichier);

Elle prend deux paramètres.

  - Le caractère à écrire (de type int  , ce qui comme je vous l'ai dit revient plus ou moins à utiliser un 
    char  , sauf que le nombre de caractères utilisables est ici plus grand). Vous pouvez donc écrire 
    directement 'A'  , par exemple.

  - Le pointeur sur le fichier dans lequel écrire. Dans notre exemple, notre pointeur s'appelle fichier  . 
    L'avantage de demander le pointeur de fichier à chaque fois, c'est que vous pouvez ouvrir plusieurs 
    fichiers en même temps, et donc lire et écrire dans chacun de ces fichiers. Vous n'êtes pas limité à un 
    seul fichier ouvert à la fois.

La fonction retourne un int, c'est un code d'erreur. Ce int vaut EOF si l'écriture a échoué, sinon il a une autre valeur.
Comme le fichier a normalement été ouvert avec succès, je n'ai pas l'habitude de tester si chacun de mes fputc a réussi, mais vous pouvez le faire encore une fois si vous le voulez.

Le code suivant écrit la lettre 'A' dans test.txt  (si le fichier existe, il est remplacé ; s'il n'existe pas, il est créé). Il y a tout dans ce code : ouverture, test de l'ouverture, écriture et fermeture.

int main(int argc, char *argv[])
{
    FILE* fichier = NULL;
 
    fichier = fopen("test.txt", "w");
 
    if (fichier != NULL)
    {
        fputc('A', fichier); // Écriture du caractère A
        fclose(fichier);
    }
 
    return 0;
}

Ouvrez votre fichier test.txt  .   Que voyez-vous ?
C'est magique, le fichier contient maintenant la lettre 'A' : 


2. Écrivez une chaîne dans le fichier avec fputs

Cette fonction est très similaire à fputc  , à la différence près qu'elle écrit tout une chaîne, ce qui est en général plus pratique que d'écrire caractère par caractère.
Cela dit, fputc reste utile lorsque vous devez écrire caractère par caractère, ce qui arrive fréquemment.

Prototype de la fonction :

  1.char* fputs(const char* chaine, FILE* pointeurSurFichier);

Les deux paramètres sont faciles à comprendre.

  - chaine  : la chaîne à écrire. Notez que le type ici est const char*  : en ajoutant le mot const dans le 
    prototype, la fonction indique que pour elle la chaîne sera considérée comme une constante. En un mot 
    comme en cent : elle s'interdit de modifier le contenu de votre chaîne. C'est logique quand on y pense : 
    fputs doit juste lire votre chaîne, pas la modifier. C'est donc pour vous une information (et une 
    sécurité) indiquant que votre chaîne ne subira pas de modification.

  - pointeurSurFichier  : comme pour fputc  , il s'agit de votre pointeur de type FILE* sur le fichier que 
    vous avez ouvert.

La fonction renvoie EOF s'il y a eu une erreur, sinon c'est que cela a fonctionné. Là non plus, je ne teste en général pas la valeur de retour.

Testons l'écriture d'une chaîne dans le fichier :

int main(int argc, char *argv[])
{
    FILE* fichier = NULL;
 
    fichier = fopen("test.txt", "w");
 
    if (fichier != NULL)
    {
        fputs("Salut les développeurs\nBienvenue sur OpenClassrooms !", fichier);
        fclose(fichier);
    }
 
    return 0;
}

Voici le fichier une fois modifié par le programme :


3. Écrivez une chaîne "formatée" dans le fichier avec fprintf

Voici un autre exemplaire de la fonction printf  . Celle-ci peut être utilisée pour écrire dans un fichier. Elle s'utilise de la même manière que printf  d'ailleurs, excepté le fait que vous devez indiquer un pointeur de FILE  en premier paramètre.

Ce code demande l'âge de l'utilisateur et l'écrit dans le fichier (résultat fig. suivante) :

int main(int argc, char *argv[])
{
    FILE* fichier = NULL;
    int age = 0;
 
    fichier = fopen("test.txt", "w");
 
    if (fichier != NULL)
    {
        // On demande l'âge
        printf("Quel age avez-vous ? ");
        scanf("%d", &age);
 
        // On l'écrit dans le fichier
        fprintf(fichier, "Le Monsieur qui utilise le programme, il a %d ans", age);
        fclose(fichier);
    }
 
    return 0;
}

Vous pouvez ainsi facilement réutiliser ce que vous savez de printf  pour écrire dans un fichier ! C'est pour cette raison d'ailleurs que j'utilise le plus souvent fprintf  pour écrire dans des fichiers.

