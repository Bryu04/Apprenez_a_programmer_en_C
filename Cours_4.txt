                           Partie 4 : Allez plus loin pour programmer comme un pro


Créez vos propres types de variables

En C, lorsque l'on cherche à faire des programmes plus complexes, on peut créer nos propres types de variables :

   1. Les structures.

   2. Et les énumérations.

Et bonne nouvelle : c'est plutôt simple à comprendre et à manipuler !


Définissez une structure

Une structure est un assemblage de variables qui peuvent avoir différents types.
Contrairement aux tableaux qui vous obligent à utiliser le même type dans tout le tableau, vous pouvez créer une structure comportant des variables de types long  , char  , int et double à la fois.

Les structures sont généralement définies dans les fichiers .h  , au même titre que les prototypes et les define  .

Pour définir une structure, il suffit de :

  - commencer par taper  struct ;

  - puis écrire le nom de la structure ;

ASTUCE : nommez vos structures en suivant les mêmes règles que pour les noms de variables, sauf que vous mettez la première lettre en majuscule pour pouvoir faire la différence.
Du coup, en regardant mon code, si vous voyez quelque chose comme :

    - ageDuCapitaine , vous saurez qu'il s'agit d'une variable car cela commence par une lettre minuscule ;

    - MorceauAudio , vous saurez qu'il s'agit d'une structure (un type personnalisé) car cela commence par une 
      majuscule.

  - ouvrir ensuite les accolades et les fermer plus loin, comme pour une fonction ;

Attention, ici c'est particulier : vous DEVEZ mettre un point-virgule après l'accolade fermante. C'est obligatoire. Si vous ne le faites pas, la compilation plantera.

  - placer entre les accolades les variables dont est composée votre structure. Une structure est généralement 
    composée d'au moins deux "sous-variables ", sinon elle n'a pas trop d'intérêt. Toutes les structures que 
    vous verrez sont en fait des "assemblages" de variables de type de base, comme long, int, double, etc. 

Voici donc à quoi ressemble une structure  :


struct NomDeVotreStructure
{
    int variable1;
    int variable2;
    int autreVariable;
    double nombreDecimal;
};

Imaginons par exemple que vous vouliez créer une variable qui stocke les coordonnées d'un point à l'écran.

Lorsqu'on travaille en 2D (2 dimensions), on a deux axes : l'axe des abscisses (de gauche à droite) et l'axe des ordonnées (de bas en haut). On a l'habitude d'exprimer les abscisses par une variable appelée x  , et les ordonnées par y  .

Voyons ce que ça donne :

struct Coordonnees
{
    int x; // Abscisses
    int y; // Ordonnées
};


Notre structure s'appelle Coordonnees et est composée de deux variables x et y  , c'est-à-dire de l'abscisse et de l'ordonnée.

Si on le voulait, on pourrait facilement faire une structure Coordonnees pour de la 3D : il suffirait d'ajouter une troisième variable (par exemple z  ) qui indiquerait la hauteur. 


Placez des tableaux dans une structure

Les structures peuvent contenir des tableaux. Ça tombe bien, on va pouvoir ainsi placer des tableaux de char (chaînes de caractères) sans problème !

Allez, imaginons une structure Personne qui stocke diverses informations sur une personne :

struct Personne
{
    char nom[100];
    char prenom[100];
    char adresse[1000];
    
    int age;
    int etudiant; // Booléen : 1 = etudiant, 0 = non etudiant
};

Cette structure est composée de cinq sous-variables. Les trois premières sont des chaînes qui stockeront le nom, le prénom et l'adresse de la personne. Les deux dernières stockent l'âge et le statut étudiant de la personne (c'est un booléen, 1 = vrai = étudiant, 0 = faux = pas étudiant).

Vous pouvez rajouter des variables dans la structure pour la compléter si vous le voulez. Il n'y a pas de limite au nombre de variables dans une structure.

Utilisez une structure dans une fonction

Maintenant que notre structure est définie dans le .h  , on va pouvoir l'utiliser dans une fonction de notre fichier .c  .

Voici comment créer une variable de type Coordonnees  (la structure qu'on a définie plus haut) :

#include "main.h" // Inclusion du .h qui contient les prototypes et structures

int main(int argc, char *argv[])
{
    struct Coordonnees point; // Création d'une variable "point" de type Coordonnees

    return 0;
}


Nous avons ainsi créé une variable point de type Coordonnees  . Cette variable est automatiquement composée de deux sous-variables : x et y  (son abscisse et son ordonnée).

Faut-il obligatoirement écrire le mot-clé struct lors de la définition de la variable ?

Oui, cela permet à l'ordinateur de différencier un type de base (comme int  ) d'un type personnalisé, comme Coordonnees  .

Toutefois, les programmeurs trouvent souvent un peu lourd de mettre le mot struct à chaque définition de variable personnalisée. Pour régler ce problème, ils ont inventé une instruction spéciale : le typedef  .

Créez un alias de structure avec l'instruction typedef

Retournons dans le fichier .h qui contient la définition de notre structure de typeCoordonnees  . Nous allons ajouter une instruction appelée typedef pour créer un alias de structure et dire qu'écrire telle chose équivaut à écrire telle autre chose.

Ajoutons une ligne commençant par typedef juste avant la définition de la structure :

typedef struct Coordonnees Coordonnees;
struct Coordonnees
{
    int x;
    int y;
};

Cette ligne doit être découpée en trois morceaux (non, je n'ai pas bégayé le mot Coordonnees  ) :

  - typedef  : indique que nous allons créer un alias de structure ;

  - struct Coordonnees  : c'est le nom de la structure dont vous allez créer un alias (c'est-à-dire un "équivalent") ;

  - Coordonnees  : c'est le nom de l'équivalent.

En clair, cette ligne dit :

"Écrire le mot Coordonnees est désormais équivalent à écrire struct Coordonnees  ".

En faisant cela, vous n'aurez plus besoin de mettre le mot struct à chaque définition de variable de type Coordonnees  . On peut donc retourner dans notre main et écrire :

int main(int argc, char *argv[])
{
    Coordonnees point; // L'ordinateur comprend qu'il s'agit de "struct Coordonnees" grâce au typedef
    return 0;
}

Je vous recommande de faire un typedef comme je l'ai fait ici pour Coordonnees  . Ça évite d'avoir à écrire le mot struct partout. Un bon programmeur est un programmeur fainéant ! Il en écrit le moins possible.

Modifiez les composantes de la structure

Maintenant que notre variable point est créée, nous voulons modifier ses coordonnées.
Comment accéder au x et au y de point? Comme ceci :

int main(int argc, char *argv[])
{
    Coordonnees point;
    
    point.x = 10;
    point.y = 20;

    return 0;
}

On a ainsi modifié la valeur de point  , en lui donnant une abscisse de 10 et une ordonnée de 20. Notre point se situe désormais à la position (10 ; 20) ; c'est la notation mathématique d'une coordonnée.

Pour accéder à chaque composante de la structure, vous devez donc écrire :

  1.variable.nomDeLaComposante

Le point fait la séparation entre la variable et la composante.

Si on prend la structure Personne que nous avons vue tout à l'heure, et qu'on demande le nom et le prénom, on devra faire comme ça :

int main(int argc, char *argv[])
{
    Personne utilisateur;

    printf("Quel est votre nom ? ");
    scanf("%s", utilisateur.nom);
    printf("Votre prenom ? ");
    scanf("%s", utilisateur.prenom);

    printf("Vous vous appelez %s %s", utilisateur.prenom, utilisateur.nom);

    return 0;
}

Quel est votre nom ? Dupont
Votre prenom ? Jean
Vous vous appelez Jean Dupont

On envoie la variable utilisateur.nom à scanf qui écrira directement dans notre variable utilisateur  . On fait de même pour prenom  , et on pourrait aussi le faire pour l'adresse, l'âge et le statut étudiant, mais je n'ai guère envie de me répéter (je dois être programmeur, c'est pour ça).

Vous auriez pu faire la même chose sans connaître les structures, en créant juste une variable nom et une autre, prenom  . Mais l'intérêt ici est que vous pouvez créer une autre variable de type Personne qui aura aussi son propre nom, son propre prénom, etc.

On peut donc faire :

  1.Personne joueur1, joueur2;

… et stocker ainsi les informations sur chaque joueur. Chaque joueur a son propre nom, son propre prénom, etc.

On peut même faire encore mieux : on peut créer un tableau de Personne :

  1.Personne joueurs[2];

Et ensuite, vous accédez par exemple au nom du joueur n° 0 en tapant :

  1.joueurs[0].nom

L'avantage d'utiliser un tableau ici, c'est que vous pouvez faire une boucle pour demander les infos du joueur 1 et du joueur 2, sans avoir à répéter deux fois le même code. Il suffit de parcourir le tableau joueur et de demander à chaque fois nom, prénom, adresse…


Initialisez une structure

Pour les structures comme pour les variables, tableaux et pointeurs, il est vivement conseillé de les initialiser dès leur création pour éviter qu'elles ne contiennent n'importe quoi.

En effet, une variable qui est créée prend la valeur de ce qui se trouve en mémoire là où elle a été placée. Parfois cette valeur est 0, parfois c'est un résidu d'un autre programme qui est passé par là avant vous, et la variable a alors une valeur qui n'a aucun sens, comme -84570.

Pour rappel, voici comment on initialise :

  - une variable : on met sa valeur à 0 (cas le plus simple) ;

  - un pointeur : on met sa valeur à NULL  . NULL  est en fait un #define situé dans stdlib.h qui vaut 
    généralement 0, mais on continue à utiliser NULL par convention sur les pointeurs pour bien voir qu'il 
    s'agit de pointeurs et non de variables ordinaires ;

  - un tableau : on met chacune de ses valeurs à 0.

Pour une structure, l'initialisation ressemble un peu à celle d'un tableau.

En effet, on peut faire à la déclaration de la variable :

  1.Coordonnees point = {0, 0};

Cela définira, dans l'ordre :

  1. point.x = 0  .

  2. point.y = 0  .

Pour envoyer ma variable point à une fonction initialiserCoordonnees par exemple, qui se charge de faire les initialisations sur ma variable, je peux envoyer un pointeur de ma variable.

En effet, si j'envoie juste ma variable, une copie en sera réalisée dans la fonction (comme pour une variable de base), et la fonction modifiera les valeurs de la copie et non celles de ma vraie variable. Revoyez le fil rouge du chapitre sur les pointeurs si vous avez oublié comment cela fonctionne.

Reprenons l’exemple de la structure  Personne  et voyons comment créer et utiliser la structure dans la vidéo suivante :


Utilisez un pointeur sur une structure

Un pointeur de structure se crée de la même manière qu'un pointeur de int  , de double ou de n'importe quel autre type de base :

  1.Coordonnees* point = NULL;

On a ainsi un pointeur de Coordonnees appelé point  .

Comme un rappel ne fera de mal à personne, je tiens à vous répéter que l'on aurait aussi pu mettre l'étoile devant le nom du pointeur, cela revient exactement au même :

  1.Coordonnees *point = NULL;

C'est même mieux car pour définir plusieurs pointeurs sur la même ligne, nous sommes obligés de placer l'étoile devant chaque nom de pointeur :

  1.Coordonnees *point1 = NULL, *point2 = NULL;


Envoyez la structure à une fonction

Ce qui nous intéresse ici, c'est de savoir comment envoyer un pointeur de structure à une fonction pour que celle-ci puisse modifier le contenu de la variable.

On va faire ceci pour cet exemple : on va simplement créer une variable de type Coordonnees  dans le main et envoyer son adresse à initialiserCoordonnees  . Cette fonction aura pour rôle de mettre tous les éléments de la structure à 0.

Notre fonction initialiserCoordonnees va prendre un paramètre : un pointeur sur une structure de type Coordonnees (un Coordonnees*  , donc).

int main(int argc, char *argv[])
{
    Coordonnees monPoint;

    initialiserCoordonnees(&monPoint);

    return 0;
}

void initialiserCoordonnees(Coordonnees* point)
{
    // Initialisation de chacun des membres de la structure ici
}

Ma variable monPoint est donc créée dans le main  .

On envoie son adresse à la fonction initialiserCoordonnees qui récupère cette variable sous la forme d'un pointeur appelé point (on aurait d'ailleurs pu l'appeler n'importe comment dans la fonction, cela n'aurait pas eu d'incidence).

Maintenant que nous sommes dans initialiserCoordonnees  , nous allons initialiser chacune des valeurs une à une.

Il ne faut pas oublier de mettre une étoile devant le nom du pointeur pour accéder à la variable. Si vous ne le faites pas, vous risquez de modifier l'adresse, et ce n'est pas ce que nous voulons faire.

Oui mais voilà, problème… On ne peut pas vraiment faire :

void initialiserCoordonnees(Coordonnees* point)
{
    *point.x = 0;
    *point.y = 0;
}


Pourquoi on ne peut pas faire ça ?

Parce que le point de séparation s'applique sur le mot point et non sur *point en entier. Or, nous ce qu'on veut, c'est accéder à *point pour en modifier la valeur.

Pour régler le problème, il faut placer des parenthèses autour de *point ;  le point de séparation s'appliquera à *point et non juste à point  :

void initialiserCoordonnees(Coordonnees* point)
{
    (*point).x = 0;
    (*point).y = 0;
}


La variable de type Coordonnees a été transmise à la fonction qui a initialisé x et y à 0.

En langage C, on initialise généralement nos structures avec la méthode simple qu'on a vue plus haut. En C++ en revanche, on initialise plus souvent dans des fonctions. Le C++ n'est en fait rien d'autre qu'une sorte de super-amélioration des structures.


Utilisez ce raccourci

Vous allez voir qu'on manipulera très souvent des pointeurs de structures. Pour être franc, je dois même vous avouer qu'en C, on utilise plus souvent des pointeurs de structures que des structures tout court.

Comme les pointeurs de structures sont très utilisés, on sera souvent amené à écrire ceci :

  1.(*point).x = 0;

Oui mais voilà, encore une fois les programmeurs trouvent ça trop long. Les parenthèses autour de *point  , quelle plaie ! Alors, ils ont inventé le raccourci suivant :

  1.point->x = 0;

Ce raccourci consiste à former une flèche avec un tiret suivi d'un chevron >  .
Écrire point->x est donc STRICTEMENT équivalent à écrire (*point).x  .

On ne peut utiliser la flèche que sur un pointeur !
Si vous travaillez directement sur la variable, vous devez utiliser le point.

Utilisez ce petit exemple pour vous en souvenir :


int main(int argc, char *argv[])
{
    Coordonnees monPoint;
    Coordonnees *pointeur = &monPoint;

    monPoint.x = 10; // On travaille sur une variable, on utilise le "point"
    pointeur->x = 10; // On travaille sur un pointeur, on utilise la flèche

    return 0;
}


On modifie la valeur du x à 10 de deux manières différentes, ici : la première fois en travaillant directement sur la variable, la seconde fois en passant par le pointeur.

Reprenons maintenant notre fonction initialiserCoordonnees ; nous pouvons alors l'écrire comme ceci :

void initialiserCoordonnees(Coordonnees* point)
{
    point->x = 0;
    point->y = 0;
}


Utilisez des énumérations

Les énumérations constituent une façon un peu différente de créer ses propres types de variables.

Une énumération ne contient pas de sous-variables comme c'était le cas pour les structures. C'est une liste de valeurs possibles pour une variable. Une énumération ne prend donc qu'une case en mémoire, et cette case peut prendre une des valeurs que vous définissez (et une seule à la fois).

Voici un exemple d'énumération :

typedef enum Volume Volume;
enum Volume
{
    FAIBLE, MOYEN, FORT
};


Vous noterez qu'on utilise un typedef là aussi, comme on l'a fait jusqu'ici.

Pour créer une énumération, on utilise le mot-clé enum  .

Notre énumération s'appelle ici Volume  . C'est un type de variable personnalisé qui peut prendre une des trois valeurs qu'on a indiquées : soit FAIBLE, soit MOYEN, soit FORT  .

On va pouvoir créer une variable de type Volume  , par exemple musique  , qui stockera le volume actuel de la musique.

On peut par exemple initialiser la musique au volume MOYEN  :

  1.Volume musique = MOYEN;

Voilà qui est fait. Plus tard dans le programme, on pourra modifier la valeur du volume et la mettre soit à FAIBLE, soit à FORT  .

Associez des nombres aux valeurs

Vous avez remarqué que j'ai écrit les valeurs possibles de l'énumération en majuscules. Cela devrait vous rappeler les constantes et les define  , non ?

En effet, c'est assez similaire, mais ce n'est pourtant pas exactement la même chose. Le compilateur associe automatiquement un nombre à chacune des valeurs possibles de l'énumération.

Dans le cas de notre énumération Volume  , FAIBLE vaut 0, MOYEN vaut 1 et FORT vaut 2. L'association est automatique et commence à 0.

Contrairement au #define  , c'est le compilateur qui associe MOYEN  à 1 par exemple, et non le préprocesseur. Au bout du compte, ça revient un peu au même. En fait, quand on a initialisé la variable musique  à MOYEN  , on a donc mis la case en mémoire à la valeur 1.

En pratique, est-ce utile de savoir que MOYEN vaut 1, FORT vaut 2, etc. ?

Non. En général ça nous est égal. C'est le compilateur qui associe automatiquement un nombre à chaque valeur. Grâce à ça, vous n'avez plus qu'à écrire :

if (musique == MOYEN)
{
    // Jouer la musique au volume moyen
}


Peu importe la valeur de MOYEN  , vous laissez le compilateur se charger de gérer les nombres.

Du coup, votre code est très lisible : tout le monde peut facilement lire le if précédent (on comprend bien que la condition signifie "Si la musique est au volume moyen").


Associez une valeur précise

Pour le moment, c'est le compilateur qui décide d'associer le nombre 0 à la première valeur, puis 1, 2, 3 dans l'ordre. Il est possible de demander d'associer une valeur précise à chaque élément de l'énumération.

Quel intérêt est-ce que ça peut bien avoir ?

Supposons que sur votre ordinateur, le volume soit géré entre 0 et 100 (0 = pas de son, 100 = 100 % du son). Il est alors pratique d'associer une valeur précise à chaque élément :


typedef enum Volume Volume;
enum Volume
{
    FAIBLE = 10, MOYEN = 50, FORT = 100
};


Ici, le volume FAIBLE correspondra à 10 % de volume, le volume MOYEN à 50 %, etc.

On pourrait facilement ajouter de nouvelles valeurs possibles comme MUET  . On associerait dans ce cas MUET  à la valeur… 0 ! Vous avez compris.

Un autre petit point à noter : si vous ne précisez pas la valeur d’un élément, elle sera forcément égale à la valeur de l'élément précédent + 1.

Dans le cas suivant, l’élément FORT est égal à 51 car la valeur précédente est égale à 50 :


typedef enum Volume Volume;
enum Volume
{
···FAIBLE = 10, MOYEN = 50, FORT·
};


En résumé

  - Une structure est un type de variable personnalisé que vous pouvez créer et utiliser dans vos programmes. 
    C'est à vous de la définir, contrairement aux types de base tels que int etdouble que l'on retrouve dans 
    tous les programmes.

  - Une structure est composée de "sous-variables" qui sont en général des variables de type de base comme int 
    et double  , mais aussi des tableaux.

  - On accède à un des composants de la structure en séparant le nom de la variable et la composante d'un 
    point : joueur.prenom  .

  - Si on manipule un pointeur de structure et qu'on veut accéder à une des composantes, on utilise une flèche 
    à la place du point : pointeurJoueur->prenom  .

  - Une énumération est un type de variable personnalisé qui peut seulement prendre une des valeurs 
    prédéfinies : FAIBLE  , MOYEN ou FORT   , par exemple.

Découvrons maintenant comment lire et écrire dans des fichiers. C’est parti !

##############################################################################################################

Manipulez des fichiers à l'aide de fonctions

Les variables n'existent que dans la mémoire vive : une fois votre programme arrêté, elles sont supprimées de la mémoire et il n'est pas possible de retrouver ensuite leur valeur. Comment peut-on faire un éditeur de texte si tout le texte écrit disparaît lorsqu'on arrête le programme ?

On peut lire et écrire dans des fichiers en langage C. Ces fichiers seront écrits sur le disque dur de votre ordinateur : ils restent là même si vous arrêtez le programme ou l'ordinateur.

Pour lire et écrire dans des fichiers, nous allons nous servir de fonctions situées dans des bibliothèques standard.

Incluez au moins les bibliothèques stdio.h et stdlib.h en haut de votre fichier .c  :

  1.#include <stdlib.h>
  2.#include <stdio.h>

Je vous recommande d'ailleurs de les inclure dans tous vos futurs programmes, quels qu'ils soient.

Pour commencer, voyons d'abord comment ouvrir et fermer un fichier. Nous verrons ensuite comment le modifier.


Ouvrez un fichier avec  fopen


Chaque fois que vous voulez ouvrir un fichier, que ce soit pour le lire ou pour y écrire, il faut :

  1. Appeler la fonction d'ouverture de fichier fopen qui renvoie un pointeur sur le fichier.

  2. Vérifier si l'ouverture a réussi (c'est-à-dire si le fichier existait) en testant la valeur du pointeur 
     qu'on a reçu. Nous verrons comment faire dans un instant.

Dans le chapitre sur les chaînes, nous nous sommes servis des prototypes des fonctions comme d'un mode d'emploi. Voyons justement le prototype de la fonction fopen  :

  1.FILE* fopen(const char* nomDuFichier, const char* modeOuverture);

Cette fonction attend deux paramètres :

  1. Le nom du fichier à ouvrir.

  2. Le mode d'ouverture du fichier, c'est-à-dire une indication qui mentionne ce que vous voulez faire : 
     seulement écrire dans le fichier, seulement le lire, ou les deux à la fois.

Cette fonction renvoie un pointeur sur FILE (une structure de type FILE qui est définie dans stdio.h  ). Elle renvoie un FILE*  .

Il faut absolument récupérer ce pointeur pour pouvoir ensuite lire et écrire dans le fichier.
Créons donc un pointeur de FILE  au début de notre fonction, par exemple la fonction main :

int main(int argc, char *argv[])
{
    FILE* fichier = NULL;

    return 0;
}


Le pointeur est initialisé à NULL dès le début.

Initialiser un pointeur à NULL dès le début, si on n'a pas d'autre valeur à lui donner, est fondamental !
Si vous ne le faites pas, vous augmentez considérablement le risque d'erreur par la suite.

Il n'est pas nécessaire d'écrire struct FILE* fichier = NULL  . Les créateurs de stdio ont donc fait un typedef .
La forme de la structure peut changer d'un système d'exploitation à l'autre (elle ne contient pas forcément les mêmes sous-variables partout). On ne modifie donc jamais le contenu d'un FILE directement (on ne fait pas fichier.element  , par exemple). On utilise des fonctions qui manipulent le FILE  à notre place.

Maintenant, nous allons appeler la fonction fopen et récupérer la valeur qu'elle renvoie dans le pointeur fichier  . Mais avant ça, il faut que je vous explique comment se servir du second paramètre, le paramètre modeOuverture  . En effet, il y a un code à envoyer qui indiquera à l'ordinateur si vous ouvrez le fichier en mode de lecture seule, d'écriture seule, ou des deux à la fois.

Voici les principaux modes d'ouverture possibles :

  - "r"  : lecture seule. Vous pourrez lire le contenu du fichier, mais pas y écrire. Le fichier doit avoir 
           été créé au préalable.

  - "w"  : écriture seule. Vous pourrez écrire dans le fichier, mais pas lire son contenu. Si le fichier 
           n'existe pas, il sera créé.

  - "a"  : mode d'ajout. Vous écrirez dans le fichier, en partant de la fin du fichier. Vous ajouterez donc du 
           texte à la fin du fichier. Si le fichier n'existe pas, il sera créé. Ce mode d'ajout peut être 
           utile si vous voulez seulement ajouter des informations à la fin du fichier.

  - "a+"  : ajout en lecture / écriture à la fin. Vous écrivez et lisez du texte à partir de la fin du 
            fichier. Si le fichier n'existe pas, il sera créé.

  - "r+"  : lecture et écriture. Vous pourrez lire et écrire dans le fichier. Le fichier doit avoir été créé 
            au préalable.

  - "w+"  : lecture et écriture, avec suppression du contenu au préalable. Le fichier est donc d'abord vidé de 
            son contenu, vous pouvez y écrire, et le lire ensuite. Si le fichier n'existe pas, il sera créé.


"r" (lecture), "w" (écriture) et "r+" (lecture et écriture) sont ceux que vous utiliserez le plus souvent.
Si vous avez juste l'intention de lire un fichier, il est conseillé de mettre "r"  . Certes, le mode "r+"  aurait fonctionné aussi, mais avec "r"  vous vous assurez que le fichier ne pourra pas être modifié, ce qui est en quelque sorte une sécurité.

Le mode "w+"  est un peu dangereux parce qu'il vide de suite le contenu du fichier, sans demande de confirmation.

Il ne doit être utilisé que si vous voulez d'abord réinitialiser le fichier.

Le code suivant ouvre le fichier test.txt en mode "r+"  (lecture et écriture) :

int main(int argc, char *argv[])
{
    FILE* fichier = NULL;

    fichier = fopen("test.txt", "r+");

    return 0;
}

Le pointeur fichier devient alors un pointeur sur test.txt  .

Où doit être situé test.txt  ?

Il doit être situé dans le même dossier que votre exécutable ( .exe  ). Pour les besoins de ce chapitre, créez un fichier test.txt dans le même dossier que le .exe :


Le fichier doit-il être de type .txt  ?

Non. C'est vous qui choisissez l'extension lorsque vous ouvrez le fichier. Vous pouvez très bien inventer votre propre format de fichier.

Le fichier doit-il être obligatoirement dans le même répertoire que l'exécutable ?

Non plus. Il peut être dans un sous-dossier :

  1.fichier = fopen("dossier/test.txt", "r+");

Ici, le fichier test.txt est dans un sous-dossier appelé dossier  . Cette méthode, que l'on appelle "chemin relatif", est plus pratique. Comme ça, cela fonctionnera, peu importe l'endroit où est installé votre programme.

Il est aussi possible d'ouvrir un autre fichier n'importe où ailleurs sur le disque dur. Dans ce cas, il faut écrire le chemin complet (ce qu'on appelle le "chemin absolu") :

  1.fichier = fopen("C:\\Program Files\\Notepad++\\readme.txt", "r+");

Ce code ouvre le fichier readme.txt situé dans C:\Program Files\Notepad++  .

Il faut mettre deux "antislashs" \  à chaque fois, comme vous l'avez remarqué.
S'il n'y en a qu'un, votre ordinateur pensera que vous essayez d'insérer un symbole spécial comme \n ou \t  .
Pour écrire un "antislash" dans une chaîne, il faut donc l'écrire deux fois : votre ordinateur comprend alors que c'est bien le symbole \  que vous vouliez utiliser.

Le défaut des chemins absolus, c'est qu'ils ne fonctionnent que sur un système d'exploitation précis. Ce n'est pas une solution portable, donc. Si vous aviez été sous Linux, vous auriez dû écrire un chemin "à la Linux", tel que :

  1.fichier = fopen("/home/mateo/dossier/readme.txt", "r+");

Je vous recommande donc d'utiliser des chemins relatifs plutôt que des chemins absolus. N'utilisez les chemins absolus que si votre programme est fait pour un système d'exploitation précis, et doit modifier un fichier précis quelque part sur votre disque dur.

Le pointeur fichier devrait contenir l'adresse de la structure de type FILE qui sert de descripteur de fichier. Celui-ci a été chargé en mémoire pour vous par la fonction fopen()  .

À partir de là, deux possibilités :

  1. Soit l'ouverture a réussi : vous pouvez commencer à lire et écrire dans le fichier via des fonctions que 
     je vais vous présenter dans la suite de ce chapitre.

  2. Soit l'ouverture a échoué parce que le fichier n'existait pas ou était utilisé par un autre programme : 
     vous devez arrêter de travailler sur le fichier.

Juste après l'ouverture du fichier, il faut impérativement vérifier si l'ouverture a réussi ou non. Pour faire ça, c'est très simple : si le pointeur vaut NULL  , l'ouverture a échoué. S'il vaut autre chose que NULL  , l'ouverture a réussi.

On va donc suivre systématiquement le schéma suivant :

int main(int argc, char *argv[])
{
    FILE* fichier = NULL;

    fichier = fopen("test.txt", "r+");

    if (fichier != NULL)
    {
        // On peut lire et écrire dans le fichier
    }
    else
    {
        // On affiche un message d'erreur si on veut
        printf("Impossible d'ouvrir le fichier test.txt");
    }

    return 0;
}

Faites toujours cela lorsque vous ouvrez un fichier. Si vous ne le faites pas et que le fichier n'existe pas, vous risquez un plantage du programme par la suite.

Quand vous avez terminé de travailler sur un fichier, n'oubliez pas de le fermer avec la fonction fclose  .


Fermez un fichier avec fclose

Si l'ouverture du fichier a réussi, vous pouvez le lire et y écrire (nous allons voir sous peu comment faire).
Une fois que vous aurez fini de travailler avec le fichier, il faudra le « fermer ». On utilise pour cela la fonction fclose  qui a pour rôle de libérer la mémoire, c'est-à-dire supprimer votre fichier chargé dans la mémoire vive.

Son prototype est :

  1.int fclose(FILE* pointeurSurFichier);

Cette fonction prend un paramètre : votre pointeur sur le fichier.
Elle renvoie un int  qui indique si elle a réussi à fermer le fichier. Ce int  vaut :

  - 0  : si la fermeture a marché ;

  - EOF  : si la fermeture a échoué. EOF  est un define  situé dans stdio.h  qui correspond à un nombre 
           spécial, utilisé pour dire soit qu'il y a eu une erreur, soit que nous sommes arrivés à la fin du 
           fichier. Dans le cas présent, cela signifie qu'il y a eu une erreur.

À priori, la fermeture se passe toujours bien : je n'ai donc pas l'habitude de tester si le fclose  a marché. Vous pouvez néanmoins le faire si vous le voulez.

Pour fermer le fichier, on va donc écrire :

  1.fclose(fichier);

Au final, le schéma que nous allons suivre pour ouvrir et fermer un fichier sera le suivant :


int main(int argc, char *argv[])
{
    FILE* fichier = NULL;

    fichier = fopen("test.txt", "r+");

    if (fichier != NULL)
    {
        // On lit et on écrit dans le fichier
        
        // ...
        
        fclose(fichier); // On ferme le fichier qui a été ouvert
    }

    return 0;
}


Je n'ai pas mis le else  ici pour afficher un message d'erreur si l'ouverture a échoué, mais vous pouvez le faire si vous le désirez.
Il faut toujours penser à fermer son fichier une fois que l'on a fini de travailler avec. Cela permet de libérer de la mémoire.
Si vous oubliez de libérer la mémoire, votre programme risque à la fin de prendre énormément de mémoire qu'il n'utilise plus. Sur un petit exemple comme ça ce n'est pas flagrant, mais sur un gros programme, bonjour les dégâts !

Oublier de libérer la mémoire, ça arrive. Ça vous arrivera d'ailleurs très certainement. Dans ce cas, vous serez témoin de ce que l'on appelle des fuites mémoire. Votre programme se mettra alors à utiliser plus de mémoire que nécessaire sans que vous arriviez à comprendre pourquoi. Bien souvent, il s'agit simplement d'un ou deux « détails », comme des petits fclose  oubliés.

Maintenant que nous avons écrit le code qui ouvre et ferme le fichier, nous n'avons plus qu'à insérer le code qui le lit et y écrit.

Nous allons commencer par voir comment écrire dans un fichier (ce qui est un peu plus simple), puis nous verrons ensuite comment lire dans un fichier.


Écrivez dans un fichier

Il existe plusieurs fonctions capables d'écrire dans un fichier. Ce sera à vous de choisir celle qui est la plus adaptée à votre cas.
Voici les trois fonctions que nous allons étudier :

  1. fputc écrit un caractère dans le fichier (UN SEUL caractère à la fois).

  2. fputs écrit une chaîne dans le fichier.

  3. fprintf écrit une chaîne formatée dans le fichier.


1. Écrivez un caractère dans le fichier avec fputc

Cette fonction écrit un caractère à la fois dans le fichier. Son prototype est :

  1.int fputc(int caractere, FILE* pointeurSurFichier);

Elle prend deux paramètres.

  - Le caractère à écrire (de type int  , ce qui comme je vous l'ai dit revient plus ou moins à utiliser un 
    char  , sauf que le nombre de caractères utilisables est ici plus grand). Vous pouvez donc écrire 
    directement 'A'  , par exemple.

  - Le pointeur sur le fichier dans lequel écrire. Dans notre exemple, notre pointeur s'appelle fichier  . 
    L'avantage de demander le pointeur de fichier à chaque fois, c'est que vous pouvez ouvrir plusieurs 
    fichiers en même temps, et donc lire et écrire dans chacun de ces fichiers. Vous n'êtes pas limité à un 
    seul fichier ouvert à la fois.

La fonction retourne un int, c'est un code d'erreur. Ce int vaut EOF si l'écriture a échoué, sinon il a une autre valeur.
Comme le fichier a normalement été ouvert avec succès, je n'ai pas l'habitude de tester si chacun de mes fputc a réussi, mais vous pouvez le faire encore une fois si vous le voulez.

Le code suivant écrit la lettre 'A' dans test.txt  (si le fichier existe, il est remplacé ; s'il n'existe pas, il est créé). Il y a tout dans ce code : ouverture, test de l'ouverture, écriture et fermeture.

int main(int argc, char *argv[])
{
    FILE* fichier = NULL;
 
    fichier = fopen("test.txt", "w");
 
    if (fichier != NULL)
    {
        fputc('A', fichier); // Écriture du caractère A
        fclose(fichier);
    }
 
    return 0;
}

Ouvrez votre fichier test.txt  .   Que voyez-vous ?
C'est magique, le fichier contient maintenant la lettre 'A' : 


2. Écrivez une chaîne dans le fichier avec fputs

Cette fonction est très similaire à fputc  , à la différence près qu'elle écrit tout une chaîne, ce qui est en général plus pratique que d'écrire caractère par caractère.
Cela dit, fputc reste utile lorsque vous devez écrire caractère par caractère, ce qui arrive fréquemment.

Prototype de la fonction :

  1.char* fputs(const char* chaine, FILE* pointeurSurFichier);

Les deux paramètres sont faciles à comprendre.

  - chaine  : la chaîne à écrire. Notez que le type ici est const char*  : en ajoutant le mot const dans le 
    prototype, la fonction indique que pour elle la chaîne sera considérée comme une constante. En un mot 
    comme en cent : elle s'interdit de modifier le contenu de votre chaîne. C'est logique quand on y pense : 
    fputs doit juste lire votre chaîne, pas la modifier. C'est donc pour vous une information (et une 
    sécurité) indiquant que votre chaîne ne subira pas de modification.

  - pointeurSurFichier  : comme pour fputc  , il s'agit de votre pointeur de type FILE* sur le fichier que 
    vous avez ouvert.

La fonction renvoie EOF s'il y a eu une erreur, sinon c'est que cela a fonctionné. Là non plus, je ne teste en général pas la valeur de retour.

Testons l'écriture d'une chaîne dans le fichier :

int main(int argc, char *argv[])
{
    FILE* fichier = NULL;
 
    fichier = fopen("test.txt", "w");
 
    if (fichier != NULL)
    {
        fputs("Salut les développeurs\nBienvenue sur OpenClassrooms !", fichier);
        fclose(fichier);
    }
 
    return 0;
}

Voici le fichier une fois modifié par le programme :


3. Écrivez une chaîne "formatée" dans le fichier avec fprintf

Voici un autre exemplaire de la fonction printf  . Celle-ci peut être utilisée pour écrire dans un fichier. Elle s'utilise de la même manière que printf  d'ailleurs, excepté le fait que vous devez indiquer un pointeur de FILE  en premier paramètre.

Ce code demande l'âge de l'utilisateur et l'écrit dans le fichier (résultat fig. suivante) :

int main(int argc, char *argv[])
{
    FILE* fichier = NULL;
    int age = 0;
 
    fichier = fopen("test.txt", "w");
 
    if (fichier != NULL)
    {
        // On demande l'âge
        printf("Quel age avez-vous ? ");
        scanf("%d", &age);
 
        // On l'écrit dans le fichier
        fprintf(fichier, "Le Monsieur qui utilise le programme, il a %d ans", age);
        fclose(fichier);
    }
 
    return 0;
}

Vous pouvez ainsi facilement réutiliser ce que vous savez de printf  pour écrire dans un fichier ! C'est pour cette raison d'ailleurs que j'utilise le plus souvent fprintf  pour écrire dans des fichiers.


Lisez dans un fichier

Nous pouvons utiliser quasiment les mêmes fonctions que pour l'écriture, le nom change juste un petit peu :

  1. fgetc lit un caractère.

  2. fgets lit une chaîne.

  3. fscanf lit une chaîne "formatée".

Je vais cette fois aller un peu plus vite dans l'explication de ces fonctions : si vous avez compris ce que j'ai écrit plus haut, ça ne devrait pas poser de problème.


1. Lisez un caractère avec fgetc

Tout d'abord le prototype :

  1.int fgetc(FILE* pointeurDeFichier);

Cette fonction retourne un int  : c'est le caractère qui a été lu.
Si la fonction n'a pas pu lire de caractère, elle retourne EOF  .

Mais comment savoir quel caractère on lit ? Si on veut lire le troisième caractère, ainsi que le dixième caractère, comment doit-on faire ?

En fait, au fur et à mesure que vous lisez un fichier, vous avez un « curseur » qui avance. C'est un curseur virtuel bien entendu, vous ne le voyez pas à l'écran. Vous pouvez imaginer que ce curseur est comme la barre clignotante lorsque vous éditez un fichier sous Bloc-Notes. Il indique où vous en êtes dans la lecture du fichier.

Nous verrons peu après comment savoir à quelle position le curseur est situé dans le fichier, et également comment modifier la position du curseur (pour le remettre au début du fichier par exemple, ou le placer à un caractère précis, comme le dixième caractère).

fgetc  avance le curseur d'un caractère à chaque fois que vous en lisez un. Si vous appelez fgetc  une seconde fois, la fonction lira donc le second caractère, puis le troisième et ainsi de suite. Vous pouvez donc faire une boucle pour lire les caractères un par un dans le fichier.

On va écrire un code qui lit tous les caractères d'un fichier un à un, et qui les écrit à chaque fois à l'écran. La boucle s'arrête quand fgetc  renvoie EOF  (qui signifie « End Of File », c'est-à-dire « fin du fichier »).

int main(int argc, char *argv[])
{
    FILE* fichier = NULL;
    int caractereActuel = 0;
 
    fichier = fopen("test.txt", "r");
 
    if (fichier != NULL)
    {
        // Boucle de lecture des caractères un à un
        do
        {
            caractereActuel = fgetc(fichier); // On lit le caractère
            printf("%c", caractereActuel); // On l'affiche
        } while (caractereActuel != EOF); // On continue tant que fgetc n'a pas retourné EOF (fin de fichier)
 
        fclose(fichier);
    }
 
    return 0;
}

La console affichera tout le contenu du fichier, par exemple :

Coucou, je suis le contenu du fichier test.txt !


2. Lisez une chaîne avec fgets

Cette fonction lit une chaîne dans le fichier. Ça vous évite d'avoir à lire tous les caractères un par un. La fonction lit au maximum une ligne (elle s'arrête au premier \n  qu'elle rencontre). Si vous voulez lire plusieurs lignes, il faudra faire une boucle.

Voici le prototype de fgets  :

  1.char* fgets(char* chaine, int nbreDeCaracteresALire, FILE* pointeurSurFichier);

Cette fonction demande un paramètre un peu particulier, qui va en fait s'avérer très pratique : le nombre de caractères à lire. Cela demande à la fonction fgets  de s'arrêter de lire la ligne si elle contient plus de X caractères.
Avantage : ça nous permet de nous assurer que l'on ne fera pas de dépassement de mémoire ! En effet, si la ligne est trop grosse pour rentrer dans chaine, la fonction aurait lu plus de caractères qu'il n'y a de place, ce qui aurait probablement provoqué un plantage du programme.

Nous allons d'abord voir comment lire une ligne avec fgets  (nous verrons ensuite comment lire tout le fichier).

Pour cela, on crée une chaîne suffisamment grande pour stocker le contenu de la ligne qu'on va lire (du moins on l'espère, car on ne peut pas en être sûr à 100 %). Vous allez voir là tout l'intérêt d'utiliser un define  pour définir la taille du tableau :


#define TAILLE_MAX 1000 // Tableau de taille 1000
 
int main(int argc, char *argv[])
{
    FILE* fichier = NULL;
    char chaine[TAILLE_MAX] = ""; // Chaîne vide de taille TAILLE_MAX
 
    fichier = fopen("test.txt", "r");
 
    if (fichier != NULL)
    {
        fgets(chaine, TAILLE_MAX, fichier); // On lit maximum TAILLE_MAX caractères du fichier, on stocke le tout dans "chaine"
        printf("%s", chaine); // On affiche la chaîne
 
        fclose(fichier);
    }
 
    return 0;
}

Le résultat est le même que pour le code de tout à l'heure, à savoir que le contenu s'écrit dans la console :

Coucou, je suis le contenu du fichier test.txt !

La différence, c'est qu'ici on ne fait pas de boucle. On affiche toute la chaîne d'un coup.
Vous aurez sûrement remarqué maintenant l'intérêt que peut avoir un #define  dans son code pour définir la taille maximale d'un tableau, par exemple. En effet, TAILLE_MAX  est ici utilisé à deux endroits du code :

  - une première fois pour définir la taille du tableau à créer ;

  - une autre fois dans le fgets  pour limiter le nombre de caractères à lire.

L'avantage ici, c'est que si vous vous rendez compte que la chaîne n'est pas assez grande pour lire le fichier, vous n'avez qu'à changer la ligne du define  et recompiler. Cela vous évite d'avoir à chercher tous les endroits du code qui indiquent la taille du tableau. Le préprocesseur remplacera tous les TAILLE_MAX  dans le code par leur nouvelle valeur.
Comme je vous l'ai dit, fgets  lit au maximum toute une ligne à la fois. Elle s'arrête de lire la ligne si elle dépasse le nombre maximum de caractères que vous autorisez.

Oui mais voilà : pour le moment, on ne sait lire qu'une seule ligne à la fois avec fgets  . Comment diable lire tout le fichier ? La réponse est simple : avec une boucle !

La fonction fgets  renvoie NULL  si elle n'est pas parvenue à lire ce que vous avez demandé.
La boucle doit donc s'arrêter dès que fgets  se met à renvoyer NULL  .

On n'a plus qu'à faire un while  pour boucler tant que fgets  ne renvoie pas NULL  :


#define TAILLE_MAX 1000
 
int main(int argc, char *argv[])
{
    FILE* fichier = NULL;
    char chaine[TAILLE_MAX] = "";
 
    fichier = fopen("test.txt", "r");
 
    if (fichier != NULL)
    {
        while (fgets(chaine, TAILLE_MAX, fichier) != NULL) // On lit le fichier tant qu'on ne reçoit pas d'erreur (NULL)
        {
            printf("%s", chaine); // On affiche la chaîne qu'on vient de lire
        }
 
        fclose(fichier);
    }
 
    return 0;
}

Ce code source lit et affiche tout le contenu de mon fichier, ligne par ligne.

La ligne de code la plus intéressante est celle du while  :

  1.while (fgets(chaine, TAILLE_MAX, fichier) != NULL)

La ligne du while  fait deux choses : elle lit une ligne dans le fichier et vérifie si fgets  ne renvoie pas NULL  . Elle peut donc se traduire comme ceci : « Lire une ligne du fichier tant que nous ne sommes pas arrivés à la fin du fichier ».


3. Lisez une chaîne "formatée" avec fscanf

C'est le même principe que la fonction scanf  , là encore.
Cette fonction lit dans un fichier qui doit avoir été écrit d'une manière précise.
Supposons que votre fichier contienne trois nombres séparés par un espace, qui sont par exemple les trois plus hauts scores obtenus à votre jeu :  15 20 30  .
Vous voudriez récupérer chacun de ces nombres dans une variable de type int  .
La fonction fscanf  va vous permettre de faire ça rapidement.


int main(int argc, char *argv[])
{
    FILE* fichier = NULL;
    int score[3] = {0}; // Tableau des 3 meilleurs scores
 
    fichier = fopen("test.txt", "r");
 
    if (fichier != NULL)
    {
        fscanf(fichier, "%d %d %d", &score[0], &score[1], &score[2]);
        printf("Les meilleurs scores sont : %d, %d et %d", score[0], score[1], score[2]);
 
        fclose(fichier);
    }
 
    return 0;
}

Les meilleurs scores sont : 15, 20 et 30

Comme vous le voyez, la fonction fscanf  attend trois nombres séparés par un espace ( "%d %d %d"  ). Elle les stocke ici dans notre tableau de trois blocs.

On affiche ensuite chacun des nombres récupérés.

Jusqu'ici, je ne vous avais fait mettre qu'un seul %d  entre guillemets pour la fonction scanf  . Vous découvrez aujourd'hui qu'on peut en mettre plusieurs, les combiner. Si votre fichier est écrit d'une façon bien précise, cela permet d'aller plus vite pour récupérer chacune des valeurs.


Déplacez-vous dans un fichier

Je vous ai parlé d'une espèce de « curseur » virtuel tout à l'heure. Nous allons l'étudier maintenant plus en détail.
Chaque fois que vous ouvrez un fichier, il existe en effet un curseur qui indique votre position dans le fichier. Vous pouvez imaginer que c'est exactement comme le curseur de votre éditeur de texte (tel Bloc-Notes). Il indique où vous êtes dans le fichier, et donc où vous allez écrire.
En résumé, le système de curseur vous permet d'aller lire et écrire à une position précise dans le fichier.

Il existe trois fonctions à connaître :

  1. ftell indique à quelle position vous êtes actuellement dans le fichier.

  2. fseek positionne le curseur à un endroit précis.

  3. rewind remet le curseur au début du fichier (c'est équivalent à demander à la fonction fseek de 
     positionner le curseur au début).


1. Situez-vous dans un fichier avec ftell

Cette fonction est très simple à utiliser. Elle renvoie la position actuelle du curseur sous la forme d'un long  :

  1.long ftell(FILE* pointeurSurFichier);

Le nombre renvoyé indique donc la position du curseur dans le fichier.


2. Positionnez le curseur dans un fichier avec fseek

Le prototype de fseek  est le suivant :

  1.int fseek(FILE* pointeurSurFichier, long deplacement, int origine);

La fonction fseek  permet de déplacer le curseur d'un certain nombre de caractères (indiqué par deplacement  ) à partir de la position indiquée par origine  .

  - Le nombre deplacement  peut être un nombre positif (pour se déplacer en avant), nul (= 0) ou négatif (pour 
    se déplacer en arrière).

  - Quant au nombre origine  , vous pouvez mettre comme valeur l'une des trois constantes (généralement des 
    define  ) listées ci-dessous :

      - SEEK_SET  : indique le début du fichier ;

      - SEEK_CUR  : indique la position actuelle du curseur ;

      - SEEK_END  : indique la fin du fichier.

Voici quelques exemples pour bien comprendre comment on jongle avec deplacement  et origine  .

  - Le code suivant place le curseur deux caractères après le début :

  1.fseek(fichier, 2, SEEK_SET);

  - Le code suivant place le curseur quatre caractères avant la position courante :

  1.fseek(fichier, -4, SEEK_CUR);

Remarquez que deplacement  est négatif car on se déplace en arrière.

  - Le code suivant place le curseur à la fin du fichier :

  1.fseek(fichier, 0, SEEK_END);

Si vous écrivez après avoir fait un fseek  qui mène à la fin du fichier, cela ajoutera vos informations à la suite dans le fichier (le fichier sera complété).
En revanche, si vous placez le curseur au début et que vous écrivez, cela écrasera le texte qui se trouvait là. Il n'y a pas de moyen d'« insérer » de texte dans le fichier, à moins de coder soi-même une fonction qui lit les caractères d'après pour s'en souvenir avant de les écraser !

Mais comment puis-je savoir à quelle position je dois aller lire et écrire dans le fichier ?

C'est à vous de le gérer. Si c'est un fichier que vous avez vous-même écrit, vous savez comment il est construit. Vous savez donc où aller chercher vos informations : par exemple les meilleurs scores sont en position 0, les noms des derniers joueurs sont en position 50, etc.

Nous travaillerons sur un TP un peu plus tard dans lequel vous comprendrez, si ce n'est pas déjà le cas, comment on fait pour aller chercher l'information qui nous intéresse. N'oubliez pas que c'est vous qui définissez comment votre fichier est construit. C'est donc à vous de dire : « Je place le score du meilleur joueur sur la première ligne, celui du second meilleur joueur sur la seconde ligne, etc. »

La fonction fseek  peut se comporter bizarrement sur des fichiers ouverts en mode texte. En général, on l'utilise plutôt pour se déplacer dans des fichiers ouverts en mode binaire.
Quand on lit et écrit dans un fichier en mode texte, on le fait généralement caractère par caractère. La seule chose qu'on se permet en mode texte avec fseek  , c'est de revenir au début ou de se placer à la fin.


3. Replacez le curseur au début du fichier avec rewind

Cette fonction est équivalente à utiliser fseek  pour nous renvoyer à la position 0 dans le fichier.

  1.void rewind(FILE* pointeurSurFichier);

Nous terminerons ce chapitre en douceur par l'étude de deux fonctions très simples :

  - rename renomme un fichier ;

  - remove  supprime un fichier.

La particularité de ces fonctions est qu'elles ne nécessitent pas de pointeur de fichier pour fonctionner. Il suffira simplement d'indiquer le nom du fichier à renommer ou supprimer.


Renommez un fichier avec rename

Voici le prototype de cette fonction :

  1.int rename(const char* ancienNom, const char* nouveauNom);

La fonction renvoie 0 si elle a réussi à renommer, sinon elle renvoie une valeur différente de 0 :


int main(int argc, char *argv[])
{
    rename("test.txt", "test_renomme.txt");

    return 0;
}


Supprimez un fichier avec remove

Cette fonction supprime un fichier sans demander son reste :

  1.int remove(const char* fichierASupprimer);

Cette fonction supprime le fichier indiqué sans demander de confirmation : le fichier n'est pas mis dans la corbeille, il est littéralement supprimé du disque dur.

Il n'est pas possible de récupérer un fichier supprimé (à moins de faire appel à des outils spécifiques de récupération de fichiers sur le disque, mais l'opération peut être longue, complexe, et ne pas aboutir).

Cette fonction tombe à pic pour la fin du chapitre, je n'ai justement plus besoin du fichier test.txt  , je peux donc me permettre de le supprimer :

int main(int argc, char *argv[])
{
    remove("test.txt");

    return 0;
}


En résumé

  - La bibliothèque standard fournit des fonctions pour pouvoir manipuler les fichiers ; cependant, il ne faut 
    pas oublier d’inclure les bibliothèques stdio.h et stdlib.h .

  - La fonction fopen permet d’ouvrir un fichier. Il faut préciser en paramètre le chemin vers le fichier, et 
    indiquer le mode d'ouverture pour travailler sur le fichier selon votre besoin.

  - Les fonctions fputc ,  fputs et fprintf permettent d’écrire dans un fichier.

  - Pour lire dans un fichier, il faut utiliser les fonctions fgetc ,  fgets et  fscanf .

  - Toujours fermer le fichier à l’aide de la fonction fclose après avoir terminé les manipulations sur 
    celui-ci.

Je ne sais pas si vous vous souvenez, mais dans le chapitre des tableaux, je vous ai vaguement parlé d’allocation dynamique. Surprise ! Il est maintenant temps de découvrir cette notion. Rendez-vous au prochain chapitre...

##############################################################################################################

Créez des variables grâce à l'allocation dynamique

Il est impératif de bien savoir manipuler les pointeurs pour pouvoir suivre ce chapitre !
Si vous avez encore des doutes, je vous recommande d'aller refaire un tour sur le chapitre des pointeurs.

Quand on déclare une variable, on dit qu'on demande à allouer de la mémoire :

  1.int monNombre = 0;

Lorsque le programme arrive à une ligne comme celle-ci, il se passe en fait les choses suivantes :

  1. Votre programme demande au système d'exploitation (Windows, Linux, Mac OS…) la permission d'utiliser un 
     peu de mémoire.

  2. Le système d'exploitation répond à votre programme en lui indiquant où il peut stocker cette variable (il 
     lui donne l'adresse qu'il lui a réservée).

  3. Lorsque la fonction est terminée, la variable est automatiquement supprimée de la mémoire. Votre 
     programme dit au système d'exploitation : "Je n'ai plus besoin de l'espace en mémoire que tu m'avais 
     réservé à telle adresse".


Trouvez la taille d'une variable en fonction de son type

Selon le type de variable que vous demandez de créer, vous avez besoin de plus ou moins de mémoire. Le problème, c'est que l'espace pris en mémoire dépend des machines : peut-être que chez vous un int occupe 8 octets, qui sait ?

Pour vérifier quelle taille occupe chacun des types sur votre ordinateur, nous allons utiliser l'opérateur sizeof().

Contrairement aux apparences, ce n'est pas une fonction, mais une fonctionnalité de base du langage C. Vous devez juste indiquer entre parenthèses le type que vous voulez analyser.

Pour connaître la taille d'un int  , on écrit :

  1.sizeof(int)

À la compilation, cela sera remplacé par un nombre : le nombre d'octets que prend int en mémoire. Testez pour voir, en affichant la valeur à l'aide d'un printf  , par exemple :

  1.printf("char : %d octets\n", sizeof(char));
  2.printf("int : %d octets\n", sizeof(int));
  3.printf("long : %d octets\n", sizeof(long));
  4.printf("double : %d octets\n", sizeof(double));

Avoir des types différents était utile à une époque où l'on n'avait pas beaucoup de mémoire dans nos ordinateurs : on utilisait le minimum de mémoire possible via le type le plus adapté.

Aujourd'hui, cela ne sert plus vraiment, car la mémoire d'un ordinateur est très grande.

Cela dit, cela a encore un intérêt si vous créez des programmes pour de l'informatique embarquée (pour des Smartphones, par exemple) où la mémoire disponible est plus faible.

Peut-on afficher la taille d'un type personnalisé qu'on a créé (une structure) ?

Oui ! sizeof marche aussi sur les structures :


typedef struct Coordonnees Coordonnees;
struct Coordonnees
{
    int x;
    int y;
};

int main(int argc, char *argv[])
{
    printf("Coordonnees : %d octets\n", sizeof(Coordonnees));

    return 0;
}


Coordonnees : 8 octets

Plus une structure contient de sous-variables, plus elle prend de mémoire. 

Revenons à nos moutons : si on déclare une variable de type int  :

  1.int nombre = 18;

… et que sizeof(int) indique 4 octets sur notre ordinateur, alors la variable occupera 4 octets en mémoire !
Supposons que la variable nombre soit allouée à l'adresse 1600 en mémoire. On aurait alors :

Adresse          Valeur

1599              ...
1600
1601
1602              18
1603
1604              ...


Notre variable nombre de type int qui vaut 18 occupe 4 octets dans la mémoire. Elle commence à l'adresse 1600 et termine à l'adresse 1603. La prochaine variable ne pourra donc être stockée qu'à partir de l'adresse 1604 !

Si on avait fait la même chose avec un char  , on n'aurait occupé qu'un seul octet en mémoire :

Adresse          Valeur

1599              ...
1600              18 
1601              ...
1602              ...
1603              ...
1604              ...


Imaginez maintenant un tableau de int  ! Chaque case du tableau occupera 4 octets.

Si notre tableau fait 100 cases :

  1.int tableau[100];

… on occupera alors en réalité 4 * 100 = 400 octets en mémoire.

Même si le tableau est vide, il prend 400 octets ?

Bien sûr ! La place en mémoire est réservée : aucun autre programme n'a le droit d'y toucher (à part le vôtre). Une fois qu'une variable est déclarée, elle prend immédiatement de la place en mémoire.

Notez que si on crée un tableau de type Coordonnees  :

  1.Coordonnees tableau[100];

… on utilisera cette fois : 8 * 100 = 800 octets en mémoire.

Il est important de bien comprendre ces petits calculs pour la suite du chapitre.


Allouez manuellement de la mémoire au système

Commencez par inclure la bibliothèque <stdlib.h>  .  Elle contient deux fonctions dont nous allons avoir besoin :

  1. malloc  (pour "Memory Allocation" ou allocation de mémoire, en français) : elle demande au système 
     d'exploitation la permission d'utiliser de la mémoire.

  2. free  (libérer, en français) : elle indique au système que l'on n'a plus besoin de la mémoire qu'on avait 
     demandée. La place en mémoire est libérée, un autre programme peut maintenant s'en servir au besoin.

Pour faire une allocation manuelle de mémoire, vous devez toujours suivre ces trois étapes :

  1. Appeler malloc pour demander de la mémoire.

  2. Vérifier la valeur retournée par malloc pour savoir si le système a bien réussi à allouer la mémoire.

  3. Libérer la mémoire avec free une fois qu'on a fini d'utiliser la mémoire. Si on ne le fait pas, on 
     s'expose à des fuites de mémoire, c'est-à-dire que votre programme risque de prendre beaucoup de mémoire 
     alors qu'il n'a en réalité plus besoin de tout cet espace.

Ces trois étapes vous rappellent-elles le chapitre sur les fichiers ? Elles devraient ! Le principe est exactement le même : on alloue, on vérifie si l'allocation a marché, on utilise la mémoire, puis on la libère quand on a fini de l'utiliser.


Étape 1 : Demandez une allocation de mémoire avec malloc

Voici le prototype de la fonction malloc :

  1.void* malloc(size_t nombreOctetsNecessaires);

La fonction prend en paramètre le nombre d'octets à réserver. Il suffit donc d'écrire sizeof(int)  dans ce paramètre pour réserver suffisamment d'espace pour stocker un int  .
Mais regardez ce que la fonction renvoie : un void*  !
Dans le chapitre sur les fonctions, je vous avais dit que void signifiait "vide", et qu'on utilisait ce type pour indiquer que la fonction ne retournait aucune valeur. Alors ici, on aurait une fonction qui retourne un "pointeur sur vide" ?
En fait, cette fonction renvoie un pointeur indiquant l'adresse que le système a réservée pour votre variable. Si le système a trouvé de la place pour vous à l'adresse 1600, la fonction renvoie donc un pointeur contenant l'adresse 1600.
Le problème, c'est que la fonction malloc ne sait pas quel type de variable vous cherchez à créer puisque vous ne lui donnez qu'un paramètre : le nombre d'octets en mémoire dont vous avez besoin. Si vous demandez 4 octets, ça pourrait aussi bien être un int qu'un long   , par exemple.

Comme malloc ne sait pas quel type elle doit retourner, elle renvoie le type void*  . Ce sera un pointeur sur n'importe quel type.
On peut dire que c'est un pointeur universel.

Passons à la pratique : si je veux créer manuellement une variable de type int en mémoire, je devrai indiquer à malloc que j'ai besoin de sizeof(int) octets en mémoire. Je récupère le résultat du malloc dans un pointeur sur int  :

  1.int* memoireAllouee = NULL; // On crée un pointeur sur int
  2.
  3.memoireAllouee = malloc(sizeof(int)); // La fonction malloc inscrit dans notre pointeur l'adresse qui a 
    été reservée.


memoireAllouee est un pointeur contenant une adresse qui vous a été réservée par le système, par exemple l'adresse 1600 pour reprendre mes schémas précédents.


Étape 2 : Testez le pointeur pour vérifier la valeur retournée par malloc

La fonction malloc a donc renvoyé dans notre pointeur memoireAllouee l'adresse qui a été réservée pour vous en mémoire. Deux possibilités :

  1. Si l'allocation a marché, notre pointeur contient une adresse.

  2. Si l'allocation a échoué, notre pointeur contient l'adresseNULL  .

Il est peu probable qu'une allocation échoue, mais ça peut arriver : si vous demandez à utiliser 34 Go de mémoire vive, il y a peu de chances que le système vous réponde favorablement.

Il est néanmoins recommandé de toujours tester si l'allocation a marché.

Si l'allocation a échoué, c'est qu'il n'y avait plus de mémoire de libre (c'est un cas critique). Dans un tel cas, le mieux est d'arrêter immédiatement le programme parce que, de toute manière, il ne pourra pas continuer convenablement.

La fonction exit() arrête immédiatement un programme. Elle prend en paramètre la valeur que le programme doit retourner.

Cela correspond en fait au return du main()  .


int main(int argc, char *argv[])
{
    int* memoireAllouee = NULL;

    memoireAllouee = malloc(sizeof(int));
    if (memoireAllouee == NULL) // Si l'allocation a échoué
    {
        exit(0); // On arrête immédiatement le programme
    }

    // On peut continuer le programme normalement sinon

    return 0;
}

Si le pointeur est différent de NULL  , le programme peut continuer, sinon il faut afficher un message d'erreur, ou même mettre fin au programme.


Étape 3 : Libérez de la mémoire avec free

Tout comme on utilisait la fonction fclose pour fermer un fichier dont on n'avait plus besoin, on va utiliser la fonction free pour libérer la mémoire dont on ne se sert plus.

  1.void free(void* pointeur);

La fonction free a juste besoin de l'adresse mémoire à libérer. On va donc lui envoyer notre pointeur : memoireAllouee dans notre exemple :


int main(int argc, char *argv[])
{
    int* memoireAllouee = NULL;

    memoireAllouee = malloc(sizeof(int));
    if (memoireAllouee == NULL) // On vérifie si la mémoire a été allouée
    {
        exit(0); // Erreur : on arrête tout !
    }

    // On peut utiliser ici la mémoire
    free(memoireAllouee); // On n'a plus besoin de la mémoire, on la libère

    return 0;
}


Analysez un exemple concret d'utilisation

On va programmer quelque chose qu'on a appris à faire il y a longtemps : demander l'âge de l'utilisateur et le lui afficher. La seule différence avec ce qu'on faisait avant, c'est qu'ici la variable va être allouée manuellement :


int main(int argc, char *argv[])
{
    int* memoireAllouee = NULL;

    memoireAllouee = malloc(sizeof(int)); // Allocation de la mémoire
    if (memoireAllouee == NULL)
    {
        exit(0);
    }

    // Utilisation de la mémoire
    printf("Quel age avez-vous ? ");
    scanf("%d", memoireAllouee);
    printf("Vous avez %d ans\n", *memoireAllouee);

    free(memoireAllouee); // Libération de mémoire

    return 0;
}

Quel age avez-vous ? 31
Vous avez 31 ans


memoireAllouee  est un pointeur : on ne l'utilise pas de la même manière qu'une vraie variable.

  - Pour obtenir la valeur de la variable, il faut placer une étoile devant :*memoireAllouee (regardez le 
    printf  ).

  - Pour indiquer l'adresse, on a juste besoin d'écrire le nom du pointeur  :memoireAllouee (regardez le 
    scanf  ).

On a déjà vu ça dans le chapitre sur les pointeurs, mais il est probable que vous confondiez encore. Faites-y attention. 🤓

Bref : on y a alloué dynamiquement une variable de type int  .
Ce qu'on a écrit revient finalement au même que d'utiliser la méthode automatique :


int main(int argc, char *argv[])
{
    int maVariable = 0; // Allocation de la mémoire (automatique)

    // Utilisation de la mémoire
    printf("Quel age avez-vous ? ");
    scanf("%d", &maVariable);
    printf("Vous avez %d ans\n", maVariable);

    return 0;
} // Libération de la mémoire (automatique à la fin de la fonction)

Quel age avez-vous ? 31
Vous avez 31 ans

Dans cette vidéo, revenons sur ce qu'on vient de voir pour créer une variable grâce à l’allocation dynamique :

En résumé, il y a deux façons de créer une variable, c'est-à-dire d'allouer de la mémoire :

  1. Automatiquement : c'est la méthode que vous connaissez et qu'on a utilisée jusqu'ici.

  2. Manuellement : c'est la méthode que je vous enseigne dans ce chapitre.

Je trouve la méthode dynamique un peu compliquée et inutile, j'ai tort ?

Un peu plus compliquée… certes. Mais inutile, non ! Nous sommes parfois obligés d'allouer manuellement de la mémoire, comme nous allons le voir maintenant.


Créez un tableau dont la taille n'est connue qu'à l'exécution


Pour le moment, on a utilisé l'allocation dynamique uniquement pour créer une petite variable. Or en général, on ne se sert pas de l'allocation dynamique pour cela. On utilise la méthode automatique qui est plus simple.

Quand a-t-on besoin de l'allocation dynamique, alors ?

Le plus souvent, on s'en sert pour créer un tableau dont on ne connaît pas la taille avant l'exécution du programme.

Imaginons par exemple un programme qui stocke l'âge de tous les amis de l'utilisateur dans un tableau. Vous pourriez créer un tableau de int pour stocker les âges, comme ceci :

  1.int ageAmis[15];

Mais qui vous dit que l'utilisateur a 15 amis ? Peut-être qu'il en a plus que ça !

Lorsque vous écrivez le code source, vous ne connaissez pas la taille que vous devez donner à votre tableau. Vous ne le saurez qu'à l'exécution, lorsque vous demanderez à l'utilisateur combien il a d'amis.

L'intérêt de l'allocation dynamique est là : on va demander le nombre d'amis à l'utilisateur, puis on fera une allocation dynamique pour créer un tableau ayant exactement la taille nécessaire (ni trop petit, ni trop grand). Si l'utilisateur a 15 amis, on créera un tableau de 15 int  ; s'il en a 28, on créera un tableau de 28 int  , etc.

Comme je vous l'ai appris, il est interdit en C de créer un tableau en indiquant sa taille à l'aide d'une variable :

  1.int amis[nombreDAmis];

Ce code fonctionne peut-être sur certains compilateurs, mais uniquement dans des cas précis, il est recommandé de ne pas l'utiliser !

L'allocation dynamique permet de créer un tableau qui a exactement la taille de la variable nombreDAmis   , et cela grâce à un code qui fonctionnera partout !

Demandons au malloc de nous réserver nombreDAmis * sizeof(int)  octets en mémoire :

  1.amis = malloc(nombreDAmis * sizeof(int));

Ce code permet de créer un tableau de type int qui a une taille correspondant exactement au nombre d'amis !
Voici ce que fait le programme dans l'ordre :

  1. Il demande à l'utilisateur combien il a d'amis.

  2. Il crée un tableau de int ayant une taille égale à son nombre d'amis (via malloc  ).

  3. Il demande l'âge de chacun de ses amis un à un, qu'on stocke dans le tableau.

  4. Il affiche l'âge des amis pour montrer qu'on a bien mémorisé tout cela.

  5. À la fin, puisqu'on n'a plus besoin du tableau contenant l'âge des amis, il le libère avec la fonction 
     free  .


int main(int argc, char *argv[])
{
    int nombreDAmis = 0, i = 0;
    int* ageAmis = NULL; // Ce pointeur va servir de tableau après l'appel du malloc

    // On demande le nombre d'amis à l'utilisateur
    printf("Combien d'amis avez-vous ? ");
    scanf("%d", &nombreDAmis);

    if (nombreDAmis > 0) // Il faut qu'il ait au moins un ami (je le plains un peu sinon :p)
    {
        ageAmis = malloc(nombreDAmis * sizeof(int)); // On alloue de la mémoire pour le tableau
        if (ageAmis == NULL) // On vérifie si l'allocation a marché ou non
        {
            exit(0); // On arrête tout
        }

        // On demande l'âge des amis un à un
        for (i = 0 ; i < nombreDAmis ; i++)
        {
            printf("Quel age a l'ami numero %d ? ", i + 1);
            scanf("%d", &ageAmis[i]);
        }

        // On affiche les âges stockés un à un
        printf("\n\nVos amis ont les ages suivants :\n");
        for (i = 0 ; i < nombreDAmis ; i++)
        {
            printf("%d ans\n", ageAmis[i]);
        }

        // On libère la mémoire allouée avec malloc, on n'en a plus besoin
        free(ageAmis);
    }

    return 0;
}

Combien d'amis avez-vous ? 5
Quel age a l'ami numero 1 ? 16
Quel age a l'ami numero 2 ? 18
Quel age a l'ami numero 3 ? 20
Quel age a l'ami numero 4 ? 26
Quel age a l'ami numero 5 ? 27

Vos amis ont les ages suivants :
16 ans
18 ans
20 ans
26 ans
27 ans


J'ai choisi cet exemple parce qu'il est simple. Dans la suite du cours, nous aurons l'occasion d'utiliser le malloc pour des choses bien plus intéressantes que le stockage de l'âge de ses amis.

En résumé