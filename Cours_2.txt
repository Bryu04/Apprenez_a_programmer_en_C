                     Partie 2 :Organisez votre code gr√¢ce aux conditions, boucles et fonctions


Structurez votre code avec les conditions

Nous avons vu comment cr√©er des variables, nous allons maintenant nous int√©resser aux conditions. Elles permettent de tester des variables. Sans conditions, nos programmes informatiques feraient toujours la m√™me chose !

Utilisez des conditions if... else

On peut par exemple dire :

"si la variable machin est √©gale √† 50, fais ceci."

Mais ce serait dommage de ne pouvoir tester que l'√©galit√© ! Il faudrait aussi pouvoir tester si la variable est inf√©rieure √† 50, inf√©rieure ou √©gale √† 50, sup√©rieure, sup√©rieure ou √©gale‚Ä¶ Ne vous inqui√©tez pas, le C a tout pr√©vu !

Avant de voir comment on √©crit une condition de type if... else  en C, il faut donc que vous connaissiez les symboles de base. Voici un tableau r√©capitulatif √† conna√Ætre par c≈ìur :

Symbole          Signification

==               est √©gal √†

>                est sup√©rieur √†

<                est inf√©rieur √†

>=               est sup√©rieur ou √©gal √†

<=               est inf√©rieur ou √©gal √†

!=               est diff√©rent de

Il y a bien deux symboles ==  pour tester l'√©galit√©. Une erreur courante que font les d√©butants est de ne mettre qu'un symbole =  , ce qui n'a pas la m√™me signification en C. 

Ouvrez une condition avec un if 

Nous allons faire un test simple, qui va dire √† l'ordinateur :

"SI la variable vaut √ßa, ALORS fais ceci".

En anglais, le mot "si" se traduit par if.

On l'utilise en langage C pour introduire une condition.

  1. Commencez par √©crire if.

  2. Ouvrez des parenth√®ses (√† l'int√©rieur de ces parenth√®ses on √©crit une condition).

  3. Ouvrez une accolade {  et fermez-la un peu plus loin}. Tout ce qui se trouve √† l'int√©rieur des accolades 
     sera ex√©cut√© uniquement si la condition est v√©rifi√©e.

Cela nous donne :

if (/* Votre condition */)
{
  // Instructions √† ex√©cuter si la condition est vraie
}

√Ä la place de mon commentaire "Votre condition", on va √©crire une condition pour tester une variable. Pour s'entra√Æner, on va tester si vous √™tes majeur avec une variable  age  , c'est-√†-dire "vous √™tes majeur si votre √¢ge est sup√©rieur ou √©gal √† 18" :

if (age >= 18)
{
  printf ("Vous etes majeur !");
}

Rappel : le symbole >=  signifie ¬´ sup√©rieur ou √©gal ¬ª.

S'il n'y a qu'une instruction entre les accolades (comme c'est le cas ici), alors celles-ci deviennent facultatives. Je recommande n√©anmoins de toujours mettre des accolades pour des raisons de clart√©.

Si vous voulez tester les codes pr√©c√©dents pour voir comment le if fonctionne, il faudra placer le if √† l'int√©rieur d'une fonction main  , et ne pas oublier de d√©clarer une variable age √† laquelle on donnera la valeur de notre choix :

#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
    int age = 20;
  
    if (age >= 18)
    {
      printf ("Vous etes majeur !\n");
    }
     
    return 0;
}

Ici, la variable age vaut 20, donc le "Vous √™tes majeur !" s'affichera.

Essayez de changer la valeur initiale de la variable pour voir. Mettez par exemple 15 : la condition sera fausse, et donc "Vous √™tes majeur !" ne s'affichera pas cette fois.

Ex√©cutez une instruction alternative avec else 

Maintenant, allons plus loin : si le test n'a pas march√© (il est faux), on va dire √† l'ordinateur d'ex√©cuter d'autres instructions.

En fran√ßais, nous allons donc √©crire quelque chose qui ressemble √† :

"SI la variable vaut √ßa, ALORS fais ceci,

SINON fais cela".

Il suffit de rajouter else apr√®s l'accolade fermante du if :

if (age >= 18) // Si l'√¢ge est sup√©rieur ou √©gal √† 18
{
  printf ("Vous etes majeur !");
}
else // Sinon...
{
  printf ("Ah c'est bete, vous etes mineur !");
}

Si la variable age est sup√©rieure ou √©gale √† 18, on affiche le message "Vous √™tes majeur !", sinon on affiche "Vous √™tes mineur".

Conditionnez l'instruction alternative avec else if 

Il est possible de faire un autre test si le premier test n'a pas march√©.  On demande alors √† l'ordinateur :

"SI la variable vaut √ßa ALORS fais ceci,

SINON SI la variable vaut √ßa ALORS fais √ßa,

SINON fais cela".

else if  ( ou "sinon si") se place entre le if et le else :

if (age >= 18) // Si l'√¢ge est sup√©rieur ou √©gal √† 18
{
  printf ("Vous etes majeur !");
}
else if ( age > 4 ) // Sinon, si l'√¢ge est au moins sup√©rieur √† 4 
{
  printf ("Bon t'es pas trop jeune quand meme...");
}
else // Sinon...
{
  printf ("Aga gaa aga gaaa"); // Langage b√©b√©, vous pouvez pas comprendre
}

L'ordinateur fait les tests dans l'ordre :

  1. D'abord il teste le premier if: si la condition est vraie, alors il ex√©cute ce qui se trouve entre les 
     premi√®res accolades.

  2. Sinon, il va au ¬´ sinon si ¬ª et fait √† nouveau un test : si ce test est vrai, alors il ex√©cute les 
     instructions correspondantes entre accolades.

  3. Enfin, si aucun des tests pr√©c√©dents n'a march√©, il ex√©cute les instructions du ¬´ sinon ¬ª.

Notez que l'on peut mettre autant de else if que l'on veut.

On peut donc √©crire :

SI la variable vaut √ßa,
ALORS fais ceci,
SINON SI la variable vaut √ßa ALORS fais √ßa,
SINON SI la variable vaut √ßa ALORS fais √ßa,
SINON SI la variable vaut √ßa ALORS fais √ßa,
SINON fais cela.

Vous avez encore quelques doutes sur l‚Äôutilisation du if, else if et else ? Pas de panique, dans la vid√©o suivante, nous revoit tout, √©tape par √©tape :

Testez plusieurs conditions √† la fois

Il peut aussi √™tre utile de faire plusieurs tests √† la fois dans votre if.

Pour cela, il va falloir utiliser de nouveaux symboles :

Symbole    Signification

&&           ET

||           OU

!            NON

Ajoutez une contrainte "ET" avec  &&

On peut vouloir tester si l'√¢ge est sup√©rieur √† 18 ET si l'√¢ge est inf√©rieur √† 25.

Pour cela, il vous faudra √©crire :

  1.if (age > 18 && age < 25)

Ajoutez une contrainte "OU" avec  ||

Ce signe n'est pas facilement accessible sur nos claviers. Sur un clavier AZERTY fran√ßais, il faudra faire Alt Gr + 6 ; sur un clavier belge, Alt Gr + &.

Imaginons un programme qui d√©cide si une personne a le droit d'ouvrir un compte en banque. Pour ouvrir un compte en banque, il vaut mieux ne pas √™tre trop jeune, ou bien avoir beaucoup d'argent. Notre test pourrait √™tre :

if (age > 30 || argent > 100000)
{
    printf("Bienvenue chez PicsouBanque !");
}
else
{
    printf("Hors de ma vue, miserable !");
}

Ce test n'est valide que si la personne a plus de 30 ans ou si elle poss√®de plus de 100 000 euros !

Testez l'oppos√©e d'une condition avec  !

En informatique, le point d'exclamation signifie ¬´ non ¬ª.

Vous devez mettre ce signe avant votre condition pour dire ¬´ si cela n'est pas vrai ¬ª :

  1.if (!(age < 18))

Cela pourrait se traduire par ¬´ si la personne n'est pas mineure ¬ª.

Si on avait enlev√© le !  devant, cela aurait signifi√© l'inverse : ¬´ si la personne est mineure ¬ª.

Et puisqu'on y est, je voudrais vous lister quelques erreurs courantes du d√©butant.

√âvitez de faire ces erreurs

Oublier les deux signes  ==
Pour tester si la personne a tout juste 18 ans, il faut √©crire if (age == 18) avec  ==  .
Si vous ne mettez qu'un seul =, alors votre variable prendra la valeur 18. Ce qu'on veut faire ici, c'est tester la valeur de la variable, non pas la changer. Faites tr√®s attention √† cela !

Terminer une condition avec un  ;
Un if est une condition. On met un  ;  √† la fin d'une instruction, pas d'une condition.

Faites des conditions de type vrai/faux avec les bool√©ens

Avant d'entrer dans les explications, voici un code source que je vous propose de tester :

if (1)
{
    printf("C'est vrai");
}
else
{
    printf("C'est faux");
}

R√©sultat :

C'est vrai

Mais‚Ä¶ Il n'y a pas de condition dans le if  , juste un nombre. Qu'est-ce que √ßa veut dire ?

Si, √ßa en a, vous allez comprendre. Faites un autre test en rempla√ßant 1 par 0 :

if (0)
{
    printf("C'est vrai");
}
else
{
    printf("C'est faux");
}

R√©sultat :

C'est faux

Faites maintenant d'autres tests en rempla√ßant le 0 par n'importe quel autre nombre entier, comme 4, 15, 226, ou encore -10.

Qu'est-ce qu'on vous r√©pond √† chaque fois ? On vous r√©pond : ¬´ C'est vrai ¬ª.

Si on met un 0, le test est consid√©r√© comme faux.

Si on met un 1 ou n'importe quel autre nombre, le test est vrai.

Ci-dessous, le test que vous faites est age >= 18.

  1.if (age >= 18)

Par exemple, si age vaut 23,  alors le test est vrai, et l'ordinateur remplace, en quelque sorte, age >= 18 par 1. Ensuite, l'ordinateur obtient (dans sa t√™te) un if (1). Quand le nombre est 1, comme on l'a vu, l'ordinateur dit que la condition est vraie, donc il affiche ¬´ C'est vrai ¬ª ! Si la condition est fausse, il remplace age >= 18 par le nombre 0, et du coup la condition est fausse : l'ordinateur va lire les instructions du else.

Testez maintenant autre chose : envoyez le r√©sultat de votre condition dans une variable, comme si c'√©tait une op√©ration (car pour l'ordinateur, c'est une op√©ration !).


  1.int age = 20;
  2.int majeur = 0;
  3.
  4.majeur = age >= 18;
  5.printf("Majeur vaut : %d\n", majeur);

Comme vous le voyez, la condition age >= 18 a renvoy√© le nombre 1 car elle est vraie. Du coup, notre variable majeur vaut 1 (on v√©rifie d'ailleurs cela gr√¢ce √† un printf qui montre bien qu'elle a chang√© de valeur).

Faites le m√™me test en mettant age == 10  , par exemple. Cette fois, majeur vaudra "0".

On dit qu'une variable √† laquelle on fait prendre les valeurs 0 et 1 est un bool√©en. Et aussi que : 0 = faux ; 1 = vrai.

Pour √™tre tout √† fait exact, 0 = faux et tous les autres nombres valent vrai (on a eu l'occasion de le tester plus t√¥t). Ceci dit, pour simplifier les choses on va se contenter de n'utiliser que les nombres 0 et 1, pour dire si "quelque chose est faux ou vrai".

En langage C, il n'existe pas de type de variable "bool√©en". Donc, on est oblig√© d'utiliser un type entier comme int pour g√©rer les bool√©ens.

Souvent, on fera un test if sur une variable bool√©enne :

  1.int majeur = 1;
  2.
  3.if (majeur)
  4.{
  5.    printf("Vous etes majeur !");
  6.}
  7.else
  8.{
  9.    printf("Vous etes mineur");
  10.}

Comme  majeur  vaut "1", la condition est vraie, donc on affiche "Vous √™tes majeur !".

Ce qui est tr√®s pratique, c'est que la condition peut √™tre lue facilement par un √™tre humain. On voit if (majeur)  , ce qui peut se traduire par "si vous √™tes majeur". Les tests sur des bool√©ens sont donc faciles √† lire et √† comprendre, pour peu que vous ayez donn√© des noms clairs √† vos variables.

Tenez, voici un autre test imaginaire :

  1.if (majeur && vaccin)

Ce test signifie "si vous √™tes majeur ET que vous √™tes vaccin√©".

vaccin est une autre variable bool√©enne qui vaut "1" si vous √™tes vaccin√©, et "0" si vous ne l'√™tes pas ! Bravo, vous avez tout compris !

Petite question : si on fait le test if (majeur == 1), √ßa marche aussi, non ?

Tout √† fait. Mais le principe des bool√©ens, c'est justement de raccourcir l'expression du if  , et de la rendre plus lisible. Avouez que if (majeur)√ßa se comprend tr√®s bien, non ?

Retenez donc :

  - Si votre variable est cens√©e contenir un nombre (comme un √¢ge), faites un test sous la forme if (variable 
    == 1). Si au contraire votre variable est cens√©e contenir un bool√©en (c'est-√†-dire soit 1 soit 0 pour dire 
    vrai ou faux), faites un test sous la forme if (variable).

Optimisez votre code avec la condition  switch
if... else est le type de condition le plus souvent utilis√© car il permet de g√©rer tous les cas. En fait, il n'y a pas 36 fa√ßons de faire une condition en C.

Cela dit, if... else peut s'av√©rer quelque peu‚Ä¶ r√©p√©titif. Prenons cet exemple :

if (age == 2)
{
    printf("Salut bebe !");
}
else if (age == 6)
{
    printf("Salut gamin !");
}
else if (age == 12)
{
    printf("Salut jeune !");
}
else if (age == 16)
{
    printf("Salut ado !");
}
else if (age == 18)
{
    printf("Salut adulte !");
}
else if (age == 68)
{
    printf("Salut papy !");
}
else
{
    printf("Je n'ai aucune reponse pour ton age");
}

Construisez un switch

Pour √©viter d'avoir √† faire des r√©p√©titions quand on teste la valeur d'une seule et m√™me variable, il existe une autre structure que if... else. Elle s'appelle switch !
Voici un switch bas√© sur l'exemple qu'on vient de voir :

switch (age)
{
case 2:
  printf("Salut bebe !");
  break;
case 6:
  printf("Salut gamin !");
  break;
case 12:
  printf("Salut jeune !");
  break;
case 16:
  printf("Salut ado !");
  break;
case 18:
  printf("Salut adulte !");
  break;
case 68:
  printf("Salut papy !");
  break;
default:
  printf("Je n'ai aucune reponse pour ton age");
  break;
}

Le principe est le suivant :

  1. Vous √©crivez switch (maVariable) pour dire ¬´ je vais tester la valeur de la variable maVariable¬ª.

  2. Vous ouvrez ensuite des accolades que vous refermez tout en bas.

  3. √Ä l'int√©rieur de ces accolades, vous g√©rez tous les cas :case 2  , case 4  , case 5  ,case 45  ‚Ä¶

Vous devez mettre une instruction break; obligatoirement √† la fin de chaque cas.

Si vous ne le faites pas, l'ordinateur lira les instructions en dessous (cens√©es √™tre r√©serv√©es aux autres cas). break; commande en fait √† l'ordinateur de "sortir" des accolades.

Enfin, le cas default correspond au else qu'on conna√Æt bien maintenant. Si la variable ne vaut aucune des valeurs pr√©c√©dentes, l'ordinateur ira lire le default.

√Ä vous de jouer !

Je crois que le moment est venu de pratiquer un peu !

En console, pour faire un menu, on fait des printf qui affichent les diff√©rentes options possibles. Chaque option est num√©rot√©e, et l'utilisateur doit entrer le num√©ro du menu qui l'int√©resse.

Voici par exemple ce que la console devra afficher :

=== Menu ===
1. Royal Cheese
2. Mc Deluxe
3. Mc Bacon
4. Big Mac
Votre choix ?

Votre mission (si vous l'acceptez) :

  1. Reproduire ce menu √† l'aide de printf.

  2. Ajouter un scanf pour enregistrer le choix de l'utilisateur dans une variable choixMenu.

  3. Faire un switch pour dire √† l'utilisateur "tu as choisi le menu Royal Cheese", par exemple.

Alors, vous avez r√©ussi ?

Je vous propose une correction dans ce screencast, et nous allons aussi pouvoir voir en bonus les bonnes pratiques pour correctement mettre en place un switch case :

D√©couvrez les conditions condens√©es : les ternaires
Il existe une troisi√®me fa√ßon de faire des conditions, plus rare : les expressions ternaires.

Les ternaires ne sont pas du tout indispensables ; personnellement je les utilise peu, car ils peuvent rendre la lecture d'un code source un peu difficile. Cela dit, il vaut mieux les conna√Ætre pour le jour o√π vous tomberez sur un code plein de ternaires !

Concr√®tement, c'est comme un if... else, sauf qu'on fait tout tenir sur une seule ligne.

Comme un exemple vaut mieux qu'un long discours, je vais vous donner deux fois la m√™me condition :

  1. La premi√®re avec un if... else.

  2. Et la seconde, identique, mais sous forme d'une expression ternaire.

1. Analysez cette condition en if... else 

Exemple : on a une variable bool√©enne majeur qui vaut vrai (1) si on est majeur, et faux (0) si on est mineur. On veut changer la valeur de la variable age en fonction du bool√©en, pour mettre "18" si on est majeur, "17" si on est mineur. C'est un exemple compl√®tement stupide, je suis d'accord, mais √ßa me permet de vous montrer comment on peut se servir des expressions ternaires.

Voici comment faire cela avec un if... else  :

if (majeur)
  age = 18;
else
  age = 17;

Notez que j'ai enlev√© les accolades, car elles sont facultatives s'il n'y a qu'une instruction.

2. Analysez cette m√™me condition en ternaire

Voici un code qui fait exactement la m√™me chose que le pr√©c√©dent, mais sous forme ternaire :

  1.age = (majeur) ? 18 : 17;

Les ternaires permettent, sur une seule ligne, de changer la valeur d'une variable en fonction d'une condition.

Ici la condition est tout simplementmajeur  , mais √ßa pourrait √™tre n'importe quelle condition plus longue, bien entendu.

Un autre exemple ?

autorisation = (age >= 18) ? 1 : 0;

Le point d'interrogation permet de dire ¬´ est-ce que tu es majeur ? ¬ª. Si oui, alors on met la valeur 18 dans age. Sinon (le : signifie else ici), on met la valeur 17.

En r√©sum√©

  - Les conditions sont √† la base de tous les programmes. C'est un moyen pour l'ordinateur de prendre une 
    d√©cision en fonction de la valeur d'une variable.

  - Les mots-cl√©s if  , else if  , else signifient respectivement ¬´ si ¬ª, ¬´ sinon si ¬ª, ¬´ sinon ¬ª. On peut 
    √©crire autant de else if que l'on veut.

  - Un bool√©en est une variable qui peut avoir deux √©tats : vrai (1) ou faux (0) (toute valeur diff√©rente de 0 
    est en fait consid√©r√©e comme ¬´ vraie ¬ª). On utilise des int pour stocker des bool√©ens, car ce ne sont en 
    fait rien d'autre que des nombres.

  - Le switch est une alternative au if quand il s'agit d'analyser la valeur d'une variable. Il permet de 
    rendre un code source plus clair si vous vous appr√™tez √† tester de nombreux cas. Si vous utilisez de 
    nombreux else if  , c'est en g√©n√©ral le signe qu'un switch serait plus adapt√© pour rendre le code source 
    plus lisible.

  - Les ternaires sont des conditions tr√®s concises qui permettent d'affecter rapidement une valeur √† une 
    variable en fonction du r√©sultat d'un test. On les utilise avec parcimonie, car le code source a tendance 
    √† devenir moins lisible avec elles.

Si vous avez compris les structures conditionnelles, je vous attends au chapitre suivant. Sinon, c‚Äôest reparti pour un tour avec ce chapitre !

##############################################################################################################

R√©p√©tez des instructions gr√¢ce aux boucles

Une boucle est une technique permettant de r√©p√©ter les m√™mes instructions plusieurs fois.

Comme pour les conditions, il y a plusieurs fa√ßons de r√©aliser des boucles. Nous allons voir trois types de boucles courantes en C :

  1. while

  2. do‚Ä¶ while

  3. for

Dans tous les cas, le principe est le m√™me :

Voici ce qu'il se passe, dans l'ordre :

  1. L'ordinateur lit les instructions de haut en bas (comme d'habitude).

  2. Puis, une fois arriv√© √† la fin de la boucle, il repart √† la premi√®re instruction.

  3. Il recommence alors √† lire les instructions de haut en bas‚Ä¶

  4. ‚Ä¶ Et il repart au d√©but de la boucle.

Le probl√®me dans ce syst√®me c'est que si on ne l'arr√™te pas, l'ordinateur est capable de r√©p√©ter les instructions √† l'infini ! Il n'est pas du genre √† se plaindre, vous savez : il fait ce qu'on lui dit de faire‚Ä¶ Il pourrait tr√®s bien se bloquer dans une boucle infinie, c'est d'ailleurs une des nombreuses craintes des programmeurs.

Et c'est l√† qu'on retrouve‚Ä¶ les conditions !

Quand on cr√©e une boucle, on indique toujours une condition !

Cette condition signifiera ¬´ R√©p√®te la boucle tant que cette condition est vraie ¬ª.

Comme je vous l'ai dit, il y a plusieurs mani√®res de s'y prendre. Voyons voir sans plus tarder comment on r√©alise une boucle de type while en C.

Cr√©ez un boucle  while

Voici comment on construit une boucle while  :

while (/* Condition */)
{
    // Instructions √† r√©p√©ter
}
while signifie ¬´ Tant que ¬ª.

On dit donc √† l'ordinateur :

¬´ Tant que la condition est vraie, r√©p√®te les instructions entre accolades ¬ª.

Faisons un test simple : on va demander √† l'utilisateur de taper le nombre 47. Tant qu'il n'a pas tap√© le nombre 47, on lui redemande le nombre. Le programme ne pourra s'arr√™ter que si l'utilisateur tape le nombre 47 (je sais, je sais, je suis diabolique) :

int nombreEntre = 0;

while (nombreEntre != 47)
{
    printf("Tapez le nombre 47 ! ");
    scanf("%d", &nombreEntre);
}

Voici maintenant le test que j'ai fait (j'ai fait expr√®s de me tromper 2-3 fois avant de taper le bon nombre) :


Tapez le nombre 47 ! 10
Tapez le nombre 47 ! 27
Tapez le nombre 47 ! 40
Tapez le nombre 47 ! 47

Cette boucle while se r√©p√®te donc tant qu'on n'a pas tap√© 47.

Maintenant, essayons quelque chose de plus int√©ressant : on veut que notre boucle se r√©p√®te un certain nombre de fois. On va pour cela cr√©er une variable compteur qui vaudra 0 au d√©but du programme et que l'on va incr√©menter au fur et √† mesure.

C'est quoi d√©j√†, l'incr√©mentation ?

√áa consiste √† ajouter 1 √† la variable en faisant variable++;.

Regardez attentivement ce bout de code et, surtout, essayez de le comprendre :

int compteur = 0;

while (compteur < 10)
{
    printf("Bienvenue sur OpenClassrooms !\n");
    compteur++;
}

R√©sultat :

Bienvenue sur OpenClassrooms !
Bienvenue sur OpenClassrooms !
Bienvenue sur OpenClassrooms !
Bienvenue sur OpenClassrooms !
Bienvenue sur OpenClassrooms !
Bienvenue sur OpenClassrooms !
Bienvenue sur OpenClassrooms !
Bienvenue sur OpenClassrooms !
Bienvenue sur OpenClassrooms !
Bienvenue sur OpenClassrooms !

Ce code r√©p√®te 10 fois l'affichage de "Bienvenue sur OpenClassrooms !".

Comment √ßa marche exactement ?

Au d√©part, on a une variable compteur initialis√©e √† 0. Elle vaut donc 0 au d√©but du programme.

La boucle while ordonne la r√©p√©tition TANT QUE compteur est inf√©rieur √† 10. Comme compteur vaut 0 au d√©part, on rentre dans la boucle.

On affiche la phrase ¬´ Bienvenue sur OpenClassrooms ! ¬ª via un printf.

Gr√¢ce √† compteur++; , on incr√©mente la valeur de la variable compteur (qui valait 0, elle vaut maintenant 1).

On arrive √† la fin de la boucle (accolade fermante) : on repart donc au d√©but, au niveau du while pour refaire le test : ¬´ Est-ce que compteur est toujours inf√©rieure √† 10 ? ¬ª. Oui car compteur vaut 1. On recommence donc les instructions de la boucle.

Et ainsi de suite : compteur va valoir progressivement 0, 1, 2, 3‚Ä¶ 8, 9, et 10. Lorsque compteur vaut 10, la condition compteur < 10 est fausse. Comme l'instruction est fausse, on sort de la boucle.

On pourrait d'ailleurs voir que la variable compteur augmente au fur et √† mesure dans la boucle, en l'affichant dans le printf:


int compteur = 0;

while (compteur < 10)
{
    printf("La variable compteur vaut %d\n", compteur);
    compteur++;
}

La variable compteur vaut 0
La variable compteur vaut 1
La variable compteur vaut 2
La variable compteur vaut 3
La variable compteur vaut 4
La variable compteur vaut 5
La variable compteur vaut 6
La variable compteur vaut 7
La variable compteur vaut 8
La variable compteur vaut 9

Voil√† : si vous avez compris √ßa, vous avez tout compris !

Vous pouvez vous amuser √† augmenter la limite du nombre de boucles : < 100  au lieu de < 10. Cela m'aurait √©t√© d'ailleurs utile plus jeune pour r√©diger les punitions que je devais r√©√©crire 100 fois.

Attention aux boucles infinies !

Lorsque vous cr√©ez une boucle, assurez-vous qu'elle puisse s'arr√™ter √† un moment ! Si la condition est toujours vraie, votre programme ne s'arr√™tera jamais !

Voici un exemple de boucle infinie :

while (1)
{
    printf("Boucle infinie\n");
}

Souvenez-vous des bool√©ens : 1 = vrai, 0 = faux. Ici, la condition est toujours vraie, ce programme affichera donc ¬´ Boucle infinie ¬ª sans arr√™t !

Que faire si on a lanc√© une boucle infinie par erreur ?

Pour arr√™ter un tel programme sous Windows, vous n'avez pas d'autre choix que de fermer la console en cliquant sur la croix en haut √† droite. Sous mac ou Linux, faites Ctrl + C.

Nous allons voir dans la vid√©o suivante comment cr√©er votre premi√®re boucle while en faisant attention √† ne pas tomber dans le pi√®ge de la boucle infinie :

Cr√©ez une boucle  do‚Ä¶ while

Ce type de boucle est moins utilis√©. La seule chose qui change par rapport √† une boucle while  , c'est la position de la condition : au lieu d'√™tre au d√©but de la boucle, la condition est √† la fin :

int compteur = 0;

do
{
    printf("Bienvenue sur OpenClassrooms !\n");
    compteur++;
} while (compteur < 10);

Qu'est-ce que √ßa change ?

La boucle while peut tr√®s bien ne jamais √™tre ex√©cut√©e si la condition est fausse d√®s le d√©part. Par exemple, si on avait initialis√© le compteur √† 50, la condition aurait √©t√© fausse d√®s le d√©but, et on ne serait jamais rentr√© dans la boucle.

Pour la boucle do‚Ä¶ while, c'est diff√©rent : cette boucle s'ex√©cutera toujours au moins une fois. En effet, le test se fait √† la fin, comme vous pouvez le voir. Si on initialise compteur √† 50, la boucle s'ex√©cutera une fois.

Il est donc parfois utile de faire des boucles de ce type, pour s'assurer que l'on rentre au moins une fois dans la boucle.

Attention : il y a un  ;  √† la fin de la boucle do‚Ä¶ while .

N'oubliez pas d'en mettre un apr√®s le while, sinon votre programme plantera √† la compilation !

La vid√©o montre la diff√©rence entre la boucle while et la boucle do...while :

Cr√©ez une boucle  for

En th√©orie, while permet de r√©aliser toutes les boucles que l'on veut.

Toutefois, comme switch pour les conditions, il est parfois utile d'avoir un autre syst√®me de boucle, plus ¬´ condens√© ¬ª, plus rapide √† √©crire. Pour cela, on a les boucles  for  .

Sachez que vous utiliserez certainement autant de for que de while  , si ce n'est plus ; il vous faudra donc savoir manipuler ces deux types de boucles.

Pour rappel, voici un exemple de boucle while que nous avons vu tout √† l'heure :

int compteur = 0;

while (compteur < 10)
{
    printf("Bienvenue sur OpenClassrooms !\n");
    compteur++;
}

Voici maintenant l'√©quivalent en boucle for :

int compteur;

for (compteur = 0 ; compteur < 10 ; compteur++)
{
    printf("Bienvenue sur OpenClassrooms !\n");
}

Quelles diff√©rences y a-t-il ?

  - On n'a pas initialis√© la variable compteur √† 0 d√®s sa d√©claration (mais on aurait pu le faire).

  - Il y a beaucoup de choses entre les parenth√®ses apr√®s for  (nous allons d√©tailler √ßa apr√®s).

  - Il n'y a plus de compteur++;  dans la boucle.

Int√©ressons-nous √† ce qui se trouve entre les parenth√®ses, car c'est l√† que r√©side tout l'int√©r√™t de la boucle for : il y a trois instructions condens√©es, s√©par√©es par un point-virgule :

  1. L'initialisation : cette premi√®re instruction est utilis√©e pour pr√©parer notre variable compteur. Dans 
     notre cas, on initialise la variable √† 0.

  2. La condition : comme pour la boucle while, c'est la condition qui dit si la boucle doit √™tre r√©p√©t√©e ou 
     non. Tant que la condition est vraie, la boucle for continue.

  3. L'incr√©mentation : cette derni√®re instruction est ex√©cut√©e √† la fin de chaque tour de boucle pour mettre 
     √† jour la variable compteur. La plupart du temps, on fera une incr√©mentation, mais on peut aussi faire 
     une d√©cr√©mentation (variable--), ou encore n'importe quelle autre op√©ration (variable += 2; pour avancer 
     de 2 en 2, par exemple).

Bref ! for n'est rien d'autre qu'un condens√©. 

L‚Äôinstruction  break  permet d'arr√™ter l‚Äôex√©cution d‚Äôune boucle, elle permet de sortir pr√©matur√©ment de la boucle et de lancer l‚Äôinstruction suivante.

L‚Äôinstruction  continue  permet de passer directement √† l‚Äôit√©ration suivante sans ex√©cuter les lignes de l‚Äôit√©ration courante.

Pour terminer ce chapitre, je vous propose une derni√®re vid√©o qui montre comment utiliser une boucle  for   , et les erreurs √† √©viter :

En r√©sum√©

  - Les boucles sont des structures qui nous permettent de r√©p√©ter une s√©rie d'instructions plusieurs fois.

  - Il existe plusieurs types de boucles : while, do‚Ä¶ while et for. Certaines sont plus adapt√©es que d'autres 
    selon les cas.

  - for est probablement celle qu'on utilise le plus. On y fait tr√®s souvent des incr√©mentations ou des 
    d√©cr√©mentations de variables.

Vous √™tes maintenant au point avec l‚Äôensemble des concepts de base du langage. Voyons maintenant une notion tr√®s importante de la programmation. Comment cr√©er une fonction ?

##############################################################################################################

D√©coupez votre programme en fonctions

Nous allons apprendre √† organiser notre code en fonctions. Il s'agit en fait de d√©couper nos programmes en petits morceaux. Chaque petit morceau sera ce qu'on appelle une fonction.

Une fonction ex√©cute des actions et renvoie un r√©sultat. C'est un morceau de code qui sert √† faire quelque chose de pr√©cis. On dit qu'une fonction poss√®de une entr√©e et une sortie.

Cr√©ez une fonction

Voil√† comment on repr√©sente une fonction, sch√©matiquement (c'est un mod√®le √† conna√Ætre !) :

type nomFonction(parametres)
{
    // Ins√©rez vos instructions ici
}


type  (correspond √† la sortie) : c'est le type de la fonction.

Si la fonction renvoie un nombre d√©cimal, vous mettrez s√ªrement double  ; si elle renvoie un entier, vous mettrez int ou long par exemple. Mais il est aussi possible de cr√©er des fonctions qui ne renvoient rien, elles seront alors de type void  ("vide", en fran√ßais).

nomFonction  : c'est le nom de votre fonction.

Vous pouvez appeler votre fonction comme vous voulez, du moment que vous respectez les m√™mes r√®gles que pour les variables (pas d'accents, pas d'espaces, etc.).

parametres  (correspond √† l'entr√©e) : ce sont les param√®tres de la fonction.

Ils sont entre parenth√®ses. Ce sont en fait des valeurs avec lesquelles la fonction va travailler.

Maintenant que vous savez √ßa, voyons un exemple pratique ! Disons que :

  - notre fonction triple re√ßoit un nombre entier de type  int  ;

  - et qu'elle renvoie un nombre entier √©galement de type int.

Elle calcule le triple du nombre qu'on lui donne :

int triple(int nombre)
{
    int resultat = 0;

    resultat = 3 * nombre;  // On multiplie le nombre fourni par 3
    return resultat;       // On retourne la variable resultat qui vaut le triple de nombre
}

La fonction est de type int. Elle doit donc renvoyer une valeur de type int.

Entre les parenth√®ses, vous avez les variables que la fonction re√ßoit. Ici, notre fonction triple re√ßoit une variable de type int appel√©e nombre.

La ligne qui donne pour consigne de "renvoyer une valeur" est celle qui contient le return. Cette ligne se trouve g√©n√©ralement √† la fin de la fonction, apr√®s les calculs. 

Ce code signifie pour la fonction :

¬´ Arr√™te-toi l√† et renvoie le nombre resultat¬ª.

Cette variable resultat DOIT √™tre de type int, car la fonction renvoie un int .

La variable resultat est d√©clar√©e (= cr√©√©e) dans la fonction triple. Cela signifie qu'elle n'est utilisable que dans cette fonction, et pas dans une autre (comme la fonction main par exemple). C'est donc une variable propre √† la fonction triple.

Mais est-ce la fa√ßon la plus courte d'√©crire notre fonction triple  ?

Non, on peut faire tout cela en une ligne :

int triple(int nombre)
{
    return 3 * nombre;
}

Cette fonction fait exactement la m√™me chose que la fonction de tout √† l'heure, elle est juste plus rapide √† √©crire.

G√©n√©ralement, vos fonctions contiendront plusieurs variables pour effectuer leurs calculs et leurs op√©rations ; rares seront les fonctions aussi courtes que triple.

Affectez (ou non) des param√®tres √† une fonction

Vous pouvez envoyer autant de param√®tres que vous le voulez. Vous pouvez aussi n'envoyer aucun param√®tre √† la fonction, mais √ßa se fait plus rarement.

Affectez plusieurs param√®tres √† une fonction

Notre fonction triple contient un param√®tre, mais il est possible de cr√©er des fonctions acceptant plusieurs param√®tres, comme par exemple une fonction addition qui additionne deux nombres a et b  :

int addition(int a, int b)
{
    return a + b;
}

Il suffit de s√©parer les diff√©rents param√®tres par une virgule, comme vous le voyez.

N'affectez aucun param√®tre √† fonction

Certaines fonctions, plus rares, ne prennent aucun param√®tre en entr√©e. Ces fonctions feront g√©n√©ralement toujours la m√™me chose. En effet, si elles n'ont pas de nombres sur lesquels travailler, vos fonctions serviront juste √† effectuer certaines actions, comme afficher du texte √† l'√©cran. Et encore, ce sera forc√©ment toujours le m√™me texte, puisque la fonction ne re√ßoit aucun param√®tre susceptible de modifier son comportement !

Imaginons une fonction bonjour qui affiche juste "Bonjour" √† l'√©cran :

void bonjour()
{
    printf("Bonjour");
}

Je n'ai rien mis entre parenth√®ses car la fonction ne prend aucun param√®tre. De plus, j'ai utilis√© le type void dont je vous ai parl√© plus haut.

En effet, ma fonction n'a pas non plus de return : elle ne retourne rien.

Une fonction qui ne retourne rien est de type void.

Appelez une fonction

Nous allons reprendre notre fonction triple  (d√©cid√©ment, je l'aime bien) pour calculer le triple d'un nombre.

Pour le moment, √©crivez la fonction triple AVANT la fonction main  (si vous la placez apr√®s, √ßa ne marchera pas, je vous expliquerai pourquoi par la suite).

Testez donc ce code pour comprendre :

#include <stdio.h>
#include <stdlib.h>

int triple(int nombre)
{
    return 3 * nombre;
}    

int main(int argc, char *argv[])
{
    int nombreEntre = 0, nombreTriple = 0;
    
    printf("Entrez un nombre... ");
    scanf("%d", &nombreEntre);
    
    nombreTriple = triple(nombreEntre);
    printf("Le triple de ce nombre est %d\n", nombreTriple);
    
    return 0;
}

Notre programme commence par la fonction main :

  1. On demande √† l'utilisateur d'entrer un nombre.

  2. On envoie ce nombre qu'il a entr√© √† la fonction triple  .

  3. Et on r√©cup√®re le r√©sultat dans la variable nombreTriple  .

Regardez en particulier cette ligne, c'est la plus int√©ressante car c'est l'appel de la fonction :

  1.nombreTriple = triple(nombreEntre);

Entre parenth√®ses, on envoie √† la fonction triple une variable en entr√©e (c'est le nombre sur lequel elle va travailler).

Cette fonction renvoie une valeur qu'on r√©cup√®re dans la variable nombreTriple  .

Dans cette ligne de code, on ordonne donc √† l'ordinateur :

¬´ Demande √† la fonction triple de me calculer le triple de nombreEntre  ,

et stocke le r√©sultat dans la variable nombreTriple  ¬ª.

Dans la vid√©o suivante, nous allons reprendre le m√™me exemple, et voir les diff√©rentes √©tapes pour cr√©er la fonction  triple  et l‚Äôappeler dans le  main  :

Comprenez le sens de lecture d'une fonction

Le code ci-dessous est comment√© de mani√®re un peu particuli√®re. C'est pour vous montrer dans quel ordre le code est "lu". Commencez donc par lire la ligne comment√©e 1, puis 2, puis 3 (vous avez compris ü§£) :

#include <stdio.h>
#include <stdlib.h>

int triple(int nombre) // 6
{
    return 3 * nombre; // 7
}    

int main(int argc, char *argv[]) // 1
{
    int nombreEntre = 0, nombreTriple = 0; // 2
    
    printf("Entrez un nombre... "); // 3
    scanf("%d", &nombreEntre); // 4
    
    nombreTriple = triple(nombreEntre); // 5
    printf("Le triple de ce nombre est %d\n", nombreTriple); // 8
    
    return 0; // 9
}

Voici ce qui se passe, ligne par ligne.

  1. Le programme commence par la fonction main.

  2. Il lit les instructions dans la fonction, une par une, dans l'ordre.

  3. Il lit l'instruction suivante et fait ce qui est demand√© (printf).

  4. De m√™me, il lit l'instruction et fait ce qui est demand√© (scanf).

  5. Il lit l'instruction‚Ä¶ Ah ! On appelle la fonction triple, on doit donc sauter √† la ligne de la fonction 
     triple plus haut.

  6. On saute √† la fonction triple et on r√©cup√®re un param√®tre (nombre).

  7. On fait des calculs sur le nombre et on termine la fonction :return signifie la fin de la fonction, et 
     permet d'indiquer le r√©sultat √† renvoyer.

  8. On retourne dans main pour prendre l'instruction suivante.

  9. Un return : la fonction  main  se termine, et donc le programme est termin√©.

Si vous avez compris dans quel ordre l'ordinateur lit les instructions, vous avez d√©j√† compris le principal.

Parfois, une fonction ne prend aucun param√®tre en entr√©e ; ou au contraire elle en prend plusieurs (je vous ai expliqu√© √ßa un peu plus haut).

De m√™me, parfois une fonction renvoie une valeur, parfois elle ne renvoie rien (dans ce cas, il n'y a pas de return).

Voici un exemple d'utilisation du programme :

Entrez un nombre... 10
Le triple de ce nombre est 30

Vous n'√™tes pas oblig√© de stocker le r√©sultat d'une fonction dans une variable ! Vous pouvez directement envoyer le r√©sultat de la fonction triple √† une autre fonction, comme si triple(nombreEntre) √©tait une variable.

Regardez bien ceci, c'est le m√™me code mais il y a un changement au niveau du dernier printf. De plus, on n'a pas d√©clar√© de variable nombreTriple car on ne s'en sert plus :

#include <stdio.h>
#include <stdlib.h>

int triple(int nombre)
{
    return 3 * nombre;
}    

int main(int argc, char *argv[])
{
    int nombreEntre = 0;
    
    printf("Entrez un nombre... ");
    scanf("%d", &nombreEntre);

    // Le r√©sultat de la fonction est directement envoy√© au printf et n'est pas stock√© dans une variable
    printf("Le triple de ce nombre est %d\n", triple(nombreEntre));
     
    return 0;
}


triple(nombreEntre)  est directement envoy√© au printf.

Que fait l'ordinateur quand il tombe sur cette ligne ?

Il voit que la ligne commence par printf, il va donc appeler la fonction printf.

Il envoie √† la fonction printf tous les param√®tres qu'on lui donne :

  1. Le premier param√®tre est le texte √† afficher.

  2. Et le second est un nombre.

Votre ordinateur voit qu'il doit d'abord appeler la fonction triple pour envoyer ce nombre √† la fonction printf :

  1. Il appelle triple.

  2. Il effectue les calculs de triple.

  3. Et une fois qu'il a le r√©sultat, il l'envoie directement dans la fonction printf !

C'est un peu une imbrication de fonctions. Et le plus fin dans tout √ßa, c'est qu'une fonction peut en appeler une autre √† son tour : notre fonction triple pourrait appeler une autre fonction, qui elle-m√™me appellerait une autre fonction, etc. C'est √ßa le principe de la programmation en C : tout est combin√©, comme dans un jeu de LEGO.

Le plus dur sera d'√©crire vos fonctions.

Une fois que vous les aurez √©crites, vous n'aurez plus qu'√† appeler les fonctions sans vous soucier des calculs qu'elles peuvent bien faire √† l'int√©rieur.

√áa va permettre de simplifier consid√©rablement l'√©criture de nos programmes et √ßa, croyez-moi, on en aura bien besoin !

Int√©grez le principe en pratique avec ces exemples
Je vais donc maintenant vous montrer plusieurs exemples d'utilisation de fonctions, pour que vous ayez une id√©e de leur int√©r√™t. Je vais m'efforcer de faire des cas diff√©rents √† chaque fois, pour que vous puissiez avoir des exemples de tous les types de fonctions qui peuvent exister.

Je ne vous apprendrai rien de nouveau, mais ce sera l'occasion de voir des exemples pratiques. Si vous avez d√©j√† compris tout ce que j'ai expliqu√© avant, c'est tr√®s bien, et normalement aucun des exemples qui vont suivre ne devrait vous surprendre.

Analysez une fonction qui prend 1 param√®tre

Int√©resserons-nous √† une fonction qui ne renvoie rien (pas de sortie). Imaginons une fonction qui copie des lignes, comme les punitions que l'on avait lorsqu'on √©tait petit :

void punition(int nombreDeLignes)
{
    int i;
    
    for (i = 0 ; i < nombreDeLignes ; i++)
    {
        printf("Je ne dois pas copier sur mon voisin\n");
    }    
}    

int main(int argc, char *argv[])
{    
    punition(10);
    
    return 0;
}

C'est une fonction qui affiche le m√™me message √† l'√©cran autant de fois qu'on lui demande. Elle prend un param√®tre en entr√©e : le nombre de fois o√π il faut afficher la punition.

R√©sultat :

Je ne dois pas copier sur mon voisin
Je ne dois pas copier sur mon voisin
Je ne dois pas copier sur mon voisin
Je ne dois pas copier sur mon voisin
Je ne dois pas copier sur mon voisin
Je ne dois pas copier sur mon voisin
Je ne dois pas copier sur mon voisin
Je ne dois pas copier sur mon voisin
Je ne dois pas copier sur mon voisin
Je ne dois pas copier sur mon voisin

On a ici affaire √† une fonction qui ne renvoie aucune valeur. Cette fonction se contente juste d'effectuer des actions (ici, elle affiche des messages √† l'√©cran).

Il aurait √©t√© bien plus int√©ressant de cr√©er une fonction punition qui s'adapte √† n'importe quelle sanction. On lui aurait envoy√© deux param√®tres : le texte √† r√©p√©ter, et le nombre de fois qu'il doit √™tre r√©p√©t√©.

Le probl√®me, c'est qu'on ne sait pas encore g√©rer le texte en C (au cas o√π vous n'auriez pas vu, je vous rappelle qu'on n'a fait que manipuler des variables contenant des nombres depuis le d√©but du cours !). D'ailleurs √† ce sujet, je vous annonce que nous ne tarderons pas √† apprendre √† utiliser des variables qui retiennent du texte. C'est plus compliqu√© qu'il n'y para√Æt, et on ne pouvait pas l'apprendre d√®s le d√©but du cours !

Analysez une fonction qui prend 2 param√®tres en entr√©e

Imaginons une fonction qui calcule l'aire d'un rectangle. L'aire d'un rectangle est facile √† calculer :largeur * hauteur.
Notre fonction nomm√©e aireRectangle va prendre deux param√®tres : la largeur et la hauteur pour renvoyer l'aire :

double aireRectangle(double largeur, double hauteur)
{
    return largeur * hauteur;
}    

int main(int argc, char *argv[])
{    
    printf("Rectangle de largeur 5 et hauteur 10. Aire = %f\n", aireRectangle(5, 10));
    printf("Rectangle de largeur 2.5 et hauteur 3.5. Aire = %f\n", aireRectangle(2.5, 3.5));
    printf("Rectangle de largeur 4.2 et hauteur 9.7. Aire = %f\n", aireRectangle(4.2, 9.7));
      
    return 0;
}


Rectangle de largeur 5 et hauteur 10. Aire = 50.000000
Rectangle de largeur 2.5 et hauteur 3.5. Aire = 8.750000
Rectangle de largeur 4.2 et hauteur 9.7. Aire = 40.740000

Pourrait-on afficher directement la largeur, la hauteur et l'aire dans la fonction ?

Bien s√ªr ! Dans ce cas, la fonction ne renverrait plus rien, elle se contenterait de calculer l'aire et de l'afficher imm√©diatement :

void aireRectangle(double largeur, double hauteur)
{
    double aire = 0;
    
    aire = largeur * hauteur;
    printf("Rectangle de largeur %f et hauteur %f. Aire = %f\n", largeur, hauteur, aire);
}    

int main(int argc, char *argv[])
{    
    aireRectangle(5, 10);
    aireRectangle(2.5, 3.5);
    aireRectangle(4.2, 9.7);
       
    return 0;
}

printf est √† l'int√©rieur de la fonction aireRectangle et produit le m√™me affichage que tout √† l'heure. C'est juste une fa√ßon diff√©rente de proc√©der.

Analysez une fonction qui ne prend aucun param√®tre en entr√©e

Ce code est plus int√©ressant et concret : on cr√©e une fonction menu qui ne prend aucun param√®tre en entr√©e. Cette fonction se contente d'afficher le menu, et demande √† l'utilisateur de faire un choix. La fonction renvoie le choix de l'utilisateur.

int menu()
{
    int choix = 0;
    
    while (choix < 1 || choix > 4)
    {
        printf("Menu :\n");
        printf("1 : Poulet de dinde aux escargots rotis a la sauce bearnaise\n");
        printf("2 : Concombres sucres a la sauce de myrtilles enrobee de chocolat\n");
        printf("3 : Escalope de kangourou saignante et sa gelee aux fraises poivree\n");
        printf("4 : La surprise du Chef (j'en salive d'avance...)\n");
        printf("Votre choix ? ");
        scanf("%d", &choix);
    }    
    
    return choix;
}    

int main(int argc, char *argv[])
{    
    switch (menu())
    {
        case 1:
            printf("Vous avez pris le poulet\n");
            break;
        case 2:
            printf("Vous avez pris les concombres\n");
            break;
        case 3:
            printf("Vous avez pris l'escalope\n");
            break;
        case 4:
            printf("Vous avez pris la surprise du Chef. Vous etes un sacre aventurier dites donc !\n");
            break;    
    }
       
    return 0;
}

La fonction menu affiche √† nouveau le menu tant que l'utilisateur n'a pas entr√© un nombre compris entre 1 et 4. Comme √ßa, aucun risque que la fonction renvoie un nombre qui ne figure pas au menu !

Dans le main, vous avez vu qu'on fait un switch(menu())  : une fois que la fonction menu()est termin√©e, elle renvoie le choix de l'utilisateur directement dans le switch. C'est une m√©thode rapide et pratique.


