                     Partie 2 :Organisez votre code grâce aux conditions, boucles et fonctions


Structurez votre code avec les conditions

Nous avons vu comment créer des variables, nous allons maintenant nous intéresser aux conditions. Elles permettent de tester des variables. Sans conditions, nos programmes informatiques feraient toujours la même chose !

Utilisez des conditions if... else

On peut par exemple dire :

"si la variable machin est égale à 50, fais ceci."

Mais ce serait dommage de ne pouvoir tester que l'égalité ! Il faudrait aussi pouvoir tester si la variable est inférieure à 50, inférieure ou égale à 50, supérieure, supérieure ou égale… Ne vous inquiétez pas, le C a tout prévu !

Avant de voir comment on écrit une condition de type if... else  en C, il faut donc que vous connaissiez les symboles de base. Voici un tableau récapitulatif à connaître par cœur :

Symbole          Signification

==               est égal à

>                est supérieur à

<                est inférieur à

>=               est supérieur ou égal à

<=               est inférieur ou égal à

!=               est différent de

Il y a bien deux symboles ==  pour tester l'égalité. Une erreur courante que font les débutants est de ne mettre qu'un symbole =  , ce qui n'a pas la même signification en C. 

Ouvrez une condition avec un if 

Nous allons faire un test simple, qui va dire à l'ordinateur :

"SI la variable vaut ça, ALORS fais ceci".

En anglais, le mot "si" se traduit par if.

On l'utilise en langage C pour introduire une condition.

  1. Commencez par écrire if.

  2. Ouvrez des parenthèses (à l'intérieur de ces parenthèses on écrit une condition).

  3. Ouvrez une accolade {  et fermez-la un peu plus loin}. Tout ce qui se trouve à l'intérieur des accolades 
     sera exécuté uniquement si la condition est vérifiée.

Cela nous donne :

if (/* Votre condition */)
{
  // Instructions à exécuter si la condition est vraie
}

À la place de mon commentaire "Votre condition", on va écrire une condition pour tester une variable. Pour s'entraîner, on va tester si vous êtes majeur avec une variable  age  , c'est-à-dire "vous êtes majeur si votre âge est supérieur ou égal à 18" :

if (age >= 18)
{
  printf ("Vous etes majeur !");
}

Rappel : le symbole >=  signifie « supérieur ou égal ».

S'il n'y a qu'une instruction entre les accolades (comme c'est le cas ici), alors celles-ci deviennent facultatives. Je recommande néanmoins de toujours mettre des accolades pour des raisons de clarté.

Si vous voulez tester les codes précédents pour voir comment le if fonctionne, il faudra placer le if à l'intérieur d'une fonction main  , et ne pas oublier de déclarer une variable age à laquelle on donnera la valeur de notre choix :

#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
    int age = 20;
  
    if (age >= 18)
    {
      printf ("Vous etes majeur !\n");
    }
     
    return 0;
}

Ici, la variable age vaut 20, donc le "Vous êtes majeur !" s'affichera.

Essayez de changer la valeur initiale de la variable pour voir. Mettez par exemple 15 : la condition sera fausse, et donc "Vous êtes majeur !" ne s'affichera pas cette fois.

Exécutez une instruction alternative avec else 

Maintenant, allons plus loin : si le test n'a pas marché (il est faux), on va dire à l'ordinateur d'exécuter d'autres instructions.

En français, nous allons donc écrire quelque chose qui ressemble à :

"SI la variable vaut ça, ALORS fais ceci,

SINON fais cela".

Il suffit de rajouter else après l'accolade fermante du if :

if (age >= 18) // Si l'âge est supérieur ou égal à 18
{
  printf ("Vous etes majeur !");
}
else // Sinon...
{
  printf ("Ah c'est bete, vous etes mineur !");
}

Si la variable age est supérieure ou égale à 18, on affiche le message "Vous êtes majeur !", sinon on affiche "Vous êtes mineur".

Conditionnez l'instruction alternative avec else if 

Il est possible de faire un autre test si le premier test n'a pas marché.  On demande alors à l'ordinateur :

"SI la variable vaut ça ALORS fais ceci,

SINON SI la variable vaut ça ALORS fais ça,

SINON fais cela".

else if  ( ou "sinon si") se place entre le if et le else :

if (age >= 18) // Si l'âge est supérieur ou égal à 18
{
  printf ("Vous etes majeur !");
}
else if ( age > 4 ) // Sinon, si l'âge est au moins supérieur à 4 
{
  printf ("Bon t'es pas trop jeune quand meme...");
}
else // Sinon...
{
  printf ("Aga gaa aga gaaa"); // Langage bébé, vous pouvez pas comprendre
}

L'ordinateur fait les tests dans l'ordre :

  1. D'abord il teste le premier if: si la condition est vraie, alors il exécute ce qui se trouve entre les 
     premières accolades.

  2. Sinon, il va au « sinon si » et fait à nouveau un test : si ce test est vrai, alors il exécute les 
     instructions correspondantes entre accolades.

  3. Enfin, si aucun des tests précédents n'a marché, il exécute les instructions du « sinon ».

Notez que l'on peut mettre autant de else if que l'on veut.

On peut donc écrire :

SI la variable vaut ça,
ALORS fais ceci,
SINON SI la variable vaut ça ALORS fais ça,
SINON SI la variable vaut ça ALORS fais ça,
SINON SI la variable vaut ça ALORS fais ça,
SINON fais cela.

Vous avez encore quelques doutes sur l’utilisation du if, else if et else ? Pas de panique, dans la vidéo suivante, nous revoit tout, étape par étape :

Testez plusieurs conditions à la fois

Il peut aussi être utile de faire plusieurs tests à la fois dans votre if.

Pour cela, il va falloir utiliser de nouveaux symboles :

Symbole    Signification

&&           ET

||           OU

!            NON

Ajoutez une contrainte "ET" avec  &&

On peut vouloir tester si l'âge est supérieur à 18 ET si l'âge est inférieur à 25.

Pour cela, il vous faudra écrire :

  1.if (age > 18 && age < 25)

Ajoutez une contrainte "OU" avec  ||

Ce signe n'est pas facilement accessible sur nos claviers. Sur un clavier AZERTY français, il faudra faire Alt Gr + 6 ; sur un clavier belge, Alt Gr + &.

Imaginons un programme qui décide si une personne a le droit d'ouvrir un compte en banque. Pour ouvrir un compte en banque, il vaut mieux ne pas être trop jeune, ou bien avoir beaucoup d'argent. Notre test pourrait être :

if (age > 30 || argent > 100000)
{
    printf("Bienvenue chez PicsouBanque !");
}
else
{
    printf("Hors de ma vue, miserable !");
}

Ce test n'est valide que si la personne a plus de 30 ans ou si elle possède plus de 100 000 euros !

Testez l'opposée d'une condition avec  !

En informatique, le point d'exclamation signifie « non ».

Vous devez mettre ce signe avant votre condition pour dire « si cela n'est pas vrai » :

  1.if (!(age < 18))

Cela pourrait se traduire par « si la personne n'est pas mineure ».

Si on avait enlevé le !  devant, cela aurait signifié l'inverse : « si la personne est mineure ».

Et puisqu'on y est, je voudrais vous lister quelques erreurs courantes du débutant.

Évitez de faire ces erreurs

Oublier les deux signes  ==
Pour tester si la personne a tout juste 18 ans, il faut écrire if (age == 18) avec  ==  .
Si vous ne mettez qu'un seul =, alors votre variable prendra la valeur 18. Ce qu'on veut faire ici, c'est tester la valeur de la variable, non pas la changer. Faites très attention à cela !

Terminer une condition avec un  ;
Un if est une condition. On met un  ;  à la fin d'une instruction, pas d'une condition.

Faites des conditions de type vrai/faux avec les booléens

Avant d'entrer dans les explications, voici un code source que je vous propose de tester :

if (1)
{
    printf("C'est vrai");
}
else
{
    printf("C'est faux");
}

Résultat :

C'est vrai

Mais… Il n'y a pas de condition dans le if  , juste un nombre. Qu'est-ce que ça veut dire ?

Si, ça en a, vous allez comprendre. Faites un autre test en remplaçant 1 par 0 :

if (0)
{
    printf("C'est vrai");
}
else
{
    printf("C'est faux");
}

Résultat :

C'est faux

Faites maintenant d'autres tests en remplaçant le 0 par n'importe quel autre nombre entier, comme 4, 15, 226, ou encore -10.

Qu'est-ce qu'on vous répond à chaque fois ? On vous répond : « C'est vrai ».

Si on met un 0, le test est considéré comme faux.

Si on met un 1 ou n'importe quel autre nombre, le test est vrai.

Ci-dessous, le test que vous faites est age >= 18.

  1.if (age >= 18)

Par exemple, si age vaut 23,  alors le test est vrai, et l'ordinateur remplace, en quelque sorte, age >= 18 par 1. Ensuite, l'ordinateur obtient (dans sa tête) un if (1). Quand le nombre est 1, comme on l'a vu, l'ordinateur dit que la condition est vraie, donc il affiche « C'est vrai » ! Si la condition est fausse, il remplace age >= 18 par le nombre 0, et du coup la condition est fausse : l'ordinateur va lire les instructions du else.

Testez maintenant autre chose : envoyez le résultat de votre condition dans une variable, comme si c'était une opération (car pour l'ordinateur, c'est une opération !).


  1.int age = 20;
  2.int majeur = 0;
  3.
  4.majeur = age >= 18;
  5.printf("Majeur vaut : %d\n", majeur);

Comme vous le voyez, la condition age >= 18 a renvoyé le nombre 1 car elle est vraie. Du coup, notre variable majeur vaut 1 (on vérifie d'ailleurs cela grâce à un printf qui montre bien qu'elle a changé de valeur).

Faites le même test en mettant age == 10  , par exemple. Cette fois, majeur vaudra "0".

On dit qu'une variable à laquelle on fait prendre les valeurs 0 et 1 est un booléen. Et aussi que : 0 = faux ; 1 = vrai.

Pour être tout à fait exact, 0 = faux et tous les autres nombres valent vrai (on a eu l'occasion de le tester plus tôt). Ceci dit, pour simplifier les choses on va se contenter de n'utiliser que les nombres 0 et 1, pour dire si "quelque chose est faux ou vrai".

En langage C, il n'existe pas de type de variable "booléen". Donc, on est obligé d'utiliser un type entier comme int pour gérer les booléens.

Souvent, on fera un test if sur une variable booléenne :

  1.int majeur = 1;
  2.
  3.if (majeur)
  4.{
  5.    printf("Vous etes majeur !");
  6.}
  7.else
  8.{
  9.    printf("Vous etes mineur");
  10.}

Comme  majeur  vaut "1", la condition est vraie, donc on affiche "Vous êtes majeur !".

Ce qui est très pratique, c'est que la condition peut être lue facilement par un être humain. On voit if (majeur)  , ce qui peut se traduire par "si vous êtes majeur". Les tests sur des booléens sont donc faciles à lire et à comprendre, pour peu que vous ayez donné des noms clairs à vos variables.

Tenez, voici un autre test imaginaire :

  1.if (majeur && vaccin)

Ce test signifie "si vous êtes majeur ET que vous êtes vacciné".

vaccin est une autre variable booléenne qui vaut "1" si vous êtes vacciné, et "0" si vous ne l'êtes pas ! Bravo, vous avez tout compris !

Petite question : si on fait le test if (majeur == 1), ça marche aussi, non ?

Tout à fait. Mais le principe des booléens, c'est justement de raccourcir l'expression du if  , et de la rendre plus lisible. Avouez que if (majeur)ça se comprend très bien, non ?

Retenez donc :

  - Si votre variable est censée contenir un nombre (comme un âge), faites un test sous la forme if (variable 
    == 1). Si au contraire votre variable est censée contenir un booléen (c'est-à-dire soit 1 soit 0 pour dire 
    vrai ou faux), faites un test sous la forme if (variable).

Optimisez votre code avec la condition  switch
if... else est le type de condition le plus souvent utilisé car il permet de gérer tous les cas. En fait, il n'y a pas 36 façons de faire une condition en C.

Cela dit, if... else peut s'avérer quelque peu… répétitif. Prenons cet exemple :

if (age == 2)
{
    printf("Salut bebe !");
}
else if (age == 6)
{
    printf("Salut gamin !");
}
else if (age == 12)
{
    printf("Salut jeune !");
}
else if (age == 16)
{
    printf("Salut ado !");
}
else if (age == 18)
{
    printf("Salut adulte !");
}
else if (age == 68)
{
    printf("Salut papy !");
}
else
{
    printf("Je n'ai aucune reponse pour ton age");
}

Construisez un switch

Pour éviter d'avoir à faire des répétitions quand on teste la valeur d'une seule et même variable, il existe une autre structure que if... else. Elle s'appelle switch !
Voici un switch basé sur l'exemple qu'on vient de voir :

switch (age)
{
case 2:
  printf("Salut bebe !");
  break;
case 6:
  printf("Salut gamin !");
  break;
case 12:
  printf("Salut jeune !");
  break;
case 16:
  printf("Salut ado !");
  break;
case 18:
  printf("Salut adulte !");
  break;
case 68:
  printf("Salut papy !");
  break;
default:
  printf("Je n'ai aucune reponse pour ton age");
  break;
}

Le principe est le suivant :

  1. Vous écrivez switch (maVariable) pour dire « je vais tester la valeur de la variable maVariable».

  2. Vous ouvrez ensuite des accolades que vous refermez tout en bas.

  3. À l'intérieur de ces accolades, vous gérez tous les cas :case 2  , case 4  , case 5  ,case 45  …

Vous devez mettre une instruction break; obligatoirement à la fin de chaque cas.

Si vous ne le faites pas, l'ordinateur lira les instructions en dessous (censées être réservées aux autres cas). break; commande en fait à l'ordinateur de "sortir" des accolades.

Enfin, le cas default correspond au else qu'on connaît bien maintenant. Si la variable ne vaut aucune des valeurs précédentes, l'ordinateur ira lire le default.

À vous de jouer !

Je crois que le moment est venu de pratiquer un peu !

En console, pour faire un menu, on fait des printf qui affichent les différentes options possibles. Chaque option est numérotée, et l'utilisateur doit entrer le numéro du menu qui l'intéresse.

Voici par exemple ce que la console devra afficher :

=== Menu ===
1. Royal Cheese
2. Mc Deluxe
3. Mc Bacon
4. Big Mac
Votre choix ?

Votre mission (si vous l'acceptez) :

  1. Reproduire ce menu à l'aide de printf.

  2. Ajouter un scanf pour enregistrer le choix de l'utilisateur dans une variable choixMenu.

  3. Faire un switch pour dire à l'utilisateur "tu as choisi le menu Royal Cheese", par exemple.

Alors, vous avez réussi ?

Je vous propose une correction dans ce screencast, et nous allons aussi pouvoir voir en bonus les bonnes pratiques pour correctement mettre en place un switch case :

Découvrez les conditions condensées : les ternaires
Il existe une troisième façon de faire des conditions, plus rare : les expressions ternaires.

Les ternaires ne sont pas du tout indispensables ; personnellement je les utilise peu, car ils peuvent rendre la lecture d'un code source un peu difficile. Cela dit, il vaut mieux les connaître pour le jour où vous tomberez sur un code plein de ternaires !

Concrètement, c'est comme un if... else, sauf qu'on fait tout tenir sur une seule ligne.

Comme un exemple vaut mieux qu'un long discours, je vais vous donner deux fois la même condition :

  1. La première avec un if... else.

  2. Et la seconde, identique, mais sous forme d'une expression ternaire.

1. Analysez cette condition en if... else 

Exemple : on a une variable booléenne majeur qui vaut vrai (1) si on est majeur, et faux (0) si on est mineur. On veut changer la valeur de la variable age en fonction du booléen, pour mettre "18" si on est majeur, "17" si on est mineur. C'est un exemple complètement stupide, je suis d'accord, mais ça me permet de vous montrer comment on peut se servir des expressions ternaires.

Voici comment faire cela avec un if... else  :

if (majeur)
  age = 18;
else
  age = 17;

Notez que j'ai enlevé les accolades, car elles sont facultatives s'il n'y a qu'une instruction.

2. Analysez cette même condition en ternaire

Voici un code qui fait exactement la même chose que le précédent, mais sous forme ternaire :

  1.age = (majeur) ? 18 : 17;

Les ternaires permettent, sur une seule ligne, de changer la valeur d'une variable en fonction d'une condition.

Ici la condition est tout simplementmajeur  , mais ça pourrait être n'importe quelle condition plus longue, bien entendu.

Un autre exemple ?

autorisation = (age >= 18) ? 1 : 0;

Le point d'interrogation permet de dire « est-ce que tu es majeur ? ». Si oui, alors on met la valeur 18 dans age. Sinon (le : signifie else ici), on met la valeur 17.

En résumé

  - Les conditions sont à la base de tous les programmes. C'est un moyen pour l'ordinateur de prendre une 
    décision en fonction de la valeur d'une variable.

  - Les mots-clés if  , else if  , else signifient respectivement « si », « sinon si », « sinon ». On peut 
    écrire autant de else if que l'on veut.

  - Un booléen est une variable qui peut avoir deux états : vrai (1) ou faux (0) (toute valeur différente de 0 
    est en fait considérée comme « vraie »). On utilise des int pour stocker des booléens, car ce ne sont en 
    fait rien d'autre que des nombres.

  - Le switch est une alternative au if quand il s'agit d'analyser la valeur d'une variable. Il permet de 
    rendre un code source plus clair si vous vous apprêtez à tester de nombreux cas. Si vous utilisez de 
    nombreux else if  , c'est en général le signe qu'un switch serait plus adapté pour rendre le code source 
    plus lisible.

  - Les ternaires sont des conditions très concises qui permettent d'affecter rapidement une valeur à une 
    variable en fonction du résultat d'un test. On les utilise avec parcimonie, car le code source a tendance 
    à devenir moins lisible avec elles.

Si vous avez compris les structures conditionnelles, je vous attends au chapitre suivant. Sinon, c’est reparti pour un tour avec ce chapitre !

##############################################################################################################

Répétez des instructions grâce aux boucles

Une boucle est une technique permettant de répéter les mêmes instructions plusieurs fois.

Comme pour les conditions, il y a plusieurs façons de réaliser des boucles. Nous allons voir trois types de boucles courantes en C :

  1. while

  2. do… while

  3. for

Dans tous les cas, le principe est le même :

Voici ce qu'il se passe, dans l'ordre :

  1. L'ordinateur lit les instructions de haut en bas (comme d'habitude).

  2. Puis, une fois arrivé à la fin de la boucle, il repart à la première instruction.

  3. Il recommence alors à lire les instructions de haut en bas…

  4. … Et il repart au début de la boucle.

Le problème dans ce système c'est que si on ne l'arrête pas, l'ordinateur est capable de répéter les instructions à l'infini ! Il n'est pas du genre à se plaindre, vous savez : il fait ce qu'on lui dit de faire… Il pourrait très bien se bloquer dans une boucle infinie, c'est d'ailleurs une des nombreuses craintes des programmeurs.

Et c'est là qu'on retrouve… les conditions !

Quand on crée une boucle, on indique toujours une condition !

Cette condition signifiera « Répète la boucle tant que cette condition est vraie ».

Comme je vous l'ai dit, il y a plusieurs manières de s'y prendre. Voyons voir sans plus tarder comment on réalise une boucle de type while en C.

Créez un boucle  while

Voici comment on construit une boucle while  :

while (/* Condition */)
{
    // Instructions à répéter
}
while signifie « Tant que ».

On dit donc à l'ordinateur :

« Tant que la condition est vraie, répète les instructions entre accolades ».

Faisons un test simple : on va demander à l'utilisateur de taper le nombre 47. Tant qu'il n'a pas tapé le nombre 47, on lui redemande le nombre. Le programme ne pourra s'arrêter que si l'utilisateur tape le nombre 47 (je sais, je sais, je suis diabolique) :

int nombreEntre = 0;

while (nombreEntre != 47)
{
    printf("Tapez le nombre 47 ! ");
    scanf("%d", &nombreEntre);
}

Voici maintenant le test que j'ai fait (j'ai fait exprès de me tromper 2-3 fois avant de taper le bon nombre) :


Tapez le nombre 47 ! 10
Tapez le nombre 47 ! 27
Tapez le nombre 47 ! 40
Tapez le nombre 47 ! 47

Cette boucle while se répète donc tant qu'on n'a pas tapé 47.

Maintenant, essayons quelque chose de plus intéressant : on veut que notre boucle se répète un certain nombre de fois. On va pour cela créer une variable compteur qui vaudra 0 au début du programme et que l'on va incrémenter au fur et à mesure.

C'est quoi déjà, l'incrémentation ?

Ça consiste à ajouter 1 à la variable en faisant variable++;.

Regardez attentivement ce bout de code et, surtout, essayez de le comprendre :

int compteur = 0;

while (compteur < 10)
{
    printf("Bienvenue sur OpenClassrooms !\n");
    compteur++;
}

Résultat :

Bienvenue sur OpenClassrooms !
Bienvenue sur OpenClassrooms !
Bienvenue sur OpenClassrooms !
Bienvenue sur OpenClassrooms !
Bienvenue sur OpenClassrooms !
Bienvenue sur OpenClassrooms !
Bienvenue sur OpenClassrooms !
Bienvenue sur OpenClassrooms !
Bienvenue sur OpenClassrooms !
Bienvenue sur OpenClassrooms !

Ce code répète 10 fois l'affichage de "Bienvenue sur OpenClassrooms !".

Comment ça marche exactement ?

Au départ, on a une variable compteur initialisée à 0. Elle vaut donc 0 au début du programme.

La boucle while ordonne la répétition TANT QUE compteur est inférieur à 10. Comme compteur vaut 0 au départ, on rentre dans la boucle.

On affiche la phrase « Bienvenue sur OpenClassrooms ! » via un printf.

Grâce à compteur++; , on incrémente la valeur de la variable compteur (qui valait 0, elle vaut maintenant 1).

On arrive à la fin de la boucle (accolade fermante) : on repart donc au début, au niveau du while pour refaire le test : « Est-ce que compteur est toujours inférieure à 10 ? ». Oui car compteur vaut 1. On recommence donc les instructions de la boucle.

Et ainsi de suite : compteur va valoir progressivement 0, 1, 2, 3… 8, 9, et 10. Lorsque compteur vaut 10, la condition compteur < 10 est fausse. Comme l'instruction est fausse, on sort de la boucle.

On pourrait d'ailleurs voir que la variable compteur augmente au fur et à mesure dans la boucle, en l'affichant dans le printf:


int compteur = 0;

while (compteur < 10)
{
    printf("La variable compteur vaut %d\n", compteur);
    compteur++;
}

La variable compteur vaut 0
La variable compteur vaut 1
La variable compteur vaut 2
La variable compteur vaut 3
La variable compteur vaut 4
La variable compteur vaut 5
La variable compteur vaut 6
La variable compteur vaut 7
La variable compteur vaut 8
La variable compteur vaut 9

Voilà : si vous avez compris ça, vous avez tout compris !

Vous pouvez vous amuser à augmenter la limite du nombre de boucles : < 100  au lieu de < 10. Cela m'aurait été d'ailleurs utile plus jeune pour rédiger les punitions que je devais réécrire 100 fois.

Attention aux boucles infinies !

Lorsque vous créez une boucle, assurez-vous qu'elle puisse s'arrêter à un moment ! Si la condition est toujours vraie, votre programme ne s'arrêtera jamais !

Voici un exemple de boucle infinie :

while (1)
{
    printf("Boucle infinie\n");
}

Souvenez-vous des booléens : 1 = vrai, 0 = faux. Ici, la condition est toujours vraie, ce programme affichera donc « Boucle infinie » sans arrêt !

Que faire si on a lancé une boucle infinie par erreur ?

Pour arrêter un tel programme sous Windows, vous n'avez pas d'autre choix que de fermer la console en cliquant sur la croix en haut à droite. Sous mac ou Linux, faites Ctrl + C.

Nous allons voir dans la vidéo suivante comment créer votre première boucle while en faisant attention à ne pas tomber dans le piège de la boucle infinie :

Créez une boucle  do… while

Ce type de boucle est moins utilisé. La seule chose qui change par rapport à une boucle while  , c'est la position de la condition : au lieu d'être au début de la boucle, la condition est à la fin :

int compteur = 0;

do
{
    printf("Bienvenue sur OpenClassrooms !\n");
    compteur++;
} while (compteur < 10);

Qu'est-ce que ça change ?

La boucle while peut très bien ne jamais être exécutée si la condition est fausse dès le départ. Par exemple, si on avait initialisé le compteur à 50, la condition aurait été fausse dès le début, et on ne serait jamais rentré dans la boucle.

Pour la boucle do… while, c'est différent : cette boucle s'exécutera toujours au moins une fois. En effet, le test se fait à la fin, comme vous pouvez le voir. Si on initialise compteur à 50, la boucle s'exécutera une fois.

Il est donc parfois utile de faire des boucles de ce type, pour s'assurer que l'on rentre au moins une fois dans la boucle.

Attention : il y a un  ;  à la fin de la boucle do… while .

N'oubliez pas d'en mettre un après le while, sinon votre programme plantera à la compilation !

La vidéo montre la différence entre la boucle while et la boucle do...while :

Créez une boucle  for

En théorie, while permet de réaliser toutes les boucles que l'on veut.

Toutefois, comme switch pour les conditions, il est parfois utile d'avoir un autre système de boucle, plus « condensé », plus rapide à écrire. Pour cela, on a les boucles  for  .

Sachez que vous utiliserez certainement autant de for que de while  , si ce n'est plus ; il vous faudra donc savoir manipuler ces deux types de boucles.

Pour rappel, voici un exemple de boucle while que nous avons vu tout à l'heure :

int compteur = 0;

while (compteur < 10)
{
    printf("Bienvenue sur OpenClassrooms !\n");
    compteur++;
}

Voici maintenant l'équivalent en boucle for :

int compteur;

for (compteur = 0 ; compteur < 10 ; compteur++)
{
    printf("Bienvenue sur OpenClassrooms !\n");
}

Quelles différences y a-t-il ?

  - On n'a pas initialisé la variable compteur à 0 dès sa déclaration (mais on aurait pu le faire).

  - Il y a beaucoup de choses entre les parenthèses après for  (nous allons détailler ça après).

  - Il n'y a plus de compteur++;  dans la boucle.

Intéressons-nous à ce qui se trouve entre les parenthèses, car c'est là que réside tout l'intérêt de la boucle for : il y a trois instructions condensées, séparées par un point-virgule :

  1. L'initialisation : cette première instruction est utilisée pour préparer notre variable compteur. Dans 
     notre cas, on initialise la variable à 0.

  2. La condition : comme pour la boucle while, c'est la condition qui dit si la boucle doit être répétée ou 
     non. Tant que la condition est vraie, la boucle for continue.

  3. L'incrémentation : cette dernière instruction est exécutée à la fin de chaque tour de boucle pour mettre 
     à jour la variable compteur. La plupart du temps, on fera une incrémentation, mais on peut aussi faire 
     une décrémentation (variable--), ou encore n'importe quelle autre opération (variable += 2; pour avancer 
     de 2 en 2, par exemple).

Bref ! for n'est rien d'autre qu'un condensé. 

L’instruction  break  permet d'arrêter l’exécution d’une boucle, elle permet de sortir prématurément de la boucle et de lancer l’instruction suivante.

L’instruction  continue  permet de passer directement à l’itération suivante sans exécuter les lignes de l’itération courante.

Pour terminer ce chapitre, je vous propose une dernière vidéo qui montre comment utiliser une boucle  for   , et les erreurs à éviter :

En résumé

  - Les boucles sont des structures qui nous permettent de répéter une série d'instructions plusieurs fois.

  - Il existe plusieurs types de boucles : while, do… while et for. Certaines sont plus adaptées que d'autres 
    selon les cas.

  - for est probablement celle qu'on utilise le plus. On y fait très souvent des incrémentations ou des 
    décrémentations de variables.

Vous êtes maintenant au point avec l’ensemble des concepts de base du langage. Voyons maintenant une notion très importante de la programmation. Comment créer une fonction ?

##############################################################################################################

Découpez votre programme en fonctions

Nous allons apprendre à organiser notre code en fonctions. Il s'agit en fait de découper nos programmes en petits morceaux. Chaque petit morceau sera ce qu'on appelle une fonction.

Une fonction exécute des actions et renvoie un résultat. C'est un morceau de code qui sert à faire quelque chose de précis. On dit qu'une fonction possède une entrée et une sortie.

Créez une fonction

Voilà comment on représente une fonction, schématiquement (c'est un modèle à connaître !) :

type nomFonction(parametres)
{
    // Insérez vos instructions ici
}


type  (correspond à la sortie) : c'est le type de la fonction.

Si la fonction renvoie un nombre décimal, vous mettrez sûrement double  ; si elle renvoie un entier, vous mettrez int ou long par exemple. Mais il est aussi possible de créer des fonctions qui ne renvoient rien, elles seront alors de type void  ("vide", en français).

nomFonction  : c'est le nom de votre fonction.

Vous pouvez appeler votre fonction comme vous voulez, du moment que vous respectez les mêmes règles que pour les variables (pas d'accents, pas d'espaces, etc.).

parametres  (correspond à l'entrée) : ce sont les paramètres de la fonction.

Ils sont entre parenthèses. Ce sont en fait des valeurs avec lesquelles la fonction va travailler.

Maintenant que vous savez ça, voyons un exemple pratique ! Disons que :

  - notre fonction triple reçoit un nombre entier de type  int  ;

  - et qu'elle renvoie un nombre entier également de type int.

Elle calcule le triple du nombre qu'on lui donne :

int triple(int nombre)
{
    int resultat = 0;

    resultat = 3 * nombre;  // On multiplie le nombre fourni par 3
    return resultat;       // On retourne la variable resultat qui vaut le triple de nombre
}

La fonction est de type int. Elle doit donc renvoyer une valeur de type int.

Entre les parenthèses, vous avez les variables que la fonction reçoit. Ici, notre fonction triple reçoit une variable de type int appelée nombre.

La ligne qui donne pour consigne de "renvoyer une valeur" est celle qui contient le return. Cette ligne se trouve généralement à la fin de la fonction, après les calculs. 

Ce code signifie pour la fonction :

« Arrête-toi là et renvoie le nombre resultat».

Cette variable resultat DOIT être de type int, car la fonction renvoie un int .

La variable resultat est déclarée (= créée) dans la fonction triple. Cela signifie qu'elle n'est utilisable que dans cette fonction, et pas dans une autre (comme la fonction main par exemple). C'est donc une variable propre à la fonction triple.

Mais est-ce la façon la plus courte d'écrire notre fonction triple  ?

Non, on peut faire tout cela en une ligne :

int triple(int nombre)
{
    return 3 * nombre;
}

Cette fonction fait exactement la même chose que la fonction de tout à l'heure, elle est juste plus rapide à écrire.

Généralement, vos fonctions contiendront plusieurs variables pour effectuer leurs calculs et leurs opérations ; rares seront les fonctions aussi courtes que triple.

Affectez (ou non) des paramètres à une fonction

Vous pouvez envoyer autant de paramètres que vous le voulez. Vous pouvez aussi n'envoyer aucun paramètre à la fonction, mais ça se fait plus rarement.

Affectez plusieurs paramètres à une fonction

Notre fonction triple contient un paramètre, mais il est possible de créer des fonctions acceptant plusieurs paramètres, comme par exemple une fonction addition qui additionne deux nombres a et b  :

int addition(int a, int b)
{
    return a + b;
}

Il suffit de séparer les différents paramètres par une virgule, comme vous le voyez.

N'affectez aucun paramètre à fonction

Certaines fonctions, plus rares, ne prennent aucun paramètre en entrée. Ces fonctions feront généralement toujours la même chose. En effet, si elles n'ont pas de nombres sur lesquels travailler, vos fonctions serviront juste à effectuer certaines actions, comme afficher du texte à l'écran. Et encore, ce sera forcément toujours le même texte, puisque la fonction ne reçoit aucun paramètre susceptible de modifier son comportement !

Imaginons une fonction bonjour qui affiche juste "Bonjour" à l'écran :

void bonjour()
{
    printf("Bonjour");
}

Je n'ai rien mis entre parenthèses car la fonction ne prend aucun paramètre. De plus, j'ai utilisé le type void dont je vous ai parlé plus haut.

En effet, ma fonction n'a pas non plus de return : elle ne retourne rien.

Une fonction qui ne retourne rien est de type void.

Appelez une fonction

Nous allons reprendre notre fonction triple  (décidément, je l'aime bien) pour calculer le triple d'un nombre.

Pour le moment, écrivez la fonction triple AVANT la fonction main  (si vous la placez après, ça ne marchera pas, je vous expliquerai pourquoi par la suite).

Testez donc ce code pour comprendre :

#include <stdio.h>
#include <stdlib.h>

int triple(int nombre)
{
    return 3 * nombre;
}    

int main(int argc, char *argv[])
{
    int nombreEntre = 0, nombreTriple = 0;
    
    printf("Entrez un nombre... ");
    scanf("%d", &nombreEntre);
    
    nombreTriple = triple(nombreEntre);
    printf("Le triple de ce nombre est %d\n", nombreTriple);
    
    return 0;
}

Notre programme commence par la fonction main :

  1. On demande à l'utilisateur d'entrer un nombre.

  2. On envoie ce nombre qu'il a entré à la fonction triple  .

  3. Et on récupère le résultat dans la variable nombreTriple  .

Regardez en particulier cette ligne, c'est la plus intéressante car c'est l'appel de la fonction :

  1.nombreTriple = triple(nombreEntre);

Entre parenthèses, on envoie à la fonction triple une variable en entrée (c'est le nombre sur lequel elle va travailler).

Cette fonction renvoie une valeur qu'on récupère dans la variable nombreTriple  .

Dans cette ligne de code, on ordonne donc à l'ordinateur :

« Demande à la fonction triple de me calculer le triple de nombreEntre  ,

et stocke le résultat dans la variable nombreTriple  ».

Dans la vidéo suivante, nous allons reprendre le même exemple, et voir les différentes étapes pour créer la fonction  triple  et l’appeler dans le  main  :

Comprenez le sens de lecture d'une fonction

Le code ci-dessous est commenté de manière un peu particulière. C'est pour vous montrer dans quel ordre le code est "lu". Commencez donc par lire la ligne commentée 1, puis 2, puis 3 (vous avez compris 🤣) :

#include <stdio.h>
#include <stdlib.h>

int triple(int nombre) // 6
{
    return 3 * nombre; // 7
}    

int main(int argc, char *argv[]) // 1
{
    int nombreEntre = 0, nombreTriple = 0; // 2
    
    printf("Entrez un nombre... "); // 3
    scanf("%d", &nombreEntre); // 4
    
    nombreTriple = triple(nombreEntre); // 5
    printf("Le triple de ce nombre est %d\n", nombreTriple); // 8
    
    return 0; // 9
}

Voici ce qui se passe, ligne par ligne.

  1. Le programme commence par la fonction main.

  2. Il lit les instructions dans la fonction, une par une, dans l'ordre.

  3. Il lit l'instruction suivante et fait ce qui est demandé (printf).

  4. De même, il lit l'instruction et fait ce qui est demandé (scanf).

  5. Il lit l'instruction… Ah ! On appelle la fonction triple, on doit donc sauter à la ligne de la fonction 
     triple plus haut.

  6. On saute à la fonction triple et on récupère un paramètre (nombre).

  7. On fait des calculs sur le nombre et on termine la fonction :return signifie la fin de la fonction, et 
     permet d'indiquer le résultat à renvoyer.

  8. On retourne dans main pour prendre l'instruction suivante.

  9. Un return : la fonction  main  se termine, et donc le programme est terminé.

Si vous avez compris dans quel ordre l'ordinateur lit les instructions, vous avez déjà compris le principal.

Parfois, une fonction ne prend aucun paramètre en entrée ; ou au contraire elle en prend plusieurs (je vous ai expliqué ça un peu plus haut).

De même, parfois une fonction renvoie une valeur, parfois elle ne renvoie rien (dans ce cas, il n'y a pas de return).

Voici un exemple d'utilisation du programme :

Entrez un nombre... 10
Le triple de ce nombre est 30

Vous n'êtes pas obligé de stocker le résultat d'une fonction dans une variable ! Vous pouvez directement envoyer le résultat de la fonction triple à une autre fonction, comme si triple(nombreEntre) était une variable.

Regardez bien ceci, c'est le même code mais il y a un changement au niveau du dernier printf. De plus, on n'a pas déclaré de variable nombreTriple car on ne s'en sert plus :

#include <stdio.h>
#include <stdlib.h>

int triple(int nombre)
{
    return 3 * nombre;
}    

int main(int argc, char *argv[])
{
    int nombreEntre = 0;
    
    printf("Entrez un nombre... ");
    scanf("%d", &nombreEntre);

    // Le résultat de la fonction est directement envoyé au printf et n'est pas stocké dans une variable
    printf("Le triple de ce nombre est %d\n", triple(nombreEntre));
     
    return 0;
}


triple(nombreEntre)  est directement envoyé au printf.

Que fait l'ordinateur quand il tombe sur cette ligne ?

Il voit que la ligne commence par printf, il va donc appeler la fonction printf.

Il envoie à la fonction printf tous les paramètres qu'on lui donne :

  1. Le premier paramètre est le texte à afficher.

  2. Et le second est un nombre.

Votre ordinateur voit qu'il doit d'abord appeler la fonction triple pour envoyer ce nombre à la fonction printf :

  1. Il appelle triple.

  2. Il effectue les calculs de triple.

  3. Et une fois qu'il a le résultat, il l'envoie directement dans la fonction printf !

C'est un peu une imbrication de fonctions. Et le plus fin dans tout ça, c'est qu'une fonction peut en appeler une autre à son tour : notre fonction triple pourrait appeler une autre fonction, qui elle-même appellerait une autre fonction, etc. C'est ça le principe de la programmation en C : tout est combiné, comme dans un jeu de LEGO.

Le plus dur sera d'écrire vos fonctions.

Une fois que vous les aurez écrites, vous n'aurez plus qu'à appeler les fonctions sans vous soucier des calculs qu'elles peuvent bien faire à l'intérieur.

Ça va permettre de simplifier considérablement l'écriture de nos programmes et ça, croyez-moi, on en aura bien besoin !

Intégrez le principe en pratique avec ces exemples
Je vais donc maintenant vous montrer plusieurs exemples d'utilisation de fonctions, pour que vous ayez une idée de leur intérêt. Je vais m'efforcer de faire des cas différents à chaque fois, pour que vous puissiez avoir des exemples de tous les types de fonctions qui peuvent exister.

Je ne vous apprendrai rien de nouveau, mais ce sera l'occasion de voir des exemples pratiques. Si vous avez déjà compris tout ce que j'ai expliqué avant, c'est très bien, et normalement aucun des exemples qui vont suivre ne devrait vous surprendre.

Analysez une fonction qui prend 1 paramètre

Intéresserons-nous à une fonction qui ne renvoie rien (pas de sortie). Imaginons une fonction qui copie des lignes, comme les punitions que l'on avait lorsqu'on était petit :

void punition(int nombreDeLignes)
{
    int i;
    
    for (i = 0 ; i < nombreDeLignes ; i++)
    {
        printf("Je ne dois pas copier sur mon voisin\n");
    }    
}    

int main(int argc, char *argv[])
{    
    punition(10);
    
    return 0;
}

C'est une fonction qui affiche le même message à l'écran autant de fois qu'on lui demande. Elle prend un paramètre en entrée : le nombre de fois où il faut afficher la punition.

Résultat :

Je ne dois pas copier sur mon voisin
Je ne dois pas copier sur mon voisin
Je ne dois pas copier sur mon voisin
Je ne dois pas copier sur mon voisin
Je ne dois pas copier sur mon voisin
Je ne dois pas copier sur mon voisin
Je ne dois pas copier sur mon voisin
Je ne dois pas copier sur mon voisin
Je ne dois pas copier sur mon voisin
Je ne dois pas copier sur mon voisin

On a ici affaire à une fonction qui ne renvoie aucune valeur. Cette fonction se contente juste d'effectuer des actions (ici, elle affiche des messages à l'écran).

Il aurait été bien plus intéressant de créer une fonction punition qui s'adapte à n'importe quelle sanction. On lui aurait envoyé deux paramètres : le texte à répéter, et le nombre de fois qu'il doit être répété.

Le problème, c'est qu'on ne sait pas encore gérer le texte en C (au cas où vous n'auriez pas vu, je vous rappelle qu'on n'a fait que manipuler des variables contenant des nombres depuis le début du cours !). D'ailleurs à ce sujet, je vous annonce que nous ne tarderons pas à apprendre à utiliser des variables qui retiennent du texte. C'est plus compliqué qu'il n'y paraît, et on ne pouvait pas l'apprendre dès le début du cours !

Analysez une fonction qui prend 2 paramètres en entrée

Imaginons une fonction qui calcule l'aire d'un rectangle. L'aire d'un rectangle est facile à calculer :largeur * hauteur.
Notre fonction nommée aireRectangle va prendre deux paramètres : la largeur et la hauteur pour renvoyer l'aire :

double aireRectangle(double largeur, double hauteur)
{
    return largeur * hauteur;
}    

int main(int argc, char *argv[])
{    
    printf("Rectangle de largeur 5 et hauteur 10. Aire = %f\n", aireRectangle(5, 10));
    printf("Rectangle de largeur 2.5 et hauteur 3.5. Aire = %f\n", aireRectangle(2.5, 3.5));
    printf("Rectangle de largeur 4.2 et hauteur 9.7. Aire = %f\n", aireRectangle(4.2, 9.7));
      
    return 0;
}


Rectangle de largeur 5 et hauteur 10. Aire = 50.000000
Rectangle de largeur 2.5 et hauteur 3.5. Aire = 8.750000
Rectangle de largeur 4.2 et hauteur 9.7. Aire = 40.740000

Pourrait-on afficher directement la largeur, la hauteur et l'aire dans la fonction ?

Bien sûr ! Dans ce cas, la fonction ne renverrait plus rien, elle se contenterait de calculer l'aire et de l'afficher immédiatement :

void aireRectangle(double largeur, double hauteur)
{
    double aire = 0;
    
    aire = largeur * hauteur;
    printf("Rectangle de largeur %f et hauteur %f. Aire = %f\n", largeur, hauteur, aire);
}    

int main(int argc, char *argv[])
{    
    aireRectangle(5, 10);
    aireRectangle(2.5, 3.5);
    aireRectangle(4.2, 9.7);
       
    return 0;
}

printf est à l'intérieur de la fonction aireRectangle et produit le même affichage que tout à l'heure. C'est juste une façon différente de procéder.

Analysez une fonction qui ne prend aucun paramètre en entrée

Ce code est plus intéressant et concret : on crée une fonction menu qui ne prend aucun paramètre en entrée. Cette fonction se contente d'afficher le menu, et demande à l'utilisateur de faire un choix. La fonction renvoie le choix de l'utilisateur.

int menu()
{
    int choix = 0;
    
    while (choix < 1 || choix > 4)
    {
        printf("Menu :\n");
        printf("1 : Poulet de dinde aux escargots rotis a la sauce bearnaise\n");
        printf("2 : Concombres sucres a la sauce de myrtilles enrobee de chocolat\n");
        printf("3 : Escalope de kangourou saignante et sa gelee aux fraises poivree\n");
        printf("4 : La surprise du Chef (j'en salive d'avance...)\n");
        printf("Votre choix ? ");
        scanf("%d", &choix);
    }    
    
    return choix;
}    

int main(int argc, char *argv[])
{    
    switch (menu())
    {
        case 1:
            printf("Vous avez pris le poulet\n");
            break;
        case 2:
            printf("Vous avez pris les concombres\n");
            break;
        case 3:
            printf("Vous avez pris l'escalope\n");
            break;
        case 4:
            printf("Vous avez pris la surprise du Chef. Vous etes un sacre aventurier dites donc !\n");
            break;    
    }
       
    return 0;
}

La fonction menu affiche à nouveau le menu tant que l'utilisateur n'a pas entré un nombre compris entre 1 et 4. Comme ça, aucun risque que la fonction renvoie un nombre qui ne figure pas au menu !

Dans le main, vous avez vu qu'on fait un switch(menu())  : une fois que la fonction menu()est terminée, elle renvoie le choix de l'utilisateur directement dans le switch. C'est une méthode rapide et pratique.


