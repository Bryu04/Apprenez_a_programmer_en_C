                     Partie 2 :Organisez votre code grâce aux conditions, boucles et fonctions


Structurez votre code avec les conditions

Nous avons vu comment créer des variables, nous allons maintenant nous intéresser aux conditions. Elles permettent de tester des variables. Sans conditions, nos programmes informatiques feraient toujours la même chose !

Utilisez des conditions if... else

On peut par exemple dire :

"si la variable machin est égale à 50, fais ceci."

Mais ce serait dommage de ne pouvoir tester que l'égalité ! Il faudrait aussi pouvoir tester si la variable est inférieure à 50, inférieure ou égale à 50, supérieure, supérieure ou égale… Ne vous inquiétez pas, le C a tout prévu !

Avant de voir comment on écrit une condition de type if... else  en C, il faut donc que vous connaissiez les symboles de base. Voici un tableau récapitulatif à connaître par cœur :

Symbole          Signification

==               est égal à

>                est supérieur à

<                est inférieur à

>=               est supérieur ou égal à

<=               est inférieur ou égal à

!=               est différent de

Il y a bien deux symboles ==  pour tester l'égalité. Une erreur courante que font les débutants est de ne mettre qu'un symbole =  , ce qui n'a pas la même signification en C. 

Ouvrez une condition avec un if 

Nous allons faire un test simple, qui va dire à l'ordinateur :

"SI la variable vaut ça, ALORS fais ceci".

En anglais, le mot "si" se traduit par if.

On l'utilise en langage C pour introduire une condition.

  1. Commencez par écrire if.

  2. Ouvrez des parenthèses (à l'intérieur de ces parenthèses on écrit une condition).

  3. Ouvrez une accolade {  et fermez-la un peu plus loin}. Tout ce qui se trouve à l'intérieur des accolades 
     sera exécuté uniquement si la condition est vérifiée.

Cela nous donne :

if (/* Votre condition */)
{
  // Instructions à exécuter si la condition est vraie
}

À la place de mon commentaire "Votre condition", on va écrire une condition pour tester une variable. Pour s'entraîner, on va tester si vous êtes majeur avec une variable  age  , c'est-à-dire "vous êtes majeur si votre âge est supérieur ou égal à 18" :

if (age >= 18)
{
  printf ("Vous etes majeur !");
}

Rappel : le symbole >=  signifie « supérieur ou égal ».

S'il n'y a qu'une instruction entre les accolades (comme c'est le cas ici), alors celles-ci deviennent facultatives. Je recommande néanmoins de toujours mettre des accolades pour des raisons de clarté.

Si vous voulez tester les codes précédents pour voir comment le if fonctionne, il faudra placer le if à l'intérieur d'une fonction main  , et ne pas oublier de déclarer une variable age à laquelle on donnera la valeur de notre choix :

#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
    int age = 20;
  
    if (age >= 18)
    {
      printf ("Vous etes majeur !\n");
    }
     
    return 0;
}

Ici, la variable age vaut 20, donc le "Vous êtes majeur !" s'affichera.

Essayez de changer la valeur initiale de la variable pour voir. Mettez par exemple 15 : la condition sera fausse, et donc "Vous êtes majeur !" ne s'affichera pas cette fois.

Exécutez une instruction alternative avec else 

Maintenant, allons plus loin : si le test n'a pas marché (il est faux), on va dire à l'ordinateur d'exécuter d'autres instructions.

En français, nous allons donc écrire quelque chose qui ressemble à :

"SI la variable vaut ça, ALORS fais ceci,

SINON fais cela".

Il suffit de rajouter else après l'accolade fermante du if :

if (age >= 18) // Si l'âge est supérieur ou égal à 18
{
  printf ("Vous etes majeur !");
}
else // Sinon...
{
  printf ("Ah c'est bete, vous etes mineur !");
}

Si la variable age est supérieure ou égale à 18, on affiche le message "Vous êtes majeur !", sinon on affiche "Vous êtes mineur".

Conditionnez l'instruction alternative avec else if 

Il est possible de faire un autre test si le premier test n'a pas marché.  On demande alors à l'ordinateur :

"SI la variable vaut ça ALORS fais ceci,

SINON SI la variable vaut ça ALORS fais ça,

SINON fais cela".

else if  ( ou "sinon si") se place entre le if et le else :

if (age >= 18) // Si l'âge est supérieur ou égal à 18
{
  printf ("Vous etes majeur !");
}
else if ( age > 4 ) // Sinon, si l'âge est au moins supérieur à 4 
{
  printf ("Bon t'es pas trop jeune quand meme...");
}
else // Sinon...
{
  printf ("Aga gaa aga gaaa"); // Langage bébé, vous pouvez pas comprendre
}

L'ordinateur fait les tests dans l'ordre :

  1. D'abord il teste le premier if: si la condition est vraie, alors il exécute ce qui se trouve entre les 
     premières accolades.

  2. Sinon, il va au « sinon si » et fait à nouveau un test : si ce test est vrai, alors il exécute les 
     instructions correspondantes entre accolades.

  3. Enfin, si aucun des tests précédents n'a marché, il exécute les instructions du « sinon ».

Notez que l'on peut mettre autant de else if que l'on veut.

On peut donc écrire :

SI la variable vaut ça,
ALORS fais ceci,
SINON SI la variable vaut ça ALORS fais ça,
SINON SI la variable vaut ça ALORS fais ça,
SINON SI la variable vaut ça ALORS fais ça,
SINON fais cela.

Vous avez encore quelques doutes sur l’utilisation du if, else if et else ? Pas de panique, dans la vidéo suivante, nous revoit tout, étape par étape :

Testez plusieurs conditions à la fois

Il peut aussi être utile de faire plusieurs tests à la fois dans votre if.

Pour cela, il va falloir utiliser de nouveaux symboles :

Symbole    Signification

&&           ET

||           OU

!            NON

Ajoutez une contrainte "ET" avec  &&

On peut vouloir tester si l'âge est supérieur à 18 ET si l'âge est inférieur à 25.

Pour cela, il vous faudra écrire :

  1.if (age > 18 && age < 25)

Ajoutez une contrainte "OU" avec  ||

Ce signe n'est pas facilement accessible sur nos claviers. Sur un clavier AZERTY français, il faudra faire Alt Gr + 6 ; sur un clavier belge, Alt Gr + &.

Imaginons un programme qui décide si une personne a le droit d'ouvrir un compte en banque. Pour ouvrir un compte en banque, il vaut mieux ne pas être trop jeune, ou bien avoir beaucoup d'argent. Notre test pourrait être :

if (age > 30 || argent > 100000)
{
    printf("Bienvenue chez PicsouBanque !");
}
else
{
    printf("Hors de ma vue, miserable !");
}

Ce test n'est valide que si la personne a plus de 30 ans ou si elle possède plus de 100 000 euros !

Testez l'opposée d'une condition avec  !

En informatique, le point d'exclamation signifie « non ».

Vous devez mettre ce signe avant votre condition pour dire « si cela n'est pas vrai » :

  1.if (!(age < 18))

Cela pourrait se traduire par « si la personne n'est pas mineure ».

Si on avait enlevé le !  devant, cela aurait signifié l'inverse : « si la personne est mineure ».

Et puisqu'on y est, je voudrais vous lister quelques erreurs courantes du débutant.

Évitez de faire ces erreurs

Oublier les deux signes  ==
Pour tester si la personne a tout juste 18 ans, il faut écrire if (age == 18) avec  ==  .
Si vous ne mettez qu'un seul =, alors votre variable prendra la valeur 18. Ce qu'on veut faire ici, c'est tester la valeur de la variable, non pas la changer. Faites très attention à cela !

Terminer une condition avec un  ;
Un if est une condition. On met un  ;  à la fin d'une instruction, pas d'une condition.

Faites des conditions de type vrai/faux avec les booléens

Avant d'entrer dans les explications, voici un code source que je vous propose de tester :

if (1)
{
    printf("C'est vrai");
}
else
{
    printf("C'est faux");
}

Résultat :

C'est vrai

Mais… Il n'y a pas de condition dans le if  , juste un nombre. Qu'est-ce que ça veut dire ?

Si, ça en a, vous allez comprendre. Faites un autre test en remplaçant 1 par 0 :

if (0)
{
    printf("C'est vrai");
}
else
{
    printf("C'est faux");
}

Résultat :

C'est faux

Faites maintenant d'autres tests en remplaçant le 0 par n'importe quel autre nombre entier, comme 4, 15, 226, ou encore -10.

Qu'est-ce qu'on vous répond à chaque fois ? On vous répond : « C'est vrai ».

Si on met un 0, le test est considéré comme faux.

Si on met un 1 ou n'importe quel autre nombre, le test est vrai.

Ci-dessous, le test que vous faites est age >= 18.

  1.if (age >= 18)

Par exemple, si age vaut 23,  alors le test est vrai, et l'ordinateur remplace, en quelque sorte, age >= 18 par 1. Ensuite, l'ordinateur obtient (dans sa tête) un if (1). Quand le nombre est 1, comme on l'a vu, l'ordinateur dit que la condition est vraie, donc il affiche « C'est vrai » ! Si la condition est fausse, il remplace age >= 18 par le nombre 0, et du coup la condition est fausse : l'ordinateur va lire les instructions du else.

Testez maintenant autre chose : envoyez le résultat de votre condition dans une variable, comme si c'était une opération (car pour l'ordinateur, c'est une opération !).


  1.int age = 20;
  2.int majeur = 0;
  3.
  4.majeur = age >= 18;
  5.printf("Majeur vaut : %d\n", majeur);

Comme vous le voyez, la condition age >= 18 a renvoyé le nombre 1 car elle est vraie. Du coup, notre variable majeur vaut 1 (on vérifie d'ailleurs cela grâce à un printf qui montre bien qu'elle a changé de valeur).

Faites le même test en mettant age == 10  , par exemple. Cette fois, majeur vaudra "0".

On dit qu'une variable à laquelle on fait prendre les valeurs 0 et 1 est un booléen. Et aussi que : 0 = faux ; 1 = vrai.

Pour être tout à fait exact, 0 = faux et tous les autres nombres valent vrai (on a eu l'occasion de le tester plus tôt). Ceci dit, pour simplifier les choses on va se contenter de n'utiliser que les nombres 0 et 1, pour dire si "quelque chose est faux ou vrai".

En langage C, il n'existe pas de type de variable "booléen". Donc, on est obligé d'utiliser un type entier comme int pour gérer les booléens.

Souvent, on fera un test if sur une variable booléenne :

  1.int majeur = 1;
  2.
  3.if (majeur)
  4.{
  5.    printf("Vous etes majeur !");
  6.}
  7.else
  8.{
  9.    printf("Vous etes mineur");
  10.}

Comme  majeur  vaut "1", la condition est vraie, donc on affiche "Vous êtes majeur !".

Ce qui est très pratique, c'est que la condition peut être lue facilement par un être humain. On voit if (majeur)  , ce qui peut se traduire par "si vous êtes majeur". Les tests sur des booléens sont donc faciles à lire et à comprendre, pour peu que vous ayez donné des noms clairs à vos variables.

Tenez, voici un autre test imaginaire :

  1.if (majeur && vaccin)

Ce test signifie "si vous êtes majeur ET que vous êtes vacciné".

vaccin est une autre variable booléenne qui vaut "1" si vous êtes vacciné, et "0" si vous ne l'êtes pas ! Bravo, vous avez tout compris !

Petite question : si on fait le test if (majeur == 1), ça marche aussi, non ?

Tout à fait. Mais le principe des booléens, c'est justement de raccourcir l'expression du if  , et de la rendre plus lisible. Avouez que if (majeur)ça se comprend très bien, non ?

Retenez donc :

  - Si votre variable est censée contenir un nombre (comme un âge), faites un test sous la forme if (variable 
    == 1). Si au contraire votre variable est censée contenir un booléen (c'est-à-dire soit 1 soit 0 pour dire 
    vrai ou faux), faites un test sous la forme if (variable).

Optimisez votre code avec la condition  switch
if... else est le type de condition le plus souvent utilisé car il permet de gérer tous les cas. En fait, il n'y a pas 36 façons de faire une condition en C.

Cela dit, if... else peut s'avérer quelque peu… répétitif. Prenons cet exemple :

if (age == 2)
{
    printf("Salut bebe !");
}
else if (age == 6)
{
    printf("Salut gamin !");
}
else if (age == 12)
{
    printf("Salut jeune !");
}
else if (age == 16)
{
    printf("Salut ado !");
}
else if (age == 18)
{
    printf("Salut adulte !");
}
else if (age == 68)
{
    printf("Salut papy !");
}
else
{
    printf("Je n'ai aucune reponse pour ton age");
}

Construisez un switch

Pour éviter d'avoir à faire des répétitions quand on teste la valeur d'une seule et même variable, il existe une autre structure que if... else. Elle s'appelle switch !
Voici un switch basé sur l'exemple qu'on vient de voir :

switch (age)
{
case 2:
  printf("Salut bebe !");
  break;
case 6:
  printf("Salut gamin !");
  break;
case 12:
  printf("Salut jeune !");
  break;
case 16:
  printf("Salut ado !");
  break;
case 18:
  printf("Salut adulte !");
  break;
case 68:
  printf("Salut papy !");
  break;
default:
  printf("Je n'ai aucune reponse pour ton age");
  break;
}

Le principe est le suivant :

  1. Vous écrivez switch (maVariable) pour dire « je vais tester la valeur de la variable maVariable».

  2. Vous ouvrez ensuite des accolades que vous refermez tout en bas.

  3. À l'intérieur de ces accolades, vous gérez tous les cas :case 2  , case 4  , case 5  ,case 45  …

Vous devez mettre une instruction break; obligatoirement à la fin de chaque cas.

Si vous ne le faites pas, l'ordinateur lira les instructions en dessous (censées être réservées aux autres cas). break; commande en fait à l'ordinateur de "sortir" des accolades.

Enfin, le cas default correspond au else qu'on connaît bien maintenant. Si la variable ne vaut aucune des valeurs précédentes, l'ordinateur ira lire le default.

À vous de jouer !

Je crois que le moment est venu de pratiquer un peu !

En console, pour faire un menu, on fait des printf qui affichent les différentes options possibles. Chaque option est numérotée, et l'utilisateur doit entrer le numéro du menu qui l'intéresse.

Voici par exemple ce que la console devra afficher :

=== Menu ===
1. Royal Cheese
2. Mc Deluxe
3. Mc Bacon
4. Big Mac
Votre choix ?

Votre mission (si vous l'acceptez) :

  1. Reproduire ce menu à l'aide de printf.

  2. Ajouter un scanf pour enregistrer le choix de l'utilisateur dans une variable choixMenu.

  3. Faire un switch pour dire à l'utilisateur "tu as choisi le menu Royal Cheese", par exemple.

Alors, vous avez réussi ?

Je vous propose une correction dans ce screencast, et nous allons aussi pouvoir voir en bonus les bonnes pratiques pour correctement mettre en place un switch case :

Découvrez les conditions condensées : les ternaires
Il existe une troisième façon de faire des conditions, plus rare : les expressions ternaires.

Les ternaires ne sont pas du tout indispensables ; personnellement je les utilise peu, car ils peuvent rendre la lecture d'un code source un peu difficile. Cela dit, il vaut mieux les connaître pour le jour où vous tomberez sur un code plein de ternaires !

Concrètement, c'est comme un if... else, sauf qu'on fait tout tenir sur une seule ligne.

Comme un exemple vaut mieux qu'un long discours, je vais vous donner deux fois la même condition :

  1. La première avec un if... else.

  2. Et la seconde, identique, mais sous forme d'une expression ternaire.

1. Analysez cette condition en if... else 

Exemple : on a une variable booléenne majeur qui vaut vrai (1) si on est majeur, et faux (0) si on est mineur. On veut changer la valeur de la variable age en fonction du booléen, pour mettre "18" si on est majeur, "17" si on est mineur. C'est un exemple complètement stupide, je suis d'accord, mais ça me permet de vous montrer comment on peut se servir des expressions ternaires.

Voici comment faire cela avec un if... else  :

if (majeur)
  age = 18;
else
  age = 17;

Notez que j'ai enlevé les accolades, car elles sont facultatives s'il n'y a qu'une instruction.

2. Analysez cette même condition en ternaire

Voici un code qui fait exactement la même chose que le précédent, mais sous forme ternaire :

  1.age = (majeur) ? 18 : 17;

Les ternaires permettent, sur une seule ligne, de changer la valeur d'une variable en fonction d'une condition.

Ici la condition est tout simplementmajeur  , mais ça pourrait être n'importe quelle condition plus longue, bien entendu.

Un autre exemple ?

autorisation = (age >= 18) ? 1 : 0;

Le point d'interrogation permet de dire « est-ce que tu es majeur ? ». Si oui, alors on met la valeur 18 dans age. Sinon (le : signifie else ici), on met la valeur 17.

En résumé

  - Les conditions sont à la base de tous les programmes. C'est un moyen pour l'ordinateur de prendre une 
    décision en fonction de la valeur d'une variable.

  - Les mots-clés if  , else if  , else signifient respectivement « si », « sinon si », « sinon ». On peut 
    écrire autant de else if que l'on veut.

  - Un booléen est une variable qui peut avoir deux états : vrai (1) ou faux (0) (toute valeur différente de 0 
    est en fait considérée comme « vraie »). On utilise des int pour stocker des booléens, car ce ne sont en 
    fait rien d'autre que des nombres.

  - Le switch est une alternative au if quand il s'agit d'analyser la valeur d'une variable. Il permet de 
    rendre un code source plus clair si vous vous apprêtez à tester de nombreux cas. Si vous utilisez de 
    nombreux else if  , c'est en général le signe qu'un switch serait plus adapté pour rendre le code source 
    plus lisible.

  - Les ternaires sont des conditions très concises qui permettent d'affecter rapidement une valeur à une 
    variable en fonction du résultat d'un test. On les utilise avec parcimonie, car le code source a tendance 
    à devenir moins lisible avec elles.

Si vous avez compris les structures conditionnelles, je vous attends au chapitre suivant. Sinon, c’est reparti pour un tour avec ce chapitre !

##############################################################################################################

Répétez des instructions grâce aux boucles

Une boucle est une technique permettant de répéter les mêmes instructions plusieurs fois.

Comme pour les conditions, il y a plusieurs façons de réaliser des boucles. Nous allons voir trois types de boucles courantes en C :

  1. while

  2. do… while

  3. for

Dans tous les cas, le principe est le même :

Voici ce qu'il se passe, dans l'ordre :

  1. L'ordinateur lit les instructions de haut en bas (comme d'habitude).

  2. Puis, une fois arrivé à la fin de la boucle, il repart à la première instruction.

  3. Il recommence alors à lire les instructions de haut en bas…

  4. … Et il repart au début de la boucle.

Le problème dans ce système c'est que si on ne l'arrête pas, l'ordinateur est capable de répéter les instructions à l'infini ! Il n'est pas du genre à se plaindre, vous savez : il fait ce qu'on lui dit de faire… Il pourrait très bien se bloquer dans une boucle infinie, c'est d'ailleurs une des nombreuses craintes des programmeurs.

Et c'est là qu'on retrouve… les conditions !

Quand on crée une boucle, on indique toujours une condition !

Cette condition signifiera « Répète la boucle tant que cette condition est vraie ».

Comme je vous l'ai dit, il y a plusieurs manières de s'y prendre. Voyons voir sans plus tarder comment on réalise une boucle de type while en C.

Créez un boucle  while

Voici comment on construit une boucle while  :

while (/* Condition */)
{
    // Instructions à répéter
}
while signifie « Tant que ».

On dit donc à l'ordinateur :

« Tant que la condition est vraie, répète les instructions entre accolades ».

Faisons un test simple : on va demander à l'utilisateur de taper le nombre 47. Tant qu'il n'a pas tapé le nombre 47, on lui redemande le nombre. Le programme ne pourra s'arrêter que si l'utilisateur tape le nombre 47 (je sais, je sais, je suis diabolique) :

int nombreEntre = 0;

while (nombreEntre != 47)
{
    printf("Tapez le nombre 47 ! ");
    scanf("%d", &nombreEntre);
}

Voici maintenant le test que j'ai fait (j'ai fait exprès de me tromper 2-3 fois avant de taper le bon nombre) :


Tapez le nombre 47 ! 10
Tapez le nombre 47 ! 27
Tapez le nombre 47 ! 40
Tapez le nombre 47 ! 47

Cette boucle while se répète donc tant qu'on n'a pas tapé 47.

Maintenant, essayons quelque chose de plus intéressant : on veut que notre boucle se répète un certain nombre de fois. On va pour cela créer une variable compteur qui vaudra 0 au début du programme et que l'on va incrémenter au fur et à mesure.

C'est quoi déjà, l'incrémentation ?

Ça consiste à ajouter 1 à la variable en faisant variable++;.

Regardez attentivement ce bout de code et, surtout, essayez de le comprendre :

int compteur = 0;

while (compteur < 10)
{
    printf("Bienvenue sur OpenClassrooms !\n");
    compteur++;
}

Résultat :

Bienvenue sur OpenClassrooms !
Bienvenue sur OpenClassrooms !
Bienvenue sur OpenClassrooms !
Bienvenue sur OpenClassrooms !
Bienvenue sur OpenClassrooms !
Bienvenue sur OpenClassrooms !
Bienvenue sur OpenClassrooms !
Bienvenue sur OpenClassrooms !
Bienvenue sur OpenClassrooms !
Bienvenue sur OpenClassrooms !

Ce code répète 10 fois l'affichage de "Bienvenue sur OpenClassrooms !".

Comment ça marche exactement ?

Au départ, on a une variable compteur initialisée à 0. Elle vaut donc 0 au début du programme.

La boucle while ordonne la répétition TANT QUE compteur est inférieur à 10. Comme compteur vaut 0 au départ, on rentre dans la boucle.

On affiche la phrase « Bienvenue sur OpenClassrooms ! » via un printf.

Grâce à compteur++; , on incrémente la valeur de la variable compteur (qui valait 0, elle vaut maintenant 1).

On arrive à la fin de la boucle (accolade fermante) : on repart donc au début, au niveau du while pour refaire le test : « Est-ce que compteur est toujours inférieure à 10 ? ». Oui car compteur vaut 1. On recommence donc les instructions de la boucle.

Et ainsi de suite : compteur va valoir progressivement 0, 1, 2, 3… 8, 9, et 10. Lorsque compteur vaut 10, la condition compteur < 10 est fausse. Comme l'instruction est fausse, on sort de la boucle.

On pourrait d'ailleurs voir que la variable compteur augmente au fur et à mesure dans la boucle, en l'affichant dans le printf:


int compteur = 0;

while (compteur < 10)
{
    printf("La variable compteur vaut %d\n", compteur);
    compteur++;
}

La variable compteur vaut 0
La variable compteur vaut 1
La variable compteur vaut 2
La variable compteur vaut 3
La variable compteur vaut 4
La variable compteur vaut 5
La variable compteur vaut 6
La variable compteur vaut 7
La variable compteur vaut 8
La variable compteur vaut 9

Voilà : si vous avez compris ça, vous avez tout compris !

Vous pouvez vous amuser à augmenter la limite du nombre de boucles : < 100  au lieu de < 10. Cela m'aurait été d'ailleurs utile plus jeune pour rédiger les punitions que je devais réécrire 100 fois.

Attention aux boucles infinies !

Lorsque vous créez une boucle, assurez-vous qu'elle puisse s'arrêter à un moment ! Si la condition est toujours vraie, votre programme ne s'arrêtera jamais !

Voici un exemple de boucle infinie :

while (1)
{
    printf("Boucle infinie\n");
}

Souvenez-vous des booléens : 1 = vrai, 0 = faux. Ici, la condition est toujours vraie, ce programme affichera donc « Boucle infinie » sans arrêt !

Que faire si on a lancé une boucle infinie par erreur ?

Pour arrêter un tel programme sous Windows, vous n'avez pas d'autre choix que de fermer la console en cliquant sur la croix en haut à droite. Sous mac ou Linux, faites Ctrl + C.

Nous allons voir dans la vidéo suivante comment créer votre première boucle while en faisant attention à ne pas tomber dans le piège de la boucle infinie :

Créez une boucle  do… while

Ce type de boucle est moins utilisé. La seule chose qui change par rapport à une boucle while  , c'est la position de la condition : au lieu d'être au début de la boucle, la condition est à la fin :

int compteur = 0;

do
{
    printf("Bienvenue sur OpenClassrooms !\n");
    compteur++;
} while (compteur < 10);

Qu'est-ce que ça change ?

La boucle while peut très bien ne jamais être exécutée si la condition est fausse dès le départ. Par exemple, si on avait initialisé le compteur à 50, la condition aurait été fausse dès le début, et on ne serait jamais rentré dans la boucle.

Pour la boucle do… while, c'est différent : cette boucle s'exécutera toujours au moins une fois. En effet, le test se fait à la fin, comme vous pouvez le voir. Si on initialise compteur à 50, la boucle s'exécutera une fois.

Il est donc parfois utile de faire des boucles de ce type, pour s'assurer que l'on rentre au moins une fois dans la boucle.

Attention : il y a un  ;  à la fin de la boucle do… while .

N'oubliez pas d'en mettre un après le while, sinon votre programme plantera à la compilation !

La vidéo montre la différence entre la boucle while et la boucle do...while :

Créez une boucle  for

En théorie, while permet de réaliser toutes les boucles que l'on veut.

Toutefois, comme switch pour les conditions, il est parfois utile d'avoir un autre système de boucle, plus « condensé », plus rapide à écrire. Pour cela, on a les boucles  for  .

Sachez que vous utiliserez certainement autant de for que de while  , si ce n'est plus ; il vous faudra donc savoir manipuler ces deux types de boucles.

Pour rappel, voici un exemple de boucle while que nous avons vu tout à l'heure :

int compteur = 0;

while (compteur < 10)
{
    printf("Bienvenue sur OpenClassrooms !\n");
    compteur++;
}

Voici maintenant l'équivalent en boucle for :

int compteur;

for (compteur = 0 ; compteur < 10 ; compteur++)
{
    printf("Bienvenue sur OpenClassrooms !\n");
}

Quelles différences y a-t-il ?

  - On n'a pas initialisé la variable compteur à 0 dès sa déclaration (mais on aurait pu le faire).

  - Il y a beaucoup de choses entre les parenthèses après for  (nous allons détailler ça après).

  - Il n'y a plus de compteur++;  dans la boucle.

Intéressons-nous à ce qui se trouve entre les parenthèses, car c'est là que réside tout l'intérêt de la boucle for : il y a trois instructions condensées, séparées par un point-virgule :

  1. L'initialisation : cette première instruction est utilisée pour préparer notre variable compteur. Dans 
     notre cas, on initialise la variable à 0.

  2. La condition : comme pour la boucle while, c'est la condition qui dit si la boucle doit être répétée ou 
     non. Tant que la condition est vraie, la boucle for continue.

  3. L'incrémentation : cette dernière instruction est exécutée à la fin de chaque tour de boucle pour mettre 
     à jour la variable compteur. La plupart du temps, on fera une incrémentation, mais on peut aussi faire 
     une décrémentation (variable--), ou encore n'importe quelle autre opération (variable += 2; pour avancer 
     de 2 en 2, par exemple).

Bref ! for n'est rien d'autre qu'un condensé. 

L’instruction  break  permet d'arrêter l’exécution d’une boucle, elle permet de sortir prématurément de la boucle et de lancer l’instruction suivante.

L’instruction  continue  permet de passer directement à l’itération suivante sans exécuter les lignes de l’itération courante.

Pour terminer ce chapitre, je vous propose une dernière vidéo qui montre comment utiliser une boucle  for   , et les erreurs à éviter :

En résumé

  - Les boucles sont des structures qui nous permettent de répéter une série d'instructions plusieurs fois.

  - Il existe plusieurs types de boucles : while, do… while et for. Certaines sont plus adaptées que d'autres 
    selon les cas.

  - for est probablement celle qu'on utilise le plus. On y fait très souvent des incrémentations ou des 
    décrémentations de variables.

Vous êtes maintenant au point avec l’ensemble des concepts de base du langage. Voyons maintenant une notion très importante de la programmation. Comment créer une fonction ?

##############################################################################################################

Découpez votre programme en fonctions

Nous allons apprendre à organiser notre code en fonctions. Il s'agit en fait de découper nos programmes en petits morceaux. Chaque petit morceau sera ce qu'on appelle une fonction.

Une fonction exécute des actions et renvoie un résultat. C'est un morceau de code qui sert à faire quelque chose de précis. On dit qu'une fonction possède une entrée et une sortie.

Créez une fonction

Voilà comment on représente une fonction, schématiquement (c'est un modèle à connaître !) :

type nomFonction(parametres)
{
    // Insérez vos instructions ici
}


type  (correspond à la sortie) : c'est le type de la fonction.

Si la fonction renvoie un nombre décimal, vous mettrez sûrement double  ; si elle renvoie un entier, vous mettrez int ou long par exemple. Mais il est aussi possible de créer des fonctions qui ne renvoient rien, elles seront alors de type void  ("vide", en français).

nomFonction  : c'est le nom de votre fonction.

Vous pouvez appeler votre fonction comme vous voulez, du moment que vous respectez les mêmes règles que pour les variables (pas d'accents, pas d'espaces, etc.).

parametres  (correspond à l'entrée) : ce sont les paramètres de la fonction.

Ils sont entre parenthèses. Ce sont en fait des valeurs avec lesquelles la fonction va travailler.

Maintenant que vous savez ça, voyons un exemple pratique ! Disons que :

  - notre fonction triple reçoit un nombre entier de type  int  ;

  - et qu'elle renvoie un nombre entier également de type int.

Elle calcule le triple du nombre qu'on lui donne :

int triple(int nombre)
{
    int resultat = 0;

    resultat = 3 * nombre;  // On multiplie le nombre fourni par 3
    return resultat;       // On retourne la variable resultat qui vaut le triple de nombre
}

La fonction est de type int. Elle doit donc renvoyer une valeur de type int.

Entre les parenthèses, vous avez les variables que la fonction reçoit. Ici, notre fonction triple reçoit une variable de type int appelée nombre.

La ligne qui donne pour consigne de "renvoyer une valeur" est celle qui contient le return. Cette ligne se trouve généralement à la fin de la fonction, après les calculs. 

Ce code signifie pour la fonction :

« Arrête-toi là et renvoie le nombre resultat».

Cette variable resultat DOIT être de type int, car la fonction renvoie un int .

La variable resultat est déclarée (= créée) dans la fonction triple. Cela signifie qu'elle n'est utilisable que dans cette fonction, et pas dans une autre (comme la fonction main par exemple). C'est donc une variable propre à la fonction triple.

Mais est-ce la façon la plus courte d'écrire notre fonction triple  ?

Non, on peut faire tout cela en une ligne :

int triple(int nombre)
{
    return 3 * nombre;
}

Cette fonction fait exactement la même chose que la fonction de tout à l'heure, elle est juste plus rapide à écrire.

Généralement, vos fonctions contiendront plusieurs variables pour effectuer leurs calculs et leurs opérations ; rares seront les fonctions aussi courtes que triple.

Affectez (ou non) des paramètres à une fonction

Vous pouvez envoyer autant de paramètres que vous le voulez. Vous pouvez aussi n'envoyer aucun paramètre à la fonction, mais ça se fait plus rarement.

Affectez plusieurs paramètres à une fonction

Notre fonction triple contient un paramètre, mais il est possible de créer des fonctions acceptant plusieurs paramètres, comme par exemple une fonction addition qui additionne deux nombres a et b  :

int addition(int a, int b)
{
    return a + b;
}

Il suffit de séparer les différents paramètres par une virgule, comme vous le voyez.

N'affectez aucun paramètre à fonction

Certaines fonctions, plus rares, ne prennent aucun paramètre en entrée. Ces fonctions feront généralement toujours la même chose. En effet, si elles n'ont pas de nombres sur lesquels travailler, vos fonctions serviront juste à effectuer certaines actions, comme afficher du texte à l'écran. Et encore, ce sera forcément toujours le même texte, puisque la fonction ne reçoit aucun paramètre susceptible de modifier son comportement !

Imaginons une fonction bonjour qui affiche juste "Bonjour" à l'écran :

void bonjour()
{
    printf("Bonjour");
}

Je n'ai rien mis entre parenthèses car la fonction ne prend aucun paramètre. De plus, j'ai utilisé le type void dont je vous ai parlé plus haut.

En effet, ma fonction n'a pas non plus de return : elle ne retourne rien.

Une fonction qui ne retourne rien est de type void.

Appelez une fonction

Nous allons reprendre notre fonction triple  (décidément, je l'aime bien) pour calculer le triple d'un nombre.

Pour le moment, écrivez la fonction triple AVANT la fonction main  (si vous la placez après, ça ne marchera pas, je vous expliquerai pourquoi par la suite).

Testez donc ce code pour comprendre :

#include <stdio.h>
#include <stdlib.h>

int triple(int nombre)
{
    return 3 * nombre;
}    

int main(int argc, char *argv[])
{
    int nombreEntre = 0, nombreTriple = 0;
    
    printf("Entrez un nombre... ");
    scanf("%d", &nombreEntre);
    
    nombreTriple = triple(nombreEntre);
    printf("Le triple de ce nombre est %d\n", nombreTriple);
    
    return 0;
}

Notre programme commence par la fonction main :

  1. On demande à l'utilisateur d'entrer un nombre.

  2. On envoie ce nombre qu'il a entré à la fonction triple  .

  3. Et on récupère le résultat dans la variable nombreTriple  .

Regardez en particulier cette ligne, c'est la plus intéressante car c'est l'appel de la fonction :

  1.nombreTriple = triple(nombreEntre);

Entre parenthèses, on envoie à la fonction triple une variable en entrée (c'est le nombre sur lequel elle va travailler).

Cette fonction renvoie une valeur qu'on récupère dans la variable nombreTriple  .

Dans cette ligne de code, on ordonne donc à l'ordinateur :

« Demande à la fonction triple de me calculer le triple de nombreEntre  ,

et stocke le résultat dans la variable nombreTriple  ».

Dans la vidéo suivante, nous allons reprendre le même exemple, et voir les différentes étapes pour créer la fonction  triple  et l’appeler dans le  main  :

Comprenez le sens de lecture d'une fonction

Le code ci-dessous est commenté de manière un peu particulière. C'est pour vous montrer dans quel ordre le code est "lu". Commencez donc par lire la ligne commentée 1, puis 2, puis 3 (vous avez compris 🤣) :

#include <stdio.h>
#include <stdlib.h>

int triple(int nombre) // 6
{
    return 3 * nombre; // 7
}    

int main(int argc, char *argv[]) // 1
{
    int nombreEntre = 0, nombreTriple = 0; // 2
    
    printf("Entrez un nombre... "); // 3
    scanf("%d", &nombreEntre); // 4
    
    nombreTriple = triple(nombreEntre); // 5
    printf("Le triple de ce nombre est %d\n", nombreTriple); // 8
    
    return 0; // 9
}

Voici ce qui se passe, ligne par ligne.

  1. Le programme commence par la fonction main.

  2. Il lit les instructions dans la fonction, une par une, dans l'ordre.

  3. Il lit l'instruction suivante et fait ce qui est demandé (printf).

  4. De même, il lit l'instruction et fait ce qui est demandé (scanf).

  5. Il lit l'instruction… Ah ! On appelle la fonction triple, on doit donc sauter à la ligne de la fonction 
     triple plus haut.

  6. On saute à la fonction triple et on récupère un paramètre (nombre).

  7. On fait des calculs sur le nombre et on termine la fonction :return signifie la fin de la fonction, et 
     permet d'indiquer le résultat à renvoyer.

  8. On retourne dans main pour prendre l'instruction suivante.

  9. Un return : la fonction  main  se termine, et donc le programme est terminé.

Si vous avez compris dans quel ordre l'ordinateur lit les instructions, vous avez déjà compris le principal.

Parfois, une fonction ne prend aucun paramètre en entrée ; ou au contraire elle en prend plusieurs (je vous ai expliqué ça un peu plus haut).

De même, parfois une fonction renvoie une valeur, parfois elle ne renvoie rien (dans ce cas, il n'y a pas de return).

Voici un exemple d'utilisation du programme :

Entrez un nombre... 10
Le triple de ce nombre est 30

Vous n'êtes pas obligé de stocker le résultat d'une fonction dans une variable ! Vous pouvez directement envoyer le résultat de la fonction triple à une autre fonction, comme si triple(nombreEntre) était une variable.

Regardez bien ceci, c'est le même code mais il y a un changement au niveau du dernier printf. De plus, on n'a pas déclaré de variable nombreTriple car on ne s'en sert plus :

#include <stdio.h>
#include <stdlib.h>

int triple(int nombre)
{
    return 3 * nombre;
}    

int main(int argc, char *argv[])
{
    int nombreEntre = 0;
    
    printf("Entrez un nombre... ");
    scanf("%d", &nombreEntre);

    // Le résultat de la fonction est directement envoyé au printf et n'est pas stocké dans une variable
    printf("Le triple de ce nombre est %d\n", triple(nombreEntre));
     
    return 0;
}


triple(nombreEntre)  est directement envoyé au printf.

Que fait l'ordinateur quand il tombe sur cette ligne ?

Il voit que la ligne commence par printf, il va donc appeler la fonction printf.

Il envoie à la fonction printf tous les paramètres qu'on lui donne :

  1. Le premier paramètre est le texte à afficher.

  2. Et le second est un nombre.

Votre ordinateur voit qu'il doit d'abord appeler la fonction triple pour envoyer ce nombre à la fonction printf :

  1. Il appelle triple.

  2. Il effectue les calculs de triple.

  3. Et une fois qu'il a le résultat, il l'envoie directement dans la fonction printf !

C'est un peu une imbrication de fonctions. Et le plus fin dans tout ça, c'est qu'une fonction peut en appeler une autre à son tour : notre fonction triple pourrait appeler une autre fonction, qui elle-même appellerait une autre fonction, etc. C'est ça le principe de la programmation en C : tout est combiné, comme dans un jeu de LEGO.

Le plus dur sera d'écrire vos fonctions.

Une fois que vous les aurez écrites, vous n'aurez plus qu'à appeler les fonctions sans vous soucier des calculs qu'elles peuvent bien faire à l'intérieur.

Ça va permettre de simplifier considérablement l'écriture de nos programmes et ça, croyez-moi, on en aura bien besoin !

Intégrez le principe en pratique avec ces exemples
Je vais donc maintenant vous montrer plusieurs exemples d'utilisation de fonctions, pour que vous ayez une idée de leur intérêt. Je vais m'efforcer de faire des cas différents à chaque fois, pour que vous puissiez avoir des exemples de tous les types de fonctions qui peuvent exister.

Je ne vous apprendrai rien de nouveau, mais ce sera l'occasion de voir des exemples pratiques. Si vous avez déjà compris tout ce que j'ai expliqué avant, c'est très bien, et normalement aucun des exemples qui vont suivre ne devrait vous surprendre.

Analysez une fonction qui prend 1 paramètre

Intéresserons-nous à une fonction qui ne renvoie rien (pas de sortie). Imaginons une fonction qui copie des lignes, comme les punitions que l'on avait lorsqu'on était petit :

void punition(int nombreDeLignes)
{
    int i;
    
    for (i = 0 ; i < nombreDeLignes ; i++)
    {
        printf("Je ne dois pas copier sur mon voisin\n");
    }    
}    

int main(int argc, char *argv[])
{    
    punition(10);
    
    return 0;
}

C'est une fonction qui affiche le même message à l'écran autant de fois qu'on lui demande. Elle prend un paramètre en entrée : le nombre de fois où il faut afficher la punition.

Résultat :

Je ne dois pas copier sur mon voisin
Je ne dois pas copier sur mon voisin
Je ne dois pas copier sur mon voisin
Je ne dois pas copier sur mon voisin
Je ne dois pas copier sur mon voisin
Je ne dois pas copier sur mon voisin
Je ne dois pas copier sur mon voisin
Je ne dois pas copier sur mon voisin
Je ne dois pas copier sur mon voisin
Je ne dois pas copier sur mon voisin

On a ici affaire à une fonction qui ne renvoie aucune valeur. Cette fonction se contente juste d'effectuer des actions (ici, elle affiche des messages à l'écran).

Il aurait été bien plus intéressant de créer une fonction punition qui s'adapte à n'importe quelle sanction. On lui aurait envoyé deux paramètres : le texte à répéter, et le nombre de fois qu'il doit être répété.

Le problème, c'est qu'on ne sait pas encore gérer le texte en C (au cas où vous n'auriez pas vu, je vous rappelle qu'on n'a fait que manipuler des variables contenant des nombres depuis le début du cours !). D'ailleurs à ce sujet, je vous annonce que nous ne tarderons pas à apprendre à utiliser des variables qui retiennent du texte. C'est plus compliqué qu'il n'y paraît, et on ne pouvait pas l'apprendre dès le début du cours !

Analysez une fonction qui prend 2 paramètres en entrée

Imaginons une fonction qui calcule l'aire d'un rectangle. L'aire d'un rectangle est facile à calculer :largeur * hauteur.
Notre fonction nommée aireRectangle va prendre deux paramètres : la largeur et la hauteur pour renvoyer l'aire :

double aireRectangle(double largeur, double hauteur)
{
    return largeur * hauteur;
}    

int main(int argc, char *argv[])
{    
    printf("Rectangle de largeur 5 et hauteur 10. Aire = %f\n", aireRectangle(5, 10));
    printf("Rectangle de largeur 2.5 et hauteur 3.5. Aire = %f\n", aireRectangle(2.5, 3.5));
    printf("Rectangle de largeur 4.2 et hauteur 9.7. Aire = %f\n", aireRectangle(4.2, 9.7));
      
    return 0;
}


Rectangle de largeur 5 et hauteur 10. Aire = 50.000000
Rectangle de largeur 2.5 et hauteur 3.5. Aire = 8.750000
Rectangle de largeur 4.2 et hauteur 9.7. Aire = 40.740000

Pourrait-on afficher directement la largeur, la hauteur et l'aire dans la fonction ?

Bien sûr ! Dans ce cas, la fonction ne renverrait plus rien, elle se contenterait de calculer l'aire et de l'afficher immédiatement :

void aireRectangle(double largeur, double hauteur)
{
    double aire = 0;
    
    aire = largeur * hauteur;
    printf("Rectangle de largeur %f et hauteur %f. Aire = %f\n", largeur, hauteur, aire);
}    

int main(int argc, char *argv[])
{    
    aireRectangle(5, 10);
    aireRectangle(2.5, 3.5);
    aireRectangle(4.2, 9.7);
       
    return 0;
}

printf est à l'intérieur de la fonction aireRectangle et produit le même affichage que tout à l'heure. C'est juste une façon différente de procéder.

Analysez une fonction qui ne prend aucun paramètre en entrée

Ce code est plus intéressant et concret : on crée une fonction menu qui ne prend aucun paramètre en entrée. Cette fonction se contente d'afficher le menu, et demande à l'utilisateur de faire un choix. La fonction renvoie le choix de l'utilisateur.

int menu()
{
    int choix = 0;
    
    while (choix < 1 || choix > 4)
    {
        printf("Menu :\n");
        printf("1 : Poulet de dinde aux escargots rotis a la sauce bearnaise\n");
        printf("2 : Concombres sucres a la sauce de myrtilles enrobee de chocolat\n");
        printf("3 : Escalope de kangourou saignante et sa gelee aux fraises poivree\n");
        printf("4 : La surprise du Chef (j'en salive d'avance...)\n");
        printf("Votre choix ? ");
        scanf("%d", &choix);
    }    
    
    return choix;
}    

int main(int argc, char *argv[])
{    
    switch (menu())
    {
        case 1:
            printf("Vous avez pris le poulet\n");
            break;
        case 2:
            printf("Vous avez pris les concombres\n");
            break;
        case 3:
            printf("Vous avez pris l'escalope\n");
            break;
        case 4:
            printf("Vous avez pris la surprise du Chef. Vous etes un sacre aventurier dites donc !\n");
            break;    
    }
       
    return 0;
}

La fonction menu affiche à nouveau le menu tant que l'utilisateur n'a pas entré un nombre compris entre 1 et 4. Comme ça, aucun risque que la fonction renvoie un nombre qui ne figure pas au menu !

Dans le main, vous avez vu qu'on fait un switch(menu())  : une fois que la fonction menu()est terminée, elle renvoie le choix de l'utilisateur directement dans le switch. C'est une méthode rapide et pratique.

En résumé

  - Les fonctions s'appellent entre elles. Ainsi, le main peut appeler des fonctions toutes prêtes telles que 
    printf ou scanf, mais aussi des fonctions que nous avons créées.

  - Une fonction récupère en entrée des variables qu'on appelle les paramètres.

  - Elle effectue certaines opérations avec ces paramètres, puis retourne en général une valeur à l'aide de 
    l'instruction return.

Dans le prochain chapitre, vous allez vous initiez à la programmation modulaire… J'espère que cela vous plaira ! Cela nous permettra de clôturer cette partie avant de nous attaquer à un gros morceau : les pointeurs.

##############################################################################################################

Initiez-vous à la programmation modulaire

Jusqu'ici nous n'avons travaillé que dans un seul fichier : main.c.

C'était acceptable car nos programmes étaient tout petits, mais ils vont bientôt être composés de nombreuses fonctions. On va donc passer à la programmation modulaire : plutôt que de placer tout le code d'un programme dans un seul fichier main.c, nous le séparons en plusieurs petits fichiers.

Lorsque vous faites appel à la fonction dans le main, l'ordinateur connaît la fonction et sait où aller la chercher.

En revanche, si vous mettez votre fonction après le main, ça ne marchera pas… Mais rassurez-vous, les programmeurs ont prévu le coup.

Grâce à ce que je vais vous apprendre maintenant, vous pourrez positionner vos fonctions dans n'importe quel ordre dans le code source !

Annoncez une fonction à l'aide d'un prototype
Nous allons annoncer nos fonctions à l'ordinateur en écrivant des prototypes. 

Regardez la première ligne de notre fonction aireRectangle  :

double aireRectangle(double largeur, double hauteur)
{
    return largeur * hauteur;
}

Copiez la première ligne tout en haut de votre fichier source, juste après les #include  .

Rajoutez un point-virgule à la fin de cette nouvelle ligne, comme ceci : 

  1.double aireRectangle(double largeur, double hauteur);

Voilà ! Maintenant, vous pouvez placer votre fonction aireRectangle après la fonction main si vous le voulez ! 

Vous devriez avoir le code suivant sous les yeux :

#include <stdio.h>
#include <stdlib.h>

// La ligne suivante est le prototype de la fonction aireRectangle :
double aireRectangle(double largeur, double hauteur);

int main(int argc, char *argv[])
{   
    printf("Rectangle de largeur 5 et hauteur 10. Aire = %f\n", aireRectangle(5, 10));
    printf("Rectangle de largeur 2.5 et hauteur 3.5. Aire = %f\n", aireRectangle(2.5, 3.5));
    printf("Rectangle de largeur 4.2 et hauteur 9.7. Aire = %f\n", aireRectangle(4.2, 9.7));
   
    return 0;
}

// Notre fonction aireRectangle peut maintenant être mise n'importe où dans le code source :
double aireRectangle(double largeur, double hauteur)
{
    return largeur * hauteur;
}

Ce qui a changé ici, c'est l'ajout du prototype en haut du code source.

Un prototype, c'est en fait une indication pour l'ordinateur, qui lui permet de s'organiser et de savoir qu'il existe une fonction (par exemple appelée aireRectangle ) qui prend tels paramètres en entrée et renvoie une sortie du type que vous indiquez. 

La fonction main est la seule qui n'a pas besoin de prototype, parce que l'ordinateur la connaît (c'est toujours la même pour tous les programmes).

Exceptée  main  (qui n'en a pas besoin), écrivez toujours les prototypes de vos fonctions, car vos programmes vont commencer à utiliser de nombreuses fonctions.

N'oubliez JAMAIS de mettre un point-virgule à la fin d'un prototype. C'est ce qui permet à l'ordinateur de différencier un prototype du véritable début d'une fonction. Si vous ne le faites pas, vous risquez d'avoir des erreurs incompréhensibles lors de la compilation.

Créez les fichiers d'en-tête (header) de vos projets

Un projet, c'est l'ensemble des fichiers sources de votre programme. En général, on crée plusieurs fichiers par projet.

Pour le moment, nos projets n'étaient composés que d'un fichier source : main.c.

Voyons comment structurer un vrai projet à l’aide de fichiers d’en-tête (ou "header", en anglais)

Créez plusieurs fichiers par projet

L'idée, c'est d'avoir plusieurs fichiers (dont le fichier main.c  qui contient la fonction main ) :


- Workspace
   => Sources
         --> controller.c
         --> main.c
         --> model.c
         --> view.c
   => Headers
         --> constants.h
         --> controller.h
         --> model.h
         --> view.h



Pourquoi plusieurs ? Combien de fichiers je dois créer pour mon projet ?

En général, on regroupe dans un même fichier des fonctions ayant le même thème :

  - dans le fichier view.c j'ai regroupé toutes les fonctions concernant l'interface graphique ;

  - dans le fichier controller.c, j'ai regroupé toutes les fonctions concernant la logique de l'application.

Faites la différence entre les fichiers .h et .c

Il y a deux types de fichiers différents :

  1. .h: fichiers header, ils contiennent les prototypes des fonctions.

  2. .c: les fichiers source, ils contiennent les fonctions elles-mêmes.

En général, on met donc rarement les prototypes dans les fichiers .c comme on l'a fait tout à l'heure dans le main.c (sauf si votre programme est tout petit).

Pour chaque fichier .c   , il y a donc son équivalent .h qui contient les prototypes des fonctions :

  - controller.c (le code des fonctions) et controller.h(les prototypes des fonctions) ;

  - view.c et view.h  , etc.

Mais comment faire pour que l'ordinateur sache que les prototypes sont dans un autre fichier que le .c?

Il faut inclure le fichier .h grâce à une directive de préprocesseur. Attention, préparez-vous à comprendre beaucoup de choses d'un coup !

Regardez par exemple le début de mon fichier view.c:

#include <stdlib.h>
#include <stdio.h>
#include "view.h"

void menu()
{
// ...

L'inclusion se fait grâce à la directive de préprocesseur #include que vous connaissez bien maintenant. Regardez les premières lignes du code source :

#include <stdlib.h>
#include <stdio.h>
#include "view.h" // On inclut view.h

On inclut trois fichiers .h:

  1. stdio ;

  2. stdlib ;

  3. view .

Les fichiers que vous avez créés et placés dans le répertoire de votre projet doivent être inclus avec des guillemets ("view.h").

Tandis que les fichiers correspondant aux bibliothèques (qui sont généralement installés, eux, dans le répertoire de votre IDE) sont inclus entre chevrons (<stdio.h>).


Vous utiliserez donc :

les chevrons  < >  pour inclure un fichier se trouvant dans le répertoire "include" de votre IDE ;

les guillemets" " pour inclure un fichier se trouvant dans le répertoire de votre projet (à côté des .c, généralement).

La commande #include demande d'insérer le contenu du fichier dans le .c. C'est donc une commande qui dit « Insère ici le fichier view.h», par exemple.

Et dans le fichier view.h, on retrouve les prototypes des fonctions du fichier view.c!

/*
view.h
-----

Rôle : prototypes des fonctions de view.
*/

void menu();
int choixUtilisateur();
void afficherInfos(const char* infos);

Voilà comment fonctionne un vrai projet ! Un prototype, c'est donc le mode d'emploi de la fonction pour l'ordinateur. Tout est une question d'ordre :

  - Si vous placez vos prototypes dans des .h inclus en haut des .c, votre ordinateur connaîtra le mode d'emploi de toutes vos fonctions dès le début de la lecture du fichier, et vous n'aurez ainsi pas à vous soucier de l'ordre dans lequel les fonctions se trouvent dans vos fichiers .c.

  - Si maintenant vous faites un petit programme contenant deux ou trois fonctions, vous vous rendrez peut-être compte que les prototypes semblent facultatifs (ça marche sans). Mais ça ne durera pas longtemps ! Dès que vous aurez un peu plus de fonctions, si vous ne mettez pas vos prototypes de fonctions dans des .h, la compilation échouera sans aucun doute.

Lorsque vous appellerez une fonction située dans fonctions.c depuis le fichier main.c, vous aurez besoin d'inclure les prototypes de fonctions.c dans main.c. Il faudra donc mettre un #include "fonctions.h"  en haut de main.c.

À chaque fois que vous faites appel à une fonction X dans un fichier, il faut que vous ayez inclus les prototypes de cette fonction dans votre fichier. Cela permet au compilateur de vérifier si vous l'avez correctement appelée.

Comment puis-je ajouter des fichiers .c et .h à mon projet ?

Ça dépend de l'IDE que vous utilisez, mais globalement la procédure est la même :Fichier / Nouveau / Fichier source.

Cela crée un nouveau fichier vide.

Ce fichier n'est pas encore de type .c  ou .h, il faut que vous l'enregistriez pour le dire. Enregistrez donc ce nouveau fichier (même s'il est encore vide), puis nommez le fichier :

  - si vous l'appelez fichier.c, ce sera un.c;

  - si vous l'appelez fichier.h, ce sera un.h.

C'est aussi simple que cela. Enregistrez votre fichier dans le répertoire dans lequel se trouvent les autres fichiers de votre projet (le même dossier que main.c). Généralement, vous enregistrerez tous vos fichiers dans le même répertoire, les .c comme les .h.
Avec Code::Block, cochez la case "Add file to active project" pour l’ajouter à votre projet. Sinon il faudra l’ajouter manuellement. Pour l'ajouter au projet, faites un clic droit sur le nom de votre projet dans la partie à gauche de l'écran (où il y a la liste des fichiers du projet), et choisissez "Add files".

Le dossier du projet regroupe des .c  et des .h ensemble.

Maintenant que vous avez compris la théorie, il est temps de pratiquer un peu. Je vous propose de suivre la vidéo suivante, et d’effectuer les mêmes manipulations pour créer un fichier "header" et placer le prototype d'une fonction dedans. Nous allons reprendre l’exemple de la fonction "aireRectangle" :

Les include des bibliothèques standard

Si on inclut les fichiers stdio.h et stdlib.h, c'est donc qu'ils existent quelque part et qu'on peut aller les chercher, non ?

Oui ! Ils sont normalement installés là où se trouve votre IDE.

Il faut généralement chercher un dossier include : dedans, vous trouverez de très nombreux fichiers ; ce sont des headers (.h) des bibliothèques standard, c'est-à-dire des bibliothèques disponibles partout (que ce soit sous Windows, Mac, Linux…). Vous y retrouverez donc stdio.h et stdlib.h, entre autres.

Vous pouvez les ouvrir si vous voulez, mais ça risque de piquer un peu les yeux. En effet, c'est un peu compliqué (il y a pas mal de choses qu'on n'a pas encore vues). Si vous cherchez bien, vous verrez que ce fichier est rempli de prototypes de fonctions standard, comme printf par exemple.

OK, je sais maintenant où se trouvent les prototypes des fonctions standard. Mais comment pourrai-je voir le code source de ces fonctions ? Où sont les .c?

Vous ne les avez pas ! En fait, les fichiers .c sont déjà compilés (en code binaire, c'est-à-dire en code machine). Il est donc totalement impossible de les lire.

Vous pouvez retrouver les fichiers compilés dans un répertoire appelé lib(c'est l'abréviation de library qui signifie "bibliothèque", en français). 

Les fichiers compilés des bibliothèques ont l'extension .a sous Code::Blocks (qui utilise le compilateur appelé mingw), et ont l'extension .lib sous Visual Studio (qui utilise le compilateur Visual). N'essayez pas de les lire : ce n'est absolument pas digeste pour un humain.

Retenez que dans vos fichiers .c, vous incluez les .h des bibliothèques standard pour pouvoir utiliser des fonctions standard comme printf. Votre ordinateur a ainsi les prototypes sous les yeux, et peut vérifier si vous appelez les fonctions correctement, par exemple que vous n'oubliez pas de paramètres.

Découvrez le fonctionnement de la compilation séparée

--> vidéo

Comprenez la portée des fonctions et des variables

Nous allons voir quand les variables et les fonctions sont accessibles, c'est-à-dire quand on peut faire appel à elles.

Les variables propres aux fonctions

Lorsque vous déclarez une variable dans une fonction, elle est supprimée de la mémoire à la fin de la fonction :

int triple(int nombre)
{
    int resultat = 0; // La variable resultat est créée en mémoire
 
    resultat = 3 * nombre;
    return resultat;
} // La fonction est terminée, la variable resultat est supprimée de la mémoire

Une variable déclarée dans une fonction n'existe donc que pendant que la fonction est exécutée. Ça veut dire que vous ne pouvez pas y accéder depuis une autre fonction !

Regardez ce code :

int triple(int nombre);
 
int main(int argc, char *argv[])
{
    printf("Le triple de 15 est %d\n", triple(15));
   
    printf("Le triple de 15 est %d", resultat); // Erreur
 
    return 0;
}
 
int triple(int nombre)
{
    int resultat = 0;
 
    resultat = 3 * nombre;
    return resultat;
}


Dans le main, j'essaie ici d'accéder à la variable resultat. Or, comme cette variable resultat a été créée dans la fonction triple, elle n'est pas accessible dans la fonction main!

Une variable déclarée dans une fonction n'est accessible qu'à l'intérieur de cette fonction. On dit que c'est une variable locale.

Créez une variable globale accessible uniquement dans un fichier

Il est possible de déclarer des variables qui seront accessibles dans toutes les fonctions de tous les fichiers du projet, mais généralement il faut éviter de le faire : ça aura l'air de simplifier votre code au début, mais ensuite vous risquez de vous retrouver avec de nombreuses variables accessibles partout, ce qui risquera de vous créer des soucis.

Exemple :

#include <stdio.h>
#include <stdlib.h>
 
int resultat = 0; // Déclaration de variable globale
 
void triple(int nombre); // Prototype de fonction
 
int main(int argc, char *argv[])
{
    triple(15); // On appelle la fonction triple, qui modifie la variable globale resultat
    printf("Le triple de 15 est %d\n", resultat); // On a accès à resultat
 
    return 0;
}
 
void triple(int nombre)
{
    resultat = 3 * nombre;
}

Ici, ma fonction triple ne renvoie plus rien (void). Elle se contente de modifier la variable globale resultat que la fonction main peut récupérer.

Ma variable resultat sera accessible dans tous les fichiers du projet, on pourra donc faire appel à elle dans TOUTES les fonctions du programme.

Ce type de choses est à bannir dans un programme en C.

Utilisez plutôt le retour de la fonction (return) pour renvoyer un résultat.

La variable globale que nous venons de voir était accessible dans tous les fichiers du projet.

Il est possible de la rendre accessible uniquement dans le fichier dans lequel elle se trouve. Ça reste une variable globale quand même, mais disons qu'elle n'est globale qu'aux fonctions de ce fichier, et non à toutes les fonctions du programme.

Pour créer une variable globale accessible uniquement dans un fichier, rajoutez simplement le mot-clé static devant :

  1.static int resultat = 0;

Conservez la valeur d'une variable avec  static

Si vous rajoutez le mot-clé static devant la déclaration d'une variable à l'intérieur d'une fonction, ça n'a pas le même sens que pour les variables globales. En fait, la variable static n'est plus supprimée à la fin de la fonction. La prochaine fois qu'on appellera la fonction, la variable aura conservé sa valeur.
Par exemple :

int triple(int nombre)
{
    static int resultat = 0; // La variable resultat est créée la première fois que la fonction est appelée
 
    resultat = 3 * nombre;
    return resultat;
} // La variable resultat n'est PAS supprimée lorsque la fonction est terminée.

Cela signifie qu'on pourra rappeler la fonction plus tard, et que la variable resultat contiendra toujours la valeur de la dernière fois.

Voici un petit exemple pour bien comprendre :

int incremente();
 
int main(int argc, char *argv[])
{
    printf("%d\n", incremente());
    printf("%d\n", incremente());
    printf("%d\n", incremente());
    printf("%d\n", incremente());
 
    return 0;
}
 
int incremente()
{
    static int nombre = 0;
    
    nombre++;
    return nombre;
}

1
2
3
4

Ici, la première fois qu'on appelle la fonction incremente, la variable nombre est créée. Elle est incrémentée à 1, et une fois la fonction terminée la variable n'est pas supprimée.

Lorsque la fonction est appelée une seconde fois, la ligne de la déclaration de variable est tout simplement "sautée". On ne recrée pas la variable, on réutilise la variable qu'on avait déjà créée. Comme la variable valait 4, elle vaudra maintenant 5, puis 6, puis 7, etc.

Définissez des fonctions locales à un fichier

Normalement, quand vous créez une fonction, celle-ci est globale à tout le programme. Elle est accessible depuis n'importe quel autre fichier .c.

Il se peut que vous ayez besoin de créer des fonctions qui ne seront accessibles que dans le fichier dans lequel se trouve la fonction. Pour faire cela, rajoutez static devant la fonction :

static int triple(int nombre)
{
    // Instructions
}

Pensez à mettre à jour le prototype aussi :

  1.static int triple(int nombre);

Maintenant, votre fonction static triple ne peut être appelée que depuis une autre fonction du même fichier. Si vous essayez d'appeler la fonction triple depuis une fonction d'un autre fichier, ça ne marchera pas car triple n'y sera pas accessible.

En résumé

  - Un programme contient des fichiers .c. Chaque fichier .c a un petit frère du même nom mais avec 
    l'extension.h. Le .c contient les fonctions tandis que le .h contient les prototypes.

  - Le contenu des fichiers .h est inclus en haut des .c par un programme appelé préprocesseur. Les .c sont 
    transformés en fichiers .o binaires par le compilateur. Les .o sont assemblés en un exécutable (.exe) par 
    le "linker", aussi appelé éditeur de liens.

  - Une variable déclarée dans une fonction est supprimée à la fin de la fonction, elle n'est accessible que 
    dans cette fonction. Une variable déclarée dans une fonction avec static devant n'est pas supprimée à la 
    fin de la fonction, elle conserve sa valeur au fur et à mesure de l'exécution du programme.

  - Une variable déclarée en dehors des fonctions est une variable globale, accessible depuis toutes les 
    fonctions de tous les fichiers source du projet. Une variable globale avec static devant est globale 
    uniquement dans le fichier dans lequel elle se trouve, elle n'est pas accessible depuis les fonctions des 
    autres fichiers.

  - Une fonction est par défaut accessible depuis tous les fichiers du projet, on peut donc l'appeler depuis 
    n'importe quel autre fichier. Si on veut qu'une fonction ne soit accessible que dans le fichier dans 
    lequel elle se trouve, il faut rajouter static devant.

Je vous sens prêt pour attaquer un gros morceau du langage C : les pointeurs ! J’espère que vous êtes bien attaché, car ce nouveau concept est costaud. Mais pas de panique, c’est loin d’être insurmontable !

##############################################################################################################

!!!!!!!!!!!!!!!!!!!!!!!!!!!! QUIZ : Découvrir les bases de la programmation en C !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

Compétences évaluées

Créer des algorithmes simples en C

Description

Dans ce quiz, vous allez construire au fur et à mesure des questions un jeu regroupant ce que vous avez pu apprendre lors de cette première partie. Il s'agit d'un petit jeu que j'appelle "Plus ou moins" ; le principe est le suivant :

  1. L'ordinateur tire au sort un nombre entre 1 et 100.
  2. Il vous demande de deviner le nombre. Vous entrez donc un nombre entre 1 et 100.
  3. L'ordinateur compare le nombre que vous avez entré avec le nombre « mystère » qu'il a tiré au sort. Il 
     vous dit si le nombre mystère est supérieur ou inférieur à celui que vous avez entré.
  4. Puis l'ordinateur vous redemande le nombre.
  5. … Et il vous indique si le nombre mystère est supérieur ou inférieur.
  6. Et ainsi de suite, jusqu'à ce que vous trouviez le nombre mystère.

Le but du jeu, bien sûr, est de trouver le nombre mystère en un minimum de coups. Allez c'est parti !

Prenez le temps dont vous avez besoin avant de répondre à chaque question. Vous retrouverez le corrigé du programme complet dans la réponse à la dernière question de ce quiz. Bonne chance !


Question 1

Quelles sont les deux bibliothèques qu’il faut absolument inclure dans notre programme pour utiliser les fonctions d’affichage et de conversion de types ?

  - 1.#include <stdio>
    2.#include <stdlib>

  - 1.#include <iostream>
    2.#include <string>

  - 1.#include <stdio.h> (o)
  - 2.#include <stdlib.h>

  - 1.#include <display.h>
    2.#include <conversion.h>

"""""""""""""""""""""" Réponse """"""""""""""""""""""""
 - #include <stdio.h>  : Cette bibliothèque contient l’ensemble des informations relatives aux fonctions 
                         d’entrée et de sortie, par exemple la fonction  printf()  ou le  scanf()  .
 -  #include <stdlib.h>  : Cette librairie propose des fonctions pour répondre à différentes problématiques 
                           liées à la conversion de données et à l’allocation dynamique de mémoire.

"""""""""""""""""""""""""""""""""""""""""""""""""""""""

Question 2

Quel est le nom de la fonction principale qui constituera le point d’entrée de notre programme ?

  - start

  - main (o)

  - entry

  - run

"""""""""""""""""""""" Réponse """"""""""""""""""""""""
Le  main  est une fonction prédéfinie en C. C'est la première fonction de chaque programme C qui est responsable du démarrage de l'exécution et de la fin du programme.

"""""""""""""""""""""""""""""""""""""""""""""""""""""""

Question 3

Dans notre super jeu, l’ordinateur va devoir enregistrer un nombre mystère qu’il aura tiré au sort entre un intervalle d’entier. Pour générer un nombre aléatoire, on va utiliser une nouvelle fonction : rand() . Pour cela, vous devez au préalable inclure la librairie  time.h . Cette fonction génère un nombre au hasard. Mais nous, on veut que ce nombre soit compris entre 1 et 100 par exemple.

Pour ce faire, on va utiliser la formule suivante  :

  1.srand(time(NULL));
  2.nombreMystere = (rand() % (MAX - MIN + 1)) + MIN;

Je vous recommande de définir ces constantes au début du programme pour définir le maximum et le minimum, comme ceci :

  1.const int MAX = 100, MIN = 1;

La fonction  rand()  retourne un entier et nous souhaitons enregistrer cette valeur dans une variable jusqu'à la fin du jeu. Quelle est la bonne méthode pour déclarer cette variable ?

  - nombreMystere int = 0;

  - nombreMystere int = 0

  - nombreMystere = 0 int;

  - int nombreMystere = 0; (o)

"""""""""""""""""""""" Réponse """"""""""""""""""""""""
La fonction  rand()  renvoie un entier, il faut donc que la variable soit de type  int  , il faut ensuite préciser le nom de cette variable  nombreMystere  et pour terminer vous pouvez initialiser cette variable grâce à l’opérateur  =  avec un entier.

"""""""""""""""""""""""""""""""""""""""""""""""""""""""

Question 4

Nous allons maintenant devoir créer une boucle dans le code pour demander à l’utilisateur d'entrer un entier afin de le comparer le nombre mystère.

Quels types de boucles sont les plus adaptées pour notre jeu sachant qu’on ne connaît pas à l’avance le nombre d’itérations ?

Attention, plusieurs réponses sont possibles.

  - loop

  - while (o)

  - for

  - do…while (o)

"""""""""""""""""""""" Réponse """"""""""""""""""""""""
La boucle  while  et la boucle  do…while  sont utilisées pour répéter une section de code un nombre inconnu de fois jusqu'à ce qu'une condition spécifique soit remplie.

La boucle  for  est répétée un nombre spécifique de fois, déterminé par le programme ou l'utilisateur.

Et la boucle  loop  n’existe pas.

"""""""""""""""""""""""""""""""""""""""""""""""""""""""

Question 5

Nous allons devoir :

  1. stocker la valeur de l’utilisateur dans une variable,
  2. et demander à l’utilisateur d'entrer un entier afin de l’assigner à cette variable. 

Ajoutons alors cette variable avant la boucle : 

  1.int nombreEntre = 0;
 

Quelle condition doit-on utiliser pour itérer dans notre boucle tant que nous n’avons pas trouvé le nombre mystère ?

  - nombreEntre == nombreMystere

  - nombreEntre >= nombreMystere

  - nombreEntre != nombreMystere (o)

  - nombreEntre = nombreMystere

"""""""""""""""""""""" Réponse """"""""""""""""""""""""
Nous devons arrêter notre boucle lorsque le nombre mystère enregistré dans la variable  nombreMystere  est égale à la variable  nombreEntre  qui contient la valeur entrée par l’utilisateur. Donc la condition pour rester à l’intérieur de la boucle est que  nombreEntre  soit différent de  nombreMystere  :  nombreEntre != nombreEntre

"""""""""""""""""""""""""""""""""""""""""""""""""""""""

Question 6

Quelle fonction permet de récupérer la saisie d’un utilisateur et de la stocker dans la variable  nombreEntre  ?

  - scanf("%d", &nombreEntre); (o)

  - scanf("%f", &nombreEntre);

  - input("%d", &nombreEntre);

  - input("%int", &nombreEntre);

"""""""""""""""""""""" Réponse """"""""""""""""""""""""
La fonction  scanf()  permet de lire les informations tapées au clavier par l'utilisateur selon un certain format. Les informations lues sont converties en caractères, entiers ou réels suivant le format attendu. Il faut préciser le format dans le premier paramètre et l’adresse de la variable où l’on souhaite stocker la saisie dans le deuxième paramètre. Dans notre cas, la variable est un  int  donc le format est  %d  et l’adresse de la variable est  &nombreEntre  .

"""""""""""""""""""""""""""""""""""""""""""""""""""""""

Question 7

Une fois la saisie de l’utilisateur récupérée, nous devons vérifier s'il est plus petit ou plus grand, ou alors s’il a trouvé le chiffre mystère. Nous devons donc créer une structure conditionnelle pour vérifier tout cela.

Quelle est la structure conditionnelle la plus adaptée à notre besoin ? 

  - if (nombreMystere < nombreEntre)
        printf("C'est plus !\n\n");
    else if (nombreMystere > nombreEntre)
        printf("C'est moins !\n\n");
    else
        printf ("Bravo, vous avez trouve le nombre mystere

  - if (nombreMystere > nombreEntre) (o)
        printf("C'est plus !\n\n");
    else if (nombreMystere < nombreEntre)
        printf("C'est moins !\n\n");
    else
        printf ("Bravo, vous avez trouve le nombre mystere !!!\n\n");

  - if (nombreMystere <= nombreEntre)
        printf("C'est plus !\n\n");
    else if (nombreMystere >= nombreEntre)
        printf("C'est moins !\n\n");
    else
        printf ("Bravo, vous avez trouve le nombre mystere !!!\n\n");

  - if (nombreEntre > nombreMystere)
            printf("C'est plus !\n\n");
        else if (nombreEntre < nombreMystere)
            printf("C'est moins !\n\n");
        else if (nombreEntre == nombreMystere)
      printf ("Bravo, vous avez trouve le nombre mystere !!!\n\n");

"""""""""""""""""""""" Réponse """"""""""""""""""""""""
Si  nombreMystere  est plus grand que  nombreEntre  il faut afficher  C’est plus !  car l’utilisateur va devoir entrer un nombre plus grand pour se rapprocher ou trouver le nombre mystère.

Si  nombreMystere  est plus petit que  nombreEntre  il faut afficher  C’est moins !  car l’utilisateur va devoir entrer un nombre plus petit pour se rapprocher ou trouver le nombre mystère.

Sinon, l’utilisateur a gagné et on affiche  Bravo, vous avez trouve le nombre mystere !!!  .
"""""""""""""""""""""""""""""""""""""""""""""""""""""""

Question 8

Par quelle instruction la fonction main doit se terminer avant de fermer les accolades ?

  - end;

  - end function;

  - return 0; (o)

  - stop 0;

"""""""""""""""""""""" Réponse """"""""""""""""""""""""
L’instruction  return 0  indique qu'on arrive à la fin de notre fonction  main  et demande de renvoyer la valeur 0. En fait, chaque programme une fois terminé renvoie une valeur, par exemple pour dire que tout s'est bien passé. En pratique, 0 signifie "tout s'est bien passé" et n'importe quelle autre valeur signifie "erreur". La plupart du temps, cette valeur n'est pas vraiment utilisée, mais il faut quand même en renvoyer une.

C'est la fin de ce petit exercice ! Sympa non ?

Si vous avez rencontré des blocages c'est normal, alors je vous propose une correction (aussi disponible sur github) :

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main ( int argc, char** argv )
{
    int nombreMystere = 0, nombreEntre = 0;
    const int MAX = 100, MIN = 1;

    // Génération du nombre aléatoire

    srand(time(NULL));
    nombreMystere = (rand() % (MAX - MIN + 1)) + MIN;

    /* La boucle du programme. Elle se répète tant que l'utilisateur n'a pas trouvé le nombre mystère */

    do
    {
        // On demande le nombre
        printf("Quel est le nombre ? ");
        scanf("%d", &nombreEntre);

        // On compare le nombre entré avec le nombre mystère

        if (nombreMystere > nombreEntre)
            printf("C'est plus !\n\n");
        else if (nombreMystere < nombreEntre)
            printf("C'est moins !\n\n");
        else
            printf ("Bravo, vous avez trouve le nombre mystere !!!\n\n");
    } while (nombreEntre != nombreMystere);
    
    return 0;
}

"""""""""""""""""""""""""""""""""""""""""""""""""""""""

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

##############################################################################################################