                                        Partie 5 (Bonus) : structurez vos données


Stockez les données avec les listes chaînées


Un tableau peut être représenté en mémoire comme ceci :

Un tableau de 4 cases en mémoire (représentation horizontale)

J'ai choisi ici de représenter le tableau horizontalement, mais il serait aussi possible de le présenter verticalement, peu importe.

Le problème des tableaux est qu'ils sont figés. Impossible de les agrandir (à moins d'en créer de nouveaux, plus grands) ; ou d'y insérer une case au milieu (à moins de décaler tous les autres éléments) :

Le langage C ne propose pas d'autre système de stockage de données, mais il est possible de le créer soi-même de toutes pièces. Encore faut-il savoir comment s'y prendre : c'est justement ce que ce chapitre et les suivants vous proposent de découvrir.

Une liste chaînée est un moyen d'organiser une série de données en mémoire. Cela consiste à assembler des structures en les liant entre elles à l'aide de pointeurs.

On pourrait les représenter comme ceci :


Une liste chaînée est un assemblage de structures liées par des pointeurs

Chaque élément peut contenir ce que l'on veut : un ou plusieurs int, double… En plus de cela, chaque élément possède un pointeur vers l'élément suivant :

Chaque élément contient une donnée (ex. : un int) et un pointeur vers l'élément suivant


Retenez comment les éléments sont agencés entre eux : ils forment une chaîne de pointeurs, d'où le nom de "liste chaînée".

Contrairement aux tableaux, les éléments d'une liste chaînée ne sont pas placés côte à côte dans la mémoire. Chaque case pointe vers une autre case en mémoire, qui n'est pas nécessairement stockée juste à côté.


Construisez une liste chaînée

Nous allons essayer de créer une structure qui fonctionne sur le principe que nous venons de découvrir.
Tout ce que nous allons faire ici fait appel à des techniques du langage C que vous connaissez déjà. Il n'y a aucun élément nouveau, nous allons nous contenter de créer nos propres structures et fonctions, et les transformer en un système logique, capable de se réguler tout seul.

Créez la structure de la liste des éléments

Nous allons créer une liste chaînée de nombres entiers.

On pourrait aussi bien créer une liste chaînée contenant des nombres décimaux ou même des tableaux et des structures. Le principe des listes chaînées s'adapte à n'importe quel type de données, mais ici, je propose de faire simple pour que vous compreniez bien le principe.

Chaque élément de la liste aura la structure suivante :


typedef struct Element Element;
struct Element
{
    int nombre;
    Element *suivant;
};


Que contient cette structure ?

  - Une donnée, ici un nombre de type int: on pourrait remplacer cela par n'importe quelle autre donnée (un 
    double, un tableau…). Cela correspond à ce que vous voulez stocker, c'est à vous de l'adapter en fonction 
    des besoins de votre programme.

Si on veut travailler de manière générique, l'idéal est de faire un pointeur sur void :void*. Cela permet de faire pointer vers n'importe quel type de données.

  - Un pointeur vers un élément du même type appelé suivant. C'est ce qui permet de lier les éléments les uns 
    aux autres : chaque élément sait où se trouve l'élément suivant en mémoire. Souvenez-vous : les cases ne 
    sont pas côte à côte en mémoire ; c'est la grosse différence par rapport aux tableaux. Cela offre 
    davantage de souplesse car on peut plus facilement ajouter de nouvelles cases par la suite au besoin.

En revanche, il ne sait pas quel est l'élément précédent, il est donc impossible de revenir en arrière à partir d'un élément avec ce type de liste. On parle de liste "simplement chaînée", alors que les listes "doublement chaînées" ont des pointeurs dans les deux sens et n'ont pas ce défaut. Elles sont néanmoins plus complexes.


Créez également la structure de contrôle

En plus de la structure qu'on vient de créer (que l'on dupliquera autant de fois qu'il y a d'éléments), nous allons avoir besoin d'une autre structure pour contrôler l'ensemble de la liste chaînée. Elle aura la forme suivante :


typedef struct Liste Liste;
struct Liste
{
    Element *premier;
};


Cette structure Liste contient un pointeur vers le premier élément de la liste. En effet, il faut conserver l'adresse du premier élément pour savoir où commence la liste. Si on connaît le premier élément, on peut retrouver tous les autres en "sautant" d'élément en élément à l'aide des pointeurs suivant.

Une structure composée d'une seule sous-variable n'est en général pas très utile. Néanmoins, je pense que l'on aura besoin d'y ajouter des sous-variables plus tard, je préfère donc prendre les devants en créant ici une structure. On pourrait par exemple y stocker en plus la taille de la liste, c'est-à-dire le nombre d'éléments qu'elle contient.

Nous n'aurons besoin de créer qu'un seul exemplaire de la structure Liste. Elle permet de contrôler toute la liste :

Retenez le dernier élément de la liste

Il faudra bien arrêter de parcourir la liste à un moment donné.

Avec quoi pourrait-on signifier à notre programme "Stop, ceci est le dernier élément" ?

Il suffit de faire pointer le dernier élément de la liste vers NULL, c'est-à-dire de mettre son pointeur suivant à NULL :

Nous avons créé deux structures qui permettent de gérer une liste chaînée :

  1. Element, qui correspond à un élément de la liste et que l'on peut dupliquer autant de fois que 
     nécessaire.

  2. Liste, qui contrôle l'ensemble de la liste. Nous n'en aurons besoin qu'en un seul exemplaire.

C'est bien, mais il manque encore l'essentiel : les fonctions qui vont manipuler la liste chaînée. En effet, on ne va pas modifier "à la main" le contenu des structures à chaque fois qu'on en a besoin ! Il vaut mieux passer par des fonctions qui automatisent le travail.


Gérez la liste à l'aide de fonctions


À première vue, on peut dire qu'on aura besoin de fonctions pour :

  - initialiser la liste ;

  - ajouter un élément ;

  - supprimer un élément ;

  - afficher le contenu de la liste ;

  - supprimer la liste entière.


Initialisez la liste

La fonction d'initialisation est la toute première que l'on doit appeler. Elle crée la structure de contrôle et le premier élément de la liste :


Liste *initialisation()
{
    Liste *liste = malloc(sizeof(*liste));
    Element *element = malloc(sizeof(*element));

    if (liste == NULL || element == NULL)
    {
        exit(EXIT_FAILURE);
    }

    element->nombre = 0;
    element->suivant = NULL;
    liste->premier = element;

    return liste;
}

On commence par créer la structure de contrôle liste.

Le type de données est Liste et la variable s'appelle liste.
La majuscule permet de les différencier.

On alloue dynamiquement la structure de contrôle avec un malloc. La taille à allouer est calculée automatiquement avec sizeof(*liste). L'ordinateur saura qu'il doit allouer l'espace nécessaire au stockage de la structure Liste.

On aurait aussi pu écrire sizeof(Liste), mais si plus tard on décide de modifier le type du pointeur liste, on devra aussi adapter le sizeof.

On alloue ensuite de la même manière la mémoire nécessaire au stockage du premier élément. On vérifie si les allocations dynamiques ont fonctionné. En cas d'erreur, on arrête immédiatement le programme en faisant appel à exit().
Si tout s'est bien passé, on définit les valeurs de notre premier élément :

  - la donnée nombre est mise à 0 par défaut ;

  - le pointeur suivant pointe vers NULL car le premier élément de notre liste est aussi le dernier pour le 
    moment. Rappel : le dernier élément doit pointer vers NULL pour signaler qu'il est en fin de liste.


Nous avons créé en mémoire une liste composée d'un seul élément :


Ajoutez un élément

Où va-t-on ajouter un nouvel élément ? Au début de la liste, à la fin, au milieu ?

On a le choix. Pour l'instant, je propose de l'ajouter en début de liste parce que c'est simple à comprendre.

Nous devons créer une fonction capable d'insérer un nouvel élément en début de liste. Imaginons un cas où la liste est composée de trois éléments et on souhaite en ajouter un nouveau au début :

Il va falloir adapter le pointeur premier de la liste ainsi que le pointeur suivant de notre nouvel élément pour "insérer" correctement celui-ci dans la liste :


void insertion(Liste *liste, int nvNombre)
{
    /* Création du nouvel élément */
    Element *nouveau = malloc(sizeof(*nouveau));
    if (liste == NULL || nouveau == NULL)
    {
        exit(EXIT_FAILURE);
    }
    nouveau->nombre = nvNombre;

    /* Insertion de l'élément au début de la liste */
    nouveau->suivant = liste->premier;
    liste->premier = nouveau;
}


La fonction insertion() prend en paramètres :

  - l'élément de contrôle liste(qui contient l'adresse du premier élément) ;

  - et le nombre à stocker dans le nouvel élément que l'on va créer.

Dans un premier temps, on alloue l'espace nécessaire au stockage du nouvel élément et on y place le nouveau nombre nvNombre. Il reste alors une étape délicate : l'insertion du nouvel élément dans la liste chaînée.
Nous avons ici choisi pour simplifier d'insérer l'élément en début de liste. Pour mettre à jour correctement les pointeurs, nous devons procéder dans cet ordre précis :

  1. Faire pointer notre nouvel élément vers son futur successeur, qui est l'actuel premier élément de la 
     liste.

  2. Faire pointer le pointeur premier vers notre nouvel élément.

On ne peut pas suivre ces étapes dans l'ordre inverse !
Si vous faites d'abord pointer premier vers notre nouvel élément, vous perdez l'adresse du premier élément de la liste.

Cela aura pour effet d'insérer correctement notre nouvel élément dans la liste chaînée :


Supprimez un élément

La suppression ne pose pas de difficulté supplémentaire. Il faut cependant adapter les pointeurs de la liste dans le bon ordre pour ne perdre aucune information :

void suppression(Liste *liste)
{
    if (liste == NULL)
    {
        exit(EXIT_FAILURE);
    }

    if (liste->premier != NULL)
    {
        Element *aSupprimer = liste->premier;
        liste->premier = liste->premier->suivant;
        free(aSupprimer);
    }
}


  1. On vérifie que le pointeur qu'on nous envoie n'est pas NULL, sinon on ne peut pas travailler.

  2. On vérifie ensuite qu'il y a au moins un élément dans la liste, sinon il n'y a rien à faire.

  3. Ces vérifications effectuées, on peut sauvegarder l'adresse de l'élément à supprimer dans un pointeur 
     aSupprimer.

  4. On adapte ensuite le pointeur premier vers le nouveau premier élément, qui est actuellement en seconde 
     position de la liste chaînée.

  5. On supprime l'élément correspondant à notre pointeur aSupprimer avec un free :


Il faut bien comprendre qu'on doit faire les choses dans un ordre précis :

  1. Faire pointer premier vers le second élément.

  2. Supprimer le premier élément avec un free.

Si on fait l'inverse, on perd l'adresse du second élément.


Affichez la liste chaînée


Il suffit de partir du premier élément et d'afficher chaque élément un à un en "sautant" de bloc en bloc :

void afficherListe(Liste *liste)
{
    if (liste == NULL)
    {
        exit(EXIT_FAILURE);
    }

    Element *actuel = liste->premier;

    while (actuel != NULL)
    {
        printf("%d -> ", actuel->nombre);
        actuel = actuel->suivant;
    }
    printf("NULL\n");
}


  1. On part du premier élément et on affiche le contenu de chaque élément de la liste (un nombre).

  2. On se sert du pointeur suivant pour passer à l'élément qui suit à chaque fois.

On peut tester la création de notre liste chaînée et son affichage avec un main:

int main()
{
    Liste *maListe = initialisation();

    insertion(maListe, 4);
    insertion(maListe, 8);
    insertion(maListe, 15);
    suppression(maListe);

    afficherListe(maListe);

    return 0;
}


En plus du premier élément (que l'on a laissé ici à 0), on en ajoute trois nouveaux à cette liste. Puis on en supprime un.

Au final, le contenu de la liste chaînée sera donc :

8 -> 4 -> 0 -> NULL


À vous de jouer


Nous venons de faire le tour des principales fonctions nécessaires à la gestion d'une liste chaînée. Voici d'autres fonctions que je vous invite à écrire, ce sera un très bon exercice !

  - Insertion d'un élément en milieu de liste : si on veut pouvoir ajouter un élément au milieu, il faut créer 
    une fonction spécifique qui prend un paramètre supplémentaire : l'adresse de celui qui précèdera notre 
    nouvel élément dans la liste. Votre fonction va parcourir la liste chaînée jusqu'à tomber sur l'élément 
    indiqué. Elle y insèrera le petit nouveau juste après.

  - Suppression d'un élément en milieu de liste : le principe est le même que pour l'insertion en milieu de 
    liste. Cette fois, vous devez ajouter en paramètre l'adresse de l'élément à supprimer.

  - Destruction de la liste : il suffit de supprimer tous les éléments un à un !

  - Taille de la liste : cette fonction indique combien il y a d'éléments dans votre liste chaînée. L'idéal, 
    plutôt que d'avoir à calculer cette valeur à chaque fois, serait de maintenir à jour un entier nbElements 
    dans la structure Liste. Il suffit d'incrémenter ce nombre à chaque fois qu'on ajoute un élément, et de le 
    décrémenter quand on en supprime un.

Je vous conseille de regrouper toutes les fonctions de gestion de la liste chaînée dans des fichiers liste_chainee.c et liste_chainee.h   , par exemple. Ce sera votre première bibliothèque ! Vous pourrez la réutiliser dans tous les programmes dans lesquels vous aurez besoin de listes chaînées.
Vous pouvez télécharger le projet des listes chaînées comprenant les fonctions que nous avons découvertes ensemble. Cela vous fera une bonne base de départ.


En résumé

  - Les listes chaînées constituent un nouveau moyen de stocker des données en mémoire. Elles sont plus 
    flexibles que les tableaux car on peut ajouter et supprimer des « cases » à n'importe quel moment.

  - Il n'existe pas en langage C de système de gestion de listes chaînées, il faut l'écrire nous-mêmes ! C'est 
    un excellent moyen de progresser en algorithmique et en programmation en général.

  - Dans une liste chaînée, chaque élément est une structure qui contient l'adresse de l'élément suivant.

  - Il est conseillé de créer une structure de contrôle (du type Liste dans notre cas) qui retient l'adresse 
    du premier élément.

  - Il existe une version améliorée – mais plus complexe – des listes chaînées appelée « listes doublement 
    chaînées », dans lesquelles chaque élément possède en plus l'adresse de celui qui le précède.

Vous en savez maintenant un peu plus sur ce que sont les listes chaînées. Dans le prochain chapitre, nous allons voir deux variantes de listes chaînées. Rendez-vous dans le prochain chapitre pour voir les piles et les files.

##############################################################################################################

Contrôlez l'ajout d'éléments avec les piles et les files

Les piles et les files sont deux variantes des listes chaînées qui permettent de contrôler la manière dont sont ajoutés les nouveaux éléments. Cette fois, on ne va plus insérer de nouveaux éléments au milieu de la liste, mais seulement au début ou à la fin.

Les piles et les files sont très utiles pour des programmes qui doivent traiter des données qui arrivent au fur et à mesure.

Construisez une structure de pile

Imaginez une pile de pièces : vous pouvez ajouter des pièces une à une en haut de la pile, mais aussi en enlever depuis le haut de la pile. Il est en revanche impossible d'enlever une pièce depuis le bas de la pile. Si vous voulez essayer, bon courage !

Comprenez le fonctionnement des piles
Les piles permettent de stocker des données au fur et à mesure, les unes au-dessus des autres pour pouvoir les récupérer plus tard.

Imaginons par exemple une pile de nombres entiers de type int. Si on ajoute un élément (on parle d'empilage), il sera placé au-dessus, comme dans Tetris :

L'opération qui consiste à extraire les nombres de la pile s'appelle le dépilage. Il s'agit de récupérer les données une à une, en commençant par la dernière qui vient d'être posée tout en haut de la pile.

On enlève les données au fur et à mesure, jusqu'à la dernière tout en bas de la pile.

On dit que c'est un algorithme LIFO, ce qui signifie "Last In First Out". Traduction : "Le dernier élément qui a été ajouté est le premier à sortir".

Les éléments de la pile sont reliés entre eux à la manière d'une liste chaînée. Ils possèdent un pointeur vers l'élément suivant, et ne sont donc pas forcément placés côte à côte en mémoire.

Le dernier élément (tout en bas de la pile) doit pointer vers NULL pour indiquer qu'on est arrivé au bout :

À quoi est-ce que tout cela peut bien servir, concrètement ?

Il y a des programmes où vous avez besoin de stocker des données temporairement pour les ressortir dans un ordre précis : le dernier élément que vous avez stocké doit être le premier à ressortir.

Votre système d'exploitation utilise ce type d'algorithme pour retenir l'ordre dans lequel les fonctions ont été appelées.

Exemple :

  1. Votre programme commence par la fonction main(comme toujours).

  2. Vous y appelez la fonction jouer.

  3. Cette fonction jouer fait appel à son tour à la fonction charger.

  4. Une fois que la fonction charger est terminée, on retourne à la fonction jouer  .

  5. Une fois que la fonction jouer est terminée, on retourne au main  .

  6. Enfin, une fois le main terminé, il n'y a plus de fonction à appeler, le programme s'achève.

Pour retenir l'ordre dans lequel les fonctions ont été appelées, votre ordinateur crée une pile de ces fonctions au fur et à mesure.

Grâce à cette technique, votre ordinateur sait à quelle fonction il doit retourner. Il peut empiler 100 fonctions d'affilée s'il le faut, il retrouvera toujours le main en bas !


Créez un système de pile

Comme pour les listes chaînées, il n'existe pas de système de pile intégré au langage C. Il faut donc le créer nous-mêmes.

Chaque élément de la pile aura une structure identique à celle d'une liste chaînée :

typedef struct Element Element;
struct Element
{
    int nombre;
    Element *suivant;
};


La structure de contrôle contiendra l'adresse du premier élément de la pile, celui qui se trouve tout en haut :

typedef struct Pile Pile;
struct Pile
{
    Element *premier;
};

Nous aurons besoin des fonctions suivantes :

  1. Empilage d'un élément.

  2. Dépilage d'un élément.

  3. Affichage de la pile.

Contrairement aux listes chaînées, on ne parle pas d'ajout ni de suppression. On parle d'empilage et de dépilage, car ces opérations sont limitées à un élément précis. Ainsi, on ne peut ajouter et retirer un élément qu'en haut de la pile.

Empilage d'un élément

Notre fonction empiler doit prendre en paramètre la structure de contrôle de la pile (de typePile) ainsi que le nouveau nombre à stocker.

Rappel : nous stockons ici des int   , mais rien ne vous empêche d'adapter ces exemples avec un autre type de données. On peut stocker n'importe quoi : des double, des char, des chaînes, des tableaux ou même d'autres structures !

void empiler(Pile *pile, int nvNombre)
{
    Element *nouveau = malloc(sizeof(*nouveau));
    if (pile == NULL || nouveau == NULL)
    {
        exit(EXIT_FAILURE);
    }

    nouveau->nombre = nvNombre;
    nouveau->suivant = pile->premier;
    pile->premier = nouveau;
}

L'ajout se fait en début de pile car il est impossible de le faire au milieu d'une pile : on ajoute toujours par le haut.
De ce fait, contrairement aux listes chaînées, on ne doit pas créer de fonction pour insérer un élément au milieu de la pile. Seule la fonction empiler permet d'ajouter un élément.

Dépilage d'un élément

Le rôle de la fonction de dépilage est de supprimer l'élément tout en haut de la pile. Mais elle doit aussi retourner l'élément qu'elle dépile, c'est-à-dire dans notre cas le nombre qui était stocké en haut de la pile.

C'est comme cela que l'on accède aux éléments d'une pile : en les enlevant un à un. On ne parcourt pas la pile pour aller y chercher le second ou le troisième élément. On demande toujours à récupérer le premier.

Notre fonction depiler va donc retourner un int correspondant au nombre qui se trouvait en tête de pile :

int depiler(Pile *pile)
{
    if (pile == NULL)
    {
        exit(EXIT_FAILURE);
    }

    int nombreDepile = 0;
    Element *elementDepile = pile->premier;

    if (pile != NULL && pile->premier != NULL)
    {
        nombreDepile = elementDepile->nombre;
        pile->premier = elementDepile->suivant;
        free(elementDepile);
    }

    return nombreDepile;
}


On récupère le nombre en tête de pile pour le renvoyer à la fin de la fonction. On modifie l'adresse du premier élément de la pile, puisque celui-ci change. Enfin, bien entendu, on supprime l'ancienne tête de pile grâce à free.


Affichez la pile

Bien que cette fonction ne soit pas indispensable (les fonctions empiler et depiler suffisent à gérer une pile), elle est utile pour tester le fonctionnement de notre pile, et surtout pour visualiser le résultat :

void afficherPile(Pile *pile)
{
    if (pile == NULL)
    {
        exit(EXIT_FAILURE);
    }
    Element *actuel = pile->premier;

    while (actuel != NULL)
    {
        printf("%d\n", actuel->nombre);
        actuel = actuel->suivant;
    }

    printf("\n");
}


C'est le moment de faire un main pour tester le comportement de notre pile :

int main()
{
    Pile *maPile = initialiser();

    empiler(maPile, 4);
    empiler(maPile, 8);
    empiler(maPile, 15);
    empiler(maPile, 16);
    empiler(maPile, 23);
    empiler(maPile, 42);

    printf("\nEtat de la pile :\n");
    afficherPile(maPile);

    printf("Je depile %d\n", depiler(maPile));
    printf("Je depile %d\n", depiler(maPile));

    printf("\nEtat de la pile :\n");
    afficherPile(maPile);

    return 0;
}


On affiche l'état de la pile après plusieurs empilages, et une autre fois après quelques dépilages. On affiche aussi le nombre qui est dépilé à chaque fois que l'on dépile.

Le résultat dans la console est le suivant :

Etat de la pile :
42
23
16
15
8
4

Je depile 42
Je depile 23

Etat de la pile :
16
15
8
4

Vérifiez que vous voyez bien ce qui se passe dans ce programme. Si vous comprenez cela, vous avez compris le fonctionnement des piles !

Vous pouvez télécharger le projet complet des piles si vous le désirez.


Construisez une structure de file

Les files ressemblent assez aux piles, si ce n'est qu'elles fonctionnent dans le sens inverse !

Comprenez le fonctionnement des files

Dans ce système, les éléments s'entassent les uns à la suite des autres. Le premier qu'on fait sortir de la file est le premier à être arrivé. On parle ici d'algorithme FIFO ("First In First Out", c'est-à-dire "Le premier qui arrive est le premier à sortir").

C'est ce qu'il se passe par exemple dans la file d'attente pour un guichet de cinéma, le premier arrivé est le premier servi.

En programmation, les files mettent en attente des informations dans l'ordre dans lequel elles sont arrivées.
Dans un logiciel de messagerie instantanée, trois messages reçus à peu de temps d'intervalle forment en fait une file en mémoire : ils sont placés les uns à la suite des autres. Le premier message arrivé s'afficher à l'écran, puis le second, et ainsi de suite.

En C, une file est une liste chaînée où chaque élément pointe vers le suivant, tout comme les piles. Le dernier élément de la file pointe vers NULL :


Créez un système de file

Nous allons créer une structure Element et une structure de contrôleFile:

typedef struct Element Element;
struct Element
{
    int nombre;
    Element *suivant;
};

typedef struct File File;
struct File
{
    Element *premier;
};

Comme pour les piles, chaque élément de la file sera de type Element.

À l'aide du pointeur premier, nous disposerons toujours du premier élément, et nous pourrons remonter jusqu'au dernier.


Enfilage d'un élément

La fonction d'enfilage ajoute un élément à la file.
Il y a deux cas à gérer :

  1. La file est vide : on crée la file en faisant pointer premier vers le nouvel élément créé.

  2. La file n'est pas vide : on parcourt toute la file en partant du premier élément jusqu'à arriver au 
     dernier. On rajoutera notre nouvel élément après le dernier.

Voici comment on peut faire dans la pratique :

void enfiler(File *file, int nvNombre)
{
    Element *nouveau = malloc(sizeof(*nouveau));
    if (file == NULL || nouveau == NULL)
    {
        exit(EXIT_FAILURE);
    }

    nouveau->nombre = nvNombre;
    nouveau->suivant = NULL;

    if (file->premier != NULL) /* La file n'est pas vide */
    {
        /* On se positionne à la fin de la file */
        Element *elementActuel = file->premier;
        while (elementActuel->suivant != NULL)
        {
            elementActuel = elementActuel->suivant;
        }
        elementActuel->suivant = nouveau;
    }
    else /* La file est vide, notre élément est le premier */
    {
        file->premier = nouveau;
    }
}


Vous voyez dans ce code le traitement des deux cas possibles, chacun devant être géré à part.
La différence par rapport aux piles, c'est qu'il faut se placer à la fin de la file pour ajouter le nouvel élément : un while   , et le tour est joué !


Défilage d'un élément

Le défilage ressemble étrangement au dépilage. Étant donné qu'on possède un pointeur vers le premier élément de la file, il nous suffit de l'enlever et de renvoyer sa valeur.

int defiler(File *file)
{
    if (file == NULL)
    {
        exit(EXIT_FAILURE);
    }

    int nombreDefile = 0;

    /* On vérifie s'il y a quelque chose à défiler */
    if (file->premier != NULL)
    {
        Element *elementDefile = file->premier;

        nombreDefile = elementDefile->nombre;
        file->premier = elementDefile->suivant;
        free(elementDefile);
    }

    return nombreDefile;
}

À vous de jouer !

Il resterait à écrire une fonction afficherFile  , comme on l'avait fait pour les piles, pour vérifier si la file se comporte correctement.

Réalisez ensuite un main pour faire tourner votre programme. Vous devriez obtenir ceci :


Etat de la file :
4 8 15 16 23 42

Je defile 4
Je defile 8

Etat de la file :
15 16 23 42


À terme, vous devriez pouvoir créer votre propre bibliothèque de files, avec des fichiers file.h et file.c   , par exemple.

Je vous propose de télécharger le projet complet de gestion des files, si vous le désirez. Il inclut la fonction afficherFile.


En résumé

  - Les piles et les files permettent d'organiser en mémoire des données qui arrivent au fur et à mesure.

  - Elles utilisent un système de liste chaînée pour assembler les éléments.

  - Dans le cas des piles, les données s'ajoutent les unes au-dessus des autres. Lorsqu'on extrait une donnée, 
    on récupère la dernière qui vient d'être ajoutée (la plus récente). On parle d'algorithme LIFO pour "Last 
    In First Out".

  - Dans le cas des files, les données s'ajoutent les unes à la suite des autres. On extrait la première 
    donnée à avoir été ajoutée dans la file (la plus ancienne). On parle d'algorithme FIFO pour "First In 
    First Out".

Maintenant que vous êtes incollable sur les listes chaînées, nous allons voir un dernier point, concernant les tables de hachage. Allez, plus qu’un chapitre !

##############################################################################################################

Stockez et retrouvez des données grâce aux tables de hachage

Les listes chaînées ont un gros défaut lorsqu'on souhaite lire ce qu'elles contiennent : il n'est pas possible d'accéder directement à un élément précis. Il faut parcourir la liste en avançant d'élément en élément jusqu'à trouver celui qu'on recherche. Cela pose des problèmes de performance dès que la liste chaînée devient volumineuse.

Les tables de hachage représentent une autre façon de stocker des données. Elles sont basées sur les tableaux du langage C. Elles permettent de retrouver instantanément un élément précis, que la table contienne 100, 1 000, 10 000 cases ou plus encore !


Comprenez l'intérêt d'une table de hachage

Les listes chaînées permettent d'ajouter ou de supprimer des cases à tout moment. Toutefois, elles ont quand même un gros défaut : si on cherche à récupérer un élément précis de la liste, il faut parcourir celle-ci en entier jusqu'à ce qu'on le retrouve !

Imaginons une liste chaînée qui contienne des informations sur des élèves : leur nom, leur âge et leur moyenne. Chaque élève sera représenté par une structure  Eleve  .

Nous avons travaillé auparavant sur des listes chaînées qui contenaient des int  . Cela dit, on peut stocker ce qu'on veut dans une liste, même un pointeur vers une structure, comme je le propose ici.

Si je veux retrouver les informations sur Luc Doncieux, il va falloir parcourir toute la liste pour se rendre compte qu'il était à la fin :

Bien entendu, si on avait cherché Julien Lefebvre, cela aurait été beaucoup plus rapide puisqu'il est au début de la liste. Néanmoins, pour évaluer l'efficacité d'un algorithme, on doit toujours envisager le pire des cas. Et le pire, c'est Luc.

Ici, on dit que l'algorithme de recherche d'un élément a une complexité en O(n)
, car il faut parcourir toute la liste chaînée pour retrouver un élément donné, dans le pire des cas où celui-ci est à la fin. Si la liste contient 9 éléments, il faudra 9 itérations au maximum pour retrouver un élément.

Dans cet exemple, notre liste chaînée ne contient que quatre éléments. L'ordinateur retrouvera Luc Doncieux très rapidement. Mais imaginez que celui-ci se trouve à la fin d'une liste chaînée de 10 000 éléments ! Ce n'est pas acceptable de devoir parcourir jusqu'à 10 000 éléments pour retrouver une information.

C'est là que les tables de hachage entrent en jeu.

Si vous vous souvenez bien, les tableaux ne connaissaient pas ce problème. Pour accéder à l'élément d'indice 2 dans mon tableau, il me suffisait d'écrire ceci :

  1.int tableau[4] = {12, 7, 14, 33};
  2.printf("%d", tableau[2]);

Si on lui donne tableau[2], l'ordinateur va directement à la case mémoire où se trouve stocké le nombre 14. Il ne parcourt pas les cases du tableau une à une.

Mais alors, les tableaux ne sont "pas si mauvais", en fait ? Mais dans ce cas, on perd l'avantage des listes chaînées qui nous permettaient d'ajouter et de retirer des cases à tout moment !

En effet, les listes chaînées sont plus flexibles. Les tableaux, eux, permettent un accès plus rapide. Les tables de hachage constituent quelque part un compromis entre les deux.

Il y a un défaut important avec les tableaux dont on n'a pas beaucoup parlé jusqu'ici : les cases sont identifiées par des numéros qu'on appelle des indices. Il n'est pas possible de demander à l'ordinateur : "Dis-moi quelles sont les données qui se trouvent à la case Luc Doncieux ".

Pour retrouver l'âge et la moyenne de Luc Doncieux, on ne peut donc pas écrire :

  1.tableau["Luc Doncieux"];

Ce serait pourtant pratique de pouvoir accéder à une case du tableau rien qu'avec le nom ! Eh bien avec les tables de hachage, c'est possible !

Les tables de hachage ne font pas partie du langage C. Il s'agit simplement d'un concept. On va réutiliser les briques de base du C que l'on connaît déjà pour créer un nouveau système intelligent. 

Puisque notre tableau doit forcément être numéroté par des indices, comment fait-on pour retrouver le bon numéro de case si on connaît seulement le nom "Luc Doncieux" ?

Un tableau reste un tableau, et celui-ci ne fonctionne qu'avec des indices numérotés.

Imaginez un tableau dans lequel chaque case a un indice et possède un pointeur vers une structure de type Eleve :


                               Indice       Valeur
                                 0            *   ->  Julien
		                                     Lefebvre
                                                      21 ans
                                                      14/20

                                 1            *   -> Aurélie
    		                                     Bassoli
 		                                      20 ans
		                                      15/20

                                 2            *   ->  Yann
						     Martinez
 						      18 ans
						      17/20

				 3            *   ->   Luc
						     Doncieux
						       18 ans
						       11/20



Si on veut retrouver la case correspondant à Luc Doncieux, il faut transformer son nom en indice du tableau, et donc associer chaque nom à un numéro de case :

  - Julien Lefebvre = 0 ;

  - Aurélie Bassoli = 1 ;

  - Yann Martinez = 2 ;

  - Luc Doncieux = 3.

On ne peut pas écrire tableau["Luc Doncieux"] comme je l'ai fait précédemment. Ce n'est pas valide en C.

Comment transformer une chaîne de caractères en numéro ?

Il faut écrire une fonction qui prend en entrée une chaîne de caractères, fait des calculs avec, puis retourne en sortie un numéro correspondant à cette chaîne.

Ce numéro sera l'indice de la case dans notre tableau :


Écrivez une fonction de hachage

Toute la difficulté consiste à écrire une fonction de hachage correcte. Comment transformer une chaîne de caractères en un nombre unique ?

Tout d'abord, mettons les choses au clair : une table de hachage ne contient pas 4 cases comme sur mes exemples, mais plutôt 100, 1 000 ou même plus. Peu importe la taille du tableau, la recherche de l'élément sera aussi rapide.

On dit que c'est une complexité en  O(1)
   car on trouve directement l'élément que l'on recherche. La fonction de hachage nous retourne un indice : il suffit de "sauter" directement à la case correspondante du tableau. Plus besoin de parcourir toutes les cases !

Imaginons donc un tableau de 100 cases dans lequel on va stocker des pointeurs vers des structures Eleve.

  1.Eleve* tableau[100];

Nous devons écrire une fonction qui, à partir d'un nom, génère un nombre compris entre 0 et 99 (les indices du tableau). C'est là qu'il faut être inventif. Il existe des méthodes mathématiques très complexes pour "hacher" des données, c'est-à-dire les transformer en nombres.

Les algorithmes MD5 et SHA1 sont des fonctions de hachage célèbres, mais elles sont trop poussées pour nous ici.

Vous pouvez inventer votre propre fonction de hachage. Ici, pour faire simple, je vous propose d'additionner les valeurs ASCII de chaque lettre du nom, c'est-à-dire pour Luc Doncieux, de faire la somme suivante :

  1.'L' + 'u' + 'c' + ' ' + 'D' + 'o' + 'n' + 'c' + 'i' + 'e' + 'u' + 'x'

On va toutefois avoir un problème : cette somme dépasse 100 ! Comme notre tableau ne fait que 100 cases, si on s'en tient à ça, on risque de sortir des limites du tableau.

Chaque lettre dans la table ASCII peut être numérotée jusqu'à 255. On a donc vite fait de dépasser 100.

Pour régler le problème, on peut utiliser l'opérateur modulo %  . Vous vous souvenez de lui ? Il donne le reste de la division !

Si on fait le calcul :


  1.sommeLettres % 100

… on obtiendra forcément un nombre compris entre 0 et 99.

Par exemple, si la somme fait 4 315, le reste de la division par 100 est 15. La fonction de hachage retournera donc 15.

Voici à quoi pourrait ressembler cette fameuse fonction :


int hachage(char *chaine)
{
    int i = 0, nombreHache = 0;

    for (i = 0 ; chaine[i] != '\0' ; i++)
    {
        nombreHache += chaine[i];
    }
    nombreHache %= 100;

    return nombreHache;
}


Si on lui envoie hachage("Luc Doncieux")  , elle renvoie 55. Avec hachage("Yann Martinez")  , on obtient 80.

Grâce à cette fonction de hachage, vous savez donc dans quelle case de votre tableau vous devez placer vos données ! Lorsque vous voudrez y accéder plus tard pour en récupérer les données, il suffira de hacher à nouveau le nom de la personne pour retrouver l'indice de la case du tableau où sont stockées les informations !

Je vous recommande de créer une fonction de recherche qui se chargera de hacher la clé (le nom) et de vous renvoyer un pointeur vers les données que vous recherchiez.

Cela donnerait par exemple :
infosSurLuc = rechercheTableHachage(tableau, "Luc Doncieux");


Gérez les collisions

Quand la fonction de hachage renvoie le même nombre pour deux clés différentes, on dit qu'il y a collision.

Dans notre cas, si nous avions un anagramme de Luc Doncieux qui s'appelle Luc Doncueix, la somme des lettres est la même, donc le résultat de la fonction de hachage sera le même !

Deux raisons peuvent expliquer une collision.

  1. La fonction de hachage n'est pas très performante. C'est notre cas : nous avons écrit une fonction très 
     simple (mais néanmoins suffisante) pour nos exemples. Les fonctions MD5 et SHA1 mentionnées plus tôt sont 
     de bonne qualité car elles produisent très peu de collisions. SHA1 est aujourd'hui préférée à MD5 car 
     c'est celle des deux qui en produit le moins.

  2. Le tableau dans lequel on stocke nos données est trop petit. Si on crée un tableau de 4 cases et qu'on 
     souhaite stocker 5 personnes, on aura à coup sûr une collision, c'est-à-dire que notre fonction de 
     hachage donnera le même indice pour deux noms différents.

Si une collision survient, pas de panique ! Deux solutions s'offrent à vous, au choix :

  1. L'adressage ouvert.

  2. Et le chaînage.

Solution 1 : l'adressage ouvert

S'il reste de la place dans votre tableau, vous pouvez utiliser la technique dite du hachage linéaire. Le principe est simple. La case est occupée ? Pas de problème, allez à la case suivante. Ah, elle est occupée aussi ? Allez à la suivante !

Ainsi de suite, continuez jusqu'à trouver la prochaine case libre dans le tableau. Si vous arrivez à la fin du tableau, retournez à la première case et continuez.

Cette méthode est simple à mettre en place, mais si vous avez beaucoup de collisions, vous allez passer beaucoup de temps à chercher la prochaine case libre.

Il existe des variantes (hachage double, hachage quadratique…) qui consistent à hacher à nouveau selon une autre fonction en cas de collision. Elles sont plus efficaces, mais plus complexes à mettre en place.

Solution 2 : le chaînage

Une autre solution consiste à créer une liste chaînée à l'emplacement de la collision. Vous avez deux données (ou plus) à stocker dans la même case ? Utilisez une liste chaînée et créez un pointeur vers cette liste depuis le tableau :


                          Indice     Valeur
                             0         *   -> Element 1 -> Element 2 -> NULL
                             1         *
                             2         *
                             3         *



Bien entendu, on en revient au défaut des listes chaînées : s'il y a 300 éléments à cet emplacement du tableau, il va falloir parcourir la liste chaînée jusqu'à trouver le bon.

Ici, comme vous le voyez, tout est affaire de compromis. Les listes chaînées ne sont pas toujours idéales, mais les tables de hachage ont aussi leurs limites. On peut combiner les deux pour tenter de tirer le meilleur de chacune de ces structures de données.

Quoi qu'il en soit, le point critique dans une table de hachage est la fonction de hachage. Moins elle produit de collisions, mieux c'est. À vous de trouver la fonction de hachage qui convient le mieux à votre cas !

En résumé

- Les listes chaînées sont flexibles, mais il peut être long de retrouver un élément précis à l'intérieur car 
  il faut les parcourir case par case.

- Les tables de hachage sont des tableaux. On y stocke des données à un emplacement déterminé par une fonction 
  de hachage.

- La fonction de hachage prend en entrée une clé (ex. : une chaîne de caractères) et retourne en sortie un 
  nombre.

- Ce nombre est utilisé pour déterminer à quel indice du tableau sont stockées les données.

- Une bonne fonction de hachage doit produire peu de collisions, c'est-à-dire qu'elle doit éviter de renvoyer 
  le même nombre pour deux clés différentes.

- En cas de collision, on peut utiliser l'adressage ouvert (recherche d'une autre case libre dans le tableau) 
  ou bien le chaînage (combinaison avec une liste chaînée).

Toutes les bonnes choses ont une fin, et c’est malheureusement le cas de ce cours.

Merci de l'avoir suivi !

Comme le langage C n’a plus de secret pour vous, laissez-vous tenter par le C++ !

Poursuivez votre apprentissage avec le C++

Pourquoi ne pas apprendre le C++ ?
C'est un langage cousin du C et bonne nouvelle, j'ai aussi créé des cours sur le sujet !
Avec ce que vous venez d'apprendre sur le C, vous ne serez pas dépaysé, et vous comprendrez rapidement les premiers chapitres !

Grâce au C++, vous pourrez faire de la programmation orientée objet (POO). C'est un petit peu complexe au premier abord, mais cette façon de programmer vous permet ensuite d'être très efficace !

##############################################################################################################

