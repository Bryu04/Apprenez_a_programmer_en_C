                                        Partie 5 (Bonus) : structurez vos données


Stockez les données avec les listes chaînées


Un tableau peut être représenté en mémoire comme ceci :

Un tableau de 4 cases en mémoire (représentation horizontale)

J'ai choisi ici de représenter le tableau horizontalement, mais il serait aussi possible de le présenter verticalement, peu importe.

Le problème des tableaux est qu'ils sont figés. Impossible de les agrandir (à moins d'en créer de nouveaux, plus grands) ; ou d'y insérer une case au milieu (à moins de décaler tous les autres éléments) :

Le langage C ne propose pas d'autre système de stockage de données, mais il est possible de le créer soi-même de toutes pièces. Encore faut-il savoir comment s'y prendre : c'est justement ce que ce chapitre et les suivants vous proposent de découvrir.

Une liste chaînée est un moyen d'organiser une série de données en mémoire. Cela consiste à assembler des structures en les liant entre elles à l'aide de pointeurs.

On pourrait les représenter comme ceci :


Une liste chaînée est un assemblage de structures liées par des pointeurs

Chaque élément peut contenir ce que l'on veut : un ou plusieurs int, double… En plus de cela, chaque élément possède un pointeur vers l'élément suivant :

Chaque élément contient une donnée (ex. : un int) et un pointeur vers l'élément suivant


Retenez comment les éléments sont agencés entre eux : ils forment une chaîne de pointeurs, d'où le nom de "liste chaînée".

Contrairement aux tableaux, les éléments d'une liste chaînée ne sont pas placés côte à côte dans la mémoire. Chaque case pointe vers une autre case en mémoire, qui n'est pas nécessairement stockée juste à côté.


Construisez une liste chaînée

Nous allons essayer de créer une structure qui fonctionne sur le principe que nous venons de découvrir.
Tout ce que nous allons faire ici fait appel à des techniques du langage C que vous connaissez déjà. Il n'y a aucun élément nouveau, nous allons nous contenter de créer nos propres structures et fonctions, et les transformer en un système logique, capable de se réguler tout seul.

Créez la structure de la liste des éléments

Nous allons créer une liste chaînée de nombres entiers.

On pourrait aussi bien créer une liste chaînée contenant des nombres décimaux ou même des tableaux et des structures. Le principe des listes chaînées s'adapte à n'importe quel type de données, mais ici, je propose de faire simple pour que vous compreniez bien le principe.

Chaque élément de la liste aura la structure suivante :


typedef struct Element Element;
struct Element
{
    int nombre;
    Element *suivant;
};


Que contient cette structure ?

  - Une donnée, ici un nombre de type int: on pourrait remplacer cela par n'importe quelle autre donnée (un 
    double, un tableau…). Cela correspond à ce que vous voulez stocker, c'est à vous de l'adapter en fonction 
    des besoins de votre programme.

Si on veut travailler de manière générique, l'idéal est de faire un pointeur sur void :void*. Cela permet de faire pointer vers n'importe quel type de données.

  - Un pointeur vers un élément du même type appelé suivant. C'est ce qui permet de lier les éléments les uns 
    aux autres : chaque élément sait où se trouve l'élément suivant en mémoire. Souvenez-vous : les cases ne 
    sont pas côte à côte en mémoire ; c'est la grosse différence par rapport aux tableaux. Cela offre 
    davantage de souplesse car on peut plus facilement ajouter de nouvelles cases par la suite au besoin.

En revanche, il ne sait pas quel est l'élément précédent, il est donc impossible de revenir en arrière à partir d'un élément avec ce type de liste. On parle de liste "simplement chaînée", alors que les listes "doublement chaînées" ont des pointeurs dans les deux sens et n'ont pas ce défaut. Elles sont néanmoins plus complexes.


Créez également la structure de contrôle

En plus de la structure qu'on vient de créer (que l'on dupliquera autant de fois qu'il y a d'éléments), nous allons avoir besoin d'une autre structure pour contrôler l'ensemble de la liste chaînée. Elle aura la forme suivante :


typedef struct Liste Liste;
struct Liste
{
    Element *premier;
};


Cette structure Liste contient un pointeur vers le premier élément de la liste. En effet, il faut conserver l'adresse du premier élément pour savoir où commence la liste. Si on connaît le premier élément, on peut retrouver tous les autres en "sautant" d'élément en élément à l'aide des pointeurs suivant.

Une structure composée d'une seule sous-variable n'est en général pas très utile. Néanmoins, je pense que l'on aura besoin d'y ajouter des sous-variables plus tard, je préfère donc prendre les devants en créant ici une structure. On pourrait par exemple y stocker en plus la taille de la liste, c'est-à-dire le nombre d'éléments qu'elle contient.

Nous n'aurons besoin de créer qu'un seul exemplaire de la structure Liste. Elle permet de contrôler toute la liste :

Retenez le dernier élément de la liste

Il faudra bien arrêter de parcourir la liste à un moment donné.

Avec quoi pourrait-on signifier à notre programme "Stop, ceci est le dernier élément" ?

Il suffit de faire pointer le dernier élément de la liste vers NULL, c'est-à-dire de mettre son pointeur suivant à NULL :

Nous avons créé deux structures qui permettent de gérer une liste chaînée :

  1. Element, qui correspond à un élément de la liste et que l'on peut dupliquer autant de fois que 
     nécessaire.

  2. Liste, qui contrôle l'ensemble de la liste. Nous n'en aurons besoin qu'en un seul exemplaire.

C'est bien, mais il manque encore l'essentiel : les fonctions qui vont manipuler la liste chaînée. En effet, on ne va pas modifier "à la main" le contenu des structures à chaque fois qu'on en a besoin ! Il vaut mieux passer par des fonctions qui automatisent le travail.


Gérez la liste à l'aide de fonctions


À première vue, on peut dire qu'on aura besoin de fonctions pour :

  - initialiser la liste ;

  - ajouter un élément ;

  - supprimer un élément ;

  - afficher le contenu de la liste ;

  - supprimer la liste entière.


Initialisez la liste

La fonction d'initialisation est la toute première que l'on doit appeler. Elle crée la structure de contrôle et le premier élément de la liste :


Liste *initialisation()
{
    Liste *liste = malloc(sizeof(*liste));
    Element *element = malloc(sizeof(*element));

    if (liste == NULL || element == NULL)
    {
        exit(EXIT_FAILURE);
    }

    element->nombre = 0;
    element->suivant = NULL;
    liste->premier = element;

    return liste;
}

On commence par créer la structure de contrôle liste.

Le type de données est Liste et la variable s'appelle liste.
La majuscule permet de les différencier.

On alloue dynamiquement la structure de contrôle avec un malloc. La taille à allouer est calculée automatiquement avec sizeof(*liste). L'ordinateur saura qu'il doit allouer l'espace nécessaire au stockage de la structure Liste.

On aurait aussi pu écrire sizeof(Liste), mais si plus tard on décide de modifier le type du pointeur liste, on devra aussi adapter le sizeof.

On alloue ensuite de la même manière la mémoire nécessaire au stockage du premier élément. On vérifie si les allocations dynamiques ont fonctionné. En cas d'erreur, on arrête immédiatement le programme en faisant appel à exit().
Si tout s'est bien passé, on définit les valeurs de notre premier élément :

  - la donnée nombre est mise à 0 par défaut ;

  - le pointeur suivant pointe vers NULL car le premier élément de notre liste est aussi le dernier pour le 
    moment. Rappel : le dernier élément doit pointer vers NULL pour signaler qu'il est en fin de liste.


Nous avons créé en mémoire une liste composée d'un seul élément :


Ajoutez un élément

Où va-t-on ajouter un nouvel élément ? Au début de la liste, à la fin, au milieu ?

On a le choix. Pour l'instant, je propose de l'ajouter en début de liste parce que c'est simple à comprendre.

Nous devons créer une fonction capable d'insérer un nouvel élément en début de liste. Imaginons un cas où la liste est composée de trois éléments et on souhaite en ajouter un nouveau au début :

Il va falloir adapter le pointeur premier de la liste ainsi que le pointeur suivant de notre nouvel élément pour "insérer" correctement celui-ci dans la liste :


void insertion(Liste *liste, int nvNombre)
{
    /* Création du nouvel élément */
    Element *nouveau = malloc(sizeof(*nouveau));
    if (liste == NULL || nouveau == NULL)
    {
        exit(EXIT_FAILURE);
    }
    nouveau->nombre = nvNombre;

    /* Insertion de l'élément au début de la liste */
    nouveau->suivant = liste->premier;
    liste->premier = nouveau;
}


La fonction insertion() prend en paramètres :

  - l'élément de contrôle liste(qui contient l'adresse du premier élément) ;

  - et le nombre à stocker dans le nouvel élément que l'on va créer.

Dans un premier temps, on alloue l'espace nécessaire au stockage du nouvel élément et on y place le nouveau nombre nvNombre. Il reste alors une étape délicate : l'insertion du nouvel élément dans la liste chaînée.
Nous avons ici choisi pour simplifier d'insérer l'élément en début de liste. Pour mettre à jour correctement les pointeurs, nous devons procéder dans cet ordre précis :

  1. Faire pointer notre nouvel élément vers son futur successeur, qui est l'actuel premier élément de la 
     liste.

  2. Faire pointer le pointeur premier vers notre nouvel élément.

On ne peut pas suivre ces étapes dans l'ordre inverse !
Si vous faites d'abord pointer premier vers notre nouvel élément, vous perdez l'adresse du premier élément de la liste.

Cela aura pour effet d'insérer correctement notre nouvel élément dans la liste chaînée :


Supprimez un élément

La suppression ne pose pas de difficulté supplémentaire. Il faut cependant adapter les pointeurs de la liste dans le bon ordre pour ne perdre aucune information :

void suppression(Liste *liste)
{
    if (liste == NULL)
    {
        exit(EXIT_FAILURE);
    }

    if (liste->premier != NULL)
    {
        Element *aSupprimer = liste->premier;
        liste->premier = liste->premier->suivant;
        free(aSupprimer);
    }
}


  1. On vérifie que le pointeur qu'on nous envoie n'est pas NULL, sinon on ne peut pas travailler.

  2. On vérifie ensuite qu'il y a au moins un élément dans la liste, sinon il n'y a rien à faire.

  3. Ces vérifications effectuées, on peut sauvegarder l'adresse de l'élément à supprimer dans un pointeur 
     aSupprimer.

  4. On adapte ensuite le pointeur premier vers le nouveau premier élément, qui est actuellement en seconde 
     position de la liste chaînée.

  5. On supprime l'élément correspondant à notre pointeur aSupprimer avec un free :


Il faut bien comprendre qu'on doit faire les choses dans un ordre précis :

  1. Faire pointer premier vers le second élément.

  2. Supprimer le premier élément avec un free.

Si on fait l'inverse, on perd l'adresse du second élément.


Affichez la liste chaînée


Il suffit de partir du premier élément et d'afficher chaque élément un à un en "sautant" de bloc en bloc :

void afficherListe(Liste *liste)
{
    if (liste == NULL)
    {
        exit(EXIT_FAILURE);
    }

    Element *actuel = liste->premier;

    while (actuel != NULL)
    {
        printf("%d -> ", actuel->nombre);
        actuel = actuel->suivant;
    }
    printf("NULL\n");
}


  1. On part du premier élément et on affiche le contenu de chaque élément de la liste (un nombre).

  2. On se sert du pointeur suivant pour passer à l'élément qui suit à chaque fois.

On peut tester la création de notre liste chaînée et son affichage avec un main:

int main()
{
    Liste *maListe = initialisation();

    insertion(maListe, 4);
    insertion(maListe, 8);
    insertion(maListe, 15);
    suppression(maListe);

    afficherListe(maListe);

    return 0;
}


En plus du premier élément (que l'on a laissé ici à 0), on en ajoute trois nouveaux à cette liste. Puis on en supprime un.

Au final, le contenu de la liste chaînée sera donc :

8 -> 4 -> 0 -> NULL


À vous de jouer


Nous venons de faire le tour des principales fonctions nécessaires à la gestion d'une liste chaînée. Voici d'autres fonctions que je vous invite à écrire, ce sera un très bon exercice !

  - Insertion d'un élément en milieu de liste : si on veut pouvoir ajouter un élément au milieu, il faut créer 
    une fonction spécifique qui prend un paramètre supplémentaire : l'adresse de celui qui précèdera notre 
    nouvel élément dans la liste. Votre fonction va parcourir la liste chaînée jusqu'à tomber sur l'élément 
    indiqué. Elle y insèrera le petit nouveau juste après.

  - Suppression d'un élément en milieu de liste : le principe est le même que pour l'insertion en milieu de 
    liste. Cette fois, vous devez ajouter en paramètre l'adresse de l'élément à supprimer.

  - Destruction de la liste : il suffit de supprimer tous les éléments un à un !

  - Taille de la liste : cette fonction indique combien il y a d'éléments dans votre liste chaînée. L'idéal, 
    plutôt que d'avoir à calculer cette valeur à chaque fois, serait de maintenir à jour un entier nbElements 
    dans la structure Liste. Il suffit d'incrémenter ce nombre à chaque fois qu'on ajoute un élément, et de le 
    décrémenter quand on en supprime un.

Je vous conseille de regrouper toutes les fonctions de gestion de la liste chaînée dans des fichiers liste_chainee.c et liste_chainee.h   , par exemple. Ce sera votre première bibliothèque ! Vous pourrez la réutiliser dans tous les programmes dans lesquels vous aurez besoin de listes chaînées.
Vous pouvez télécharger le projet des listes chaînées comprenant les fonctions que nous avons découvertes ensemble. Cela vous fera une bonne base de départ.


En résumé

  - Les listes chaînées constituent un nouveau moyen de stocker des données en mémoire. Elles sont plus 
    flexibles que les tableaux car on peut ajouter et supprimer des « cases » à n'importe quel moment.

  - Il n'existe pas en langage C de système de gestion de listes chaînées, il faut l'écrire nous-mêmes ! C'est 
    un excellent moyen de progresser en algorithmique et en programmation en général.

  - Dans une liste chaînée, chaque élément est une structure qui contient l'adresse de l'élément suivant.

  - Il est conseillé de créer une structure de contrôle (du type Liste dans notre cas) qui retient l'adresse 
    du premier élément.

  - Il existe une version améliorée – mais plus complexe – des listes chaînées appelée « listes doublement 
    chaînées », dans lesquelles chaque élément possède en plus l'adresse de celui qui le précède.

Vous en savez maintenant un peu plus sur ce que sont les listes chaînées. Dans le prochain chapitre, nous allons voir deux variantes de listes chaînées. Rendez-vous dans le prochain chapitre pour voir les piles et les files.

##############################################################################################################

Contrôlez l'ajout d'éléments avec les piles et les files

Les piles et les files sont deux variantes des listes chaînées qui permettent de contrôler la manière dont sont ajoutés les nouveaux éléments. Cette fois, on ne va plus insérer de nouveaux éléments au milieu de la liste, mais seulement au début ou à la fin.

Les piles et les files sont très utiles pour des programmes qui doivent traiter des données qui arrivent au fur et à mesure.

Construisez une structure de pile

Imaginez une pile de pièces : vous pouvez ajouter des pièces une à une en haut de la pile, mais aussi en enlever depuis le haut de la pile. Il est en revanche impossible d'enlever une pièce depuis le bas de la pile. Si vous voulez essayer, bon courage !

Comprenez le fonctionnement des piles
Les piles permettent de stocker des données au fur et à mesure, les unes au-dessus des autres pour pouvoir les récupérer plus tard.

Imaginons par exemple une pile de nombres entiers de type int. Si on ajoute un élément (on parle d'empilage), il sera placé au-dessus, comme dans Tetris :

L'opération qui consiste à extraire les nombres de la pile s'appelle le dépilage. Il s'agit de récupérer les données une à une, en commençant par la dernière qui vient d'être posée tout en haut de la pile.

On enlève les données au fur et à mesure, jusqu'à la dernière tout en bas de la pile.

On dit que c'est un algorithme LIFO, ce qui signifie "Last In First Out". Traduction : "Le dernier élément qui a été ajouté est le premier à sortir".

Les éléments de la pile sont reliés entre eux à la manière d'une liste chaînée. Ils possèdent un pointeur vers l'élément suivant, et ne sont donc pas forcément placés côte à côte en mémoire.

Le dernier élément (tout en bas de la pile) doit pointer vers NULL pour indiquer qu'on est arrivé au bout :

À quoi est-ce que tout cela peut bien servir, concrètement ?

Il y a des programmes où vous avez besoin de stocker des données temporairement pour les ressortir dans un ordre précis : le dernier élément que vous avez stocké doit être le premier à ressortir.

Votre système d'exploitation utilise ce type d'algorithme pour retenir l'ordre dans lequel les fonctions ont été appelées.

Exemple :

  1. Votre programme commence par la fonction main(comme toujours).

  2. Vous y appelez la fonction jouer.

  3. Cette fonction jouer fait appel à son tour à la fonction charger.

  4. Une fois que la fonction charger est terminée, on retourne à la fonction jouer  .

  5. Une fois que la fonction jouer est terminée, on retourne au main  .

  6. Enfin, une fois le main terminé, il n'y a plus de fonction à appeler, le programme s'achève.

Pour retenir l'ordre dans lequel les fonctions ont été appelées, votre ordinateur crée une pile de ces fonctions au fur et à mesure.

Grâce à cette technique, votre ordinateur sait à quelle fonction il doit retourner. Il peut empiler 100 fonctions d'affilée s'il le faut, il retrouvera toujours le main en bas !


Créez un système de pile

Comme pour les listes chaînées, il n'existe pas de système de pile intégré au langage C. Il faut donc le créer nous-mêmes.

Chaque élément de la pile aura une structure identique à celle d'une liste chaînée :

typedef struct Element Element;
struct Element
{
    int nombre;
    Element *suivant;
};


La structure de contrôle contiendra l'adresse du premier élément de la pile, celui qui se trouve tout en haut :

typedef struct Pile Pile;
struct Pile
{
    Element *premier;
};

Nous aurons besoin des fonctions suivantes :

  1. Empilage d'un élément.

  2. Dépilage d'un élément.

  3. Affichage de la pile.

Contrairement aux listes chaînées, on ne parle pas d'ajout ni de suppression. On parle d'empilage et de dépilage, car ces opérations sont limitées à un élément précis. Ainsi, on ne peut ajouter et retirer un élément qu'en haut de la pile.

Empilage d'un élément

Notre fonction empiler doit prendre en paramètre la structure de contrôle de la pile (de typePile) ainsi que le nouveau nombre à stocker.

Rappel : nous stockons ici des int   , mais rien ne vous empêche d'adapter ces exemples avec un autre type de données. On peut stocker n'importe quoi : des double, des char, des chaînes, des tableaux ou même d'autres structures !

void empiler(Pile *pile, int nvNombre)
{
    Element *nouveau = malloc(sizeof(*nouveau));
    if (pile == NULL || nouveau == NULL)
    {
        exit(EXIT_FAILURE);
    }

    nouveau->nombre = nvNombre;
    nouveau->suivant = pile->premier;
    pile->premier = nouveau;
}

L'ajout se fait en début de pile car il est impossible de le faire au milieu d'une pile : on ajoute toujours par le haut.
De ce fait, contrairement aux listes chaînées, on ne doit pas créer de fonction pour insérer un élément au milieu de la pile. Seule la fonction empiler permet d'ajouter un élément.

Dépilage d'un élément

Le rôle de la fonction de dépilage est de supprimer l'élément tout en haut de la pile. Mais elle doit aussi retourner l'élément qu'elle dépile, c'est-à-dire dans notre cas le nombre qui était stocké en haut de la pile.

C'est comme cela que l'on accède aux éléments d'une pile : en les enlevant un à un. On ne parcourt pas la pile pour aller y chercher le second ou le troisième élément. On demande toujours à récupérer le premier.

Notre fonction depiler va donc retourner un int correspondant au nombre qui se trouvait en tête de pile :

int depiler(Pile *pile)
{
    if (pile == NULL)
    {
        exit(EXIT_FAILURE);
    }

    int nombreDepile = 0;
    Element *elementDepile = pile->premier;

    if (pile != NULL && pile->premier != NULL)
    {
        nombreDepile = elementDepile->nombre;
        pile->premier = elementDepile->suivant;
        free(elementDepile);
    }

    return nombreDepile;
}


On récupère le nombre en tête de pile pour le renvoyer à la fin de la fonction. On modifie l'adresse du premier élément de la pile, puisque celui-ci change. Enfin, bien entendu, on supprime l'ancienne tête de pile grâce à free.


Affichez la pile

Bien que cette fonction ne soit pas indispensable (les fonctions empiler et depiler suffisent à gérer une pile), elle est utile pour tester le fonctionnement de notre pile, et surtout pour visualiser le résultat :

void afficherPile(Pile *pile)
{
    if (pile == NULL)
    {
        exit(EXIT_FAILURE);
    }
    Element *actuel = pile->premier;

    while (actuel != NULL)
    {
        printf("%d\n", actuel->nombre);
        actuel = actuel->suivant;
    }

    printf("\n");
}


C'est le moment de faire un main pour tester le comportement de notre pile :

int main()
{
    Pile *maPile = initialiser();

    empiler(maPile, 4);
    empiler(maPile, 8);
    empiler(maPile, 15);
    empiler(maPile, 16);
    empiler(maPile, 23);
    empiler(maPile, 42);

    printf("\nEtat de la pile :\n");
    afficherPile(maPile);

    printf("Je depile %d\n", depiler(maPile));
    printf("Je depile %d\n", depiler(maPile));

    printf("\nEtat de la pile :\n");
    afficherPile(maPile);

    return 0;
}


On affiche l'état de la pile après plusieurs empilages, et une autre fois après quelques dépilages. On affiche aussi le nombre qui est dépilé à chaque fois que l'on dépile.

Le résultat dans la console est le suivant :

Etat de la pile :
42
23
16
15
8
4

Je depile 42
Je depile 23

Etat de la pile :
16
15
8
4

Vérifiez que vous voyez bien ce qui se passe dans ce programme. Si vous comprenez cela, vous avez compris le fonctionnement des piles !

Vous pouvez télécharger le projet complet des piles si vous le désirez.


Construisez une structure de file

Les files ressemblent assez aux piles, si ce n'est qu'elles fonctionnent dans le sens inverse !

Comprenez le fonctionnement des files

Dans ce système, les éléments s'entassent les uns à la suite des autres. Le premier qu'on fait sortir de la file est le premier à être arrivé. On parle ici d'algorithme FIFO ("First In First Out", c'est-à-dire "Le premier qui arrive est le premier à sortir").

C'est ce qu'il se passe par exemple dans la file d'attente pour un guichet de cinéma, le premier arrivé est le premier servi.

En programmation, les files mettent en attente des informations dans l'ordre dans lequel elles sont arrivées.
Dans un logiciel de messagerie instantanée, trois messages reçus à peu de temps d'intervalle forment en fait une file en mémoire : ils sont placés les uns à la suite des autres. Le premier message arrivé s'afficher à l'écran, puis le second, et ainsi de suite.

En C, une file est une liste chaînée où chaque élément pointe vers le suivant, tout comme les piles. Le dernier élément de la file pointe vers NULL :


Créez un système de file

Nous allons créer une structure Element et une structure de contrôleFile:

typedef struct Element Element;
struct Element
{
    int nombre;
    Element *suivant;
};

typedef struct File File;
struct File
{
    Element *premier;
};

Comme pour les piles, chaque élément de la file sera de type Element.

À l'aide du pointeur premier, nous disposerons toujours du premier élément, et nous pourrons remonter jusqu'au dernier.


Enfilage d'un élément

La fonction d'enfilage ajoute un élément à la file.
Il y a deux cas à gérer :

  1. La file est vide : on crée la file en faisant pointer premier vers le nouvel élément créé.

  2. La file n'est pas vide : on parcourt toute la file en partant du premier élément jusqu'à arriver au 
     dernier. On rajoutera notre nouvel élément après le dernier.

Voici comment on peut faire dans la pratique :

void enfiler(File *file, int nvNombre)
{
    Element *nouveau = malloc(sizeof(*nouveau));
    if (file == NULL || nouveau == NULL)
    {
        exit(EXIT_FAILURE);
    }

    nouveau->nombre = nvNombre;
    nouveau->suivant = NULL;

    if (file->premier != NULL) /* La file n'est pas vide */
    {
        /* On se positionne à la fin de la file */
        Element *elementActuel = file->premier;
        while (elementActuel->suivant != NULL)
        {
            elementActuel = elementActuel->suivant;
        }
        elementActuel->suivant = nouveau;
    }
    else /* La file est vide, notre élément est le premier */
    {
        file->premier = nouveau;
    }
}


Vous voyez dans ce code le traitement des deux cas possibles, chacun devant être géré à part.
La différence par rapport aux piles, c'est qu'il faut se placer à la fin de la file pour ajouter le nouvel élément : un while   , et le tour est joué !


Défilage d'un élément

Le défilage ressemble étrangement au dépilage. Étant donné qu'on possède un pointeur vers le premier élément de la file, il nous suffit de l'enlever et de renvoyer sa valeur.

int defiler(File *file)
{
    if (file == NULL)
    {
        exit(EXIT_FAILURE);
    }

    int nombreDefile = 0;

    /* On vérifie s'il y a quelque chose à défiler */
    if (file->premier != NULL)
    {
        Element *elementDefile = file->premier;

        nombreDefile = elementDefile->nombre;
        file->premier = elementDefile->suivant;
        free(elementDefile);
    }

    return nombreDefile;
}

À vous de jouer !

Il resterait à écrire une fonction afficherFile  , comme on l'avait fait pour les piles, pour vérifier si la file se comporte correctement.

Réalisez ensuite un main pour faire tourner votre programme. Vous devriez obtenir ceci :


Etat de la file :
4 8 15 16 23 42

Je defile 4
Je defile 8

Etat de la file :
15 16 23 42


À terme, vous devriez pouvoir créer votre propre bibliothèque de files, avec des fichiers file.h et file.c   , par exemple.

Je vous propose de télécharger le projet complet de gestion des files, si vous le désirez. Il inclut la fonction afficherFile.


En résumé

  - Les piles et les files permettent d'organiser en mémoire des données qui arrivent au fur et à mesure.

  - Elles utilisent un système de liste chaînée pour assembler les éléments.

  - Dans le cas des piles, les données s'ajoutent les unes au-dessus des autres. Lorsqu'on extrait une donnée, 
    on récupère la dernière qui vient d'être ajoutée (la plus récente). On parle d'algorithme LIFO pour "Last 
    In First Out".

  - Dans le cas des files, les données s'ajoutent les unes à la suite des autres. On extrait la première 
    donnée à avoir été ajoutée dans la file (la plus ancienne). On parle d'algorithme FIFO pour "First In 
    First Out".

Maintenant que vous êtes incollable sur les listes chaînées, nous allons voir un dernier point, concernant les tables de hachage. Allez, plus qu’un chapitre !

##############################################################################################################

